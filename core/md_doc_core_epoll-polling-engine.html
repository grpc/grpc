<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC Core: &lt;tt&gt;epoll&lt;/tt&gt;-based pollset implementation in gRPC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC Core
   &#160;<span id="projectnumber">33.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><code>epoll</code>-based pollset implementation in gRPC </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Sree Kuchibhotla (sreek@) [May - 2016] (Design input from Craig Tiller and David Klempner)</p>
<blockquote class="doxtable">
<p>Status: As of June 2016, this change is implemented and merged. </p>
</blockquote>
<blockquote class="doxtable">
<ul>
<li>The bulk of the functionality is in: <a href="https://github.com/grpc/grpc/blob/master/src/core/lib/iomgr/ev_epollsig_linux.c">ev_epollsig_linux.c</a></li>
<li>Pull request: <a href="https://github.com/grpc/grpc/pull/6803">https://github.com/grpc/grpc/pull/6803</a> </li>
</ul>
</blockquote>
<h1><a class="anchor" id="autotoc_md92"></a>
1. Introduction</h1>
<p>The document talks about the proposed changes to <code>epoll</code>-based implementation of pollsets in gRPC. Section-2 gives an overview of the current implementation, Section-3 talks about the problems in the current implementation and finally Section-4 talks about the proposed changes.</p>
<h1><a class="anchor" id="autotoc_md93"></a>
2. Current &lt;tt&gt;epoll&lt;/tt&gt;-based implementation in gRPC</h1>
<p><img src="images/old_epoll_impl.png" alt="image" class="inline"/></p>
<p><b>Figure 1: Current implementation</b></p>
<p>A gRPC client or a server can have more than one completion queue. Each completion queue creates a pollset.</p>
<p>The gRPC core library does not create any threads[^1] on its own and relies on the application using the gRPC core library to provide the threads. A thread starts to poll for events by calling the gRPC core surface APIs <code><a class="el" href="grpc_8h.html#ab43d55077bcbeb324044d3dcd26a5c80" title="Blocks until an event is available, the completion queue is being shut down, or deadline is reached.">grpc_completion_queue_next()</a></code> or <code><a class="el" href="grpc_8h.html#a0292bf7a0c794771cd66766dc4b8276c" title="Blocks until an event with tag &#39;tag&#39; is available, the completion queue is being shutdown or deadline...">grpc_completion_queue_pluck()</a></code>. More than one thread can call <code><a class="el" href="grpc_8h.html#ab43d55077bcbeb324044d3dcd26a5c80" title="Blocks until an event is available, the completion queue is being shut down, or deadline is reached.">grpc_completion_queue_next()</a></code>on the same completion queue[^2].</p>
<p>A file descriptor can be in more than one completion queue. There are examples in the next section that show how this can happen.</p>
<p>When an event of interest happens in a pollset, multiple threads are woken up and there are no guarantees on which thread actually ends up performing the work i.e executing the callbacks associated with that event. The thread that performs the work finally queues a completion event <code>grpc_cq_completion</code> on the appropriate completion queue and "kicks" (i.e wakes ups) the thread that is actually interested in that event (which can be itself - in which case there is no thread hop)</p>
<p>For example, in <b>Figure 1</b>, if <code>fd1</code> becomes readable, any one of the threads i.e <em>Threads 1</em> to <em>Threads K</em> or <em>Thread P</em>, might be woken up. Let's say <em>Thread P</em> was calling a <code><a class="el" href="grpc_8h.html#a0292bf7a0c794771cd66766dc4b8276c" title="Blocks until an event with tag &#39;tag&#39; is available, the completion queue is being shutdown or deadline...">grpc_completion_queue_pluck()</a></code> and was actually interested in the event on <code>fd1</code> but <em>Thread 1</em> woke up. In this case, <em>Thread 1</em> executes the callbacks and finally kicks <em>Thread P</em> by signalling <code>event_fd_P</code>. <em>Thread P</em> wakes up, realizes that there is a new completion event for it and returns from <code><a class="el" href="grpc_8h.html#a0292bf7a0c794771cd66766dc4b8276c" title="Blocks until an event with tag &#39;tag&#39; is available, the completion queue is being shutdown or deadline...">grpc_completion_queue_pluck()</a></code> to its caller.</p>
<h1><a class="anchor" id="autotoc_md94"></a>
3. Issues in the current architecture</h1>
<h2><a class="anchor" id="autotoc_md95"></a>
&lt;em&gt;Thundering Herds&lt;/em&gt;</h2>
<p>If multiple threads concurrently call <code>epoll_wait()</code>, we are guaranteed that only one thread is woken up if one of the <code>fds</code> in the set becomes readable/writable. However, in our current implementation, the threads do not directly call a blocking <code>epoll_wait()</code>[^3]. Instead, they call <code>poll()</code> on the set containing <code>[event_fd</code>[^4]<code>, epoll_fd]</code>. **(see Figure 1)**</p>
<p>Considering the fact that an <code>fd</code> can be in multiple <code>pollsets</code> and that each <code>pollset</code> might have multiple poller threads, it means that whenever an <code>fd</code> becomes readable/writable, all the threads in all the <code>pollsets</code> (in which that <code>fd</code> is present) are woken up.</p>
<p>The performance impact of this would be more conspicuous on the server side. Here are a two examples of thundering herds on the server side.</p>
<p>Example 1: Listening fds on server</p>
<ul>
<li>A gRPC server can have multiple server completion queues (i.e completion queues which are used to listen for incoming channels).</li>
<li>A gRPC server can also listen on more than one TCP-port.</li>
<li>A listening socket is created for each port the gRPC server would be listening on.</li>
<li>Every listening socket's fd is added to all the server completion queues' pollsets. (Currently we do not do any sharding of the listening fds across these pollsets).</li>
</ul>
<p>This means that for every incoming new channel, all the threads waiting on all the pollsets are woken up.</p>
<p>Example 2: New Incoming-channel fds on server</p>
<ul>
<li>Currently, every new incoming channel's <code>fd</code> (i.e the socket <code>fd</code> that is returned by doing an <code>accept()</code> on the new incoming channel) is added to all the server completion queues' pollsets [^5]).</li>
<li>Clearly, this would also cause all thundering herd problem for every read onthat fd</li>
</ul>
<p>There are other scenarios especially on the client side where an fd can end up being on multiple pollsets which would cause thundering herds on the clients.</p>
<h1><a class="anchor" id="autotoc_md96"></a>
4. Proposed changes to the current &lt;tt&gt;epoll&lt;/tt&gt;-based polling implementation:</h1>
<p>The main idea in this proposal is to group 'related' <code>fds</code> into a single epoll-based set. This would ensure that only one thread wakes up in case of an event on one of the <code>fds</code> in the epoll set.</p>
<p>To accomplish this, we introduce a new abstraction called <code>polling_island</code> which will have an epoll set underneath (See <b>Figure 2</b> below). A <code>polling_island</code> contains the following:</p>
<ul>
<li><code>epoll_fd</code>: The file descriptor of the underlying epoll set</li>
<li><code>fd_set</code>: The set of 'fds' in the pollset island i.e in the epoll set (The pollset island merging operation described later requires the list of fds in the pollset island and currently there is no API available to enumerate all the fds in an epoll set)</li>
<li><code>event_fd</code>: A level triggered <em>event fd</em> that is used to wake up all the threads waiting on this epoll set (Note: This <code>event_fd</code> is added to the underlying epoll set during pollset island creation. This is useful in the pollset island merging operation described later)</li>
<li><code>merged_to</code>: The polling island into which this one merged. See section 4.2 (case 2) for more details on this. Also note that if <code>merged_to</code> is set, all the other fields in this polling island are not used anymore</li>
</ul>
<p>In this new model, only one thread wakes up whenever an event of interest happens in an epoll set.</p>
<p><img src="images/new_epoll_impl.png" alt="drawing" class="inline"/></p>
<p><b>Figure 2: Proposed changes</b></p>
<h2><a class="anchor" id="autotoc_md97"></a>
4.1 Relation between &lt;tt&gt;fd&lt;/tt&gt;, &lt;tt&gt;pollset&lt;/tt&gt; and &lt;tt&gt;polling_island:&lt;/tt&gt;</h2>
<ul>
<li>An <code>fd</code> may belong to multiple <code>pollsets</code> but belongs to exactly one <code>polling_island</code></li>
<li>A <code>pollset</code> belongs to exactly one <code>polling_island</code></li>
<li>An <code>fd</code> and the <code>pollset(s</code>) it belongs to, have same <code>polling_island</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md98"></a>
4.2 Algorithm to add an &lt;tt&gt;fd&lt;/tt&gt; to a &lt;tt&gt;pollset&lt;/tt&gt;</h2>
<p>There are two cases to check here:</p>
<ul>
<li><b>Case 1:</b> Both <code>fd</code> and <code>pollset</code> already belong to the same <code>polling_island</code><ul>
<li>This is straightforward and nothing really needs to be done here</li>
</ul>
</li>
<li><b>Case 2:</b> The <code>fd</code>and <code>pollset</code> point to different <code>polling_islands</code>: In this case we <em>merge</em> both the polling islands i.e:<ul>
<li>Add all the <code>fds</code> from the smaller <code>polling_island</code>to the larger <code>polling_island</code> and update the <code>merged_to</code> pointer on the smaller island to point to the larger island.</li>
<li>Wake up all the threads waiting on the smaller <code>polling_island</code>'s <code>epoll_fd</code> (by signaling the <code>event_fd</code> on that island) and make them now wait on the larger <code>polling_island</code>'s <code>epoll_fd</code></li>
<li>Update <code>fd</code> and <code>pollset</code> to now point to the larger <code>polling_island</code></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md99"></a>
4.3 Directed wakeups:</h2>
<p>The new implementation, just like the current implementation, does not provide us any guarantees that the thread that is woken up is the thread that is actually interested in the event. So the thread that woke up executes the callbacks and finally has to 'kick' the appropriate polling thread interested in the event.</p>
<p>In the current implementation, every polling thread also had a <code>event_fd</code> on which it was listening to and hence waking it up was as simple as signaling that <code>event_fd</code>. However, using an <code>event_fd</code> also meant that every thread has to use a <code>poll()</code> (on <code>event_fd</code> and <code>epoll_fd</code>) instead of doing an <code>epoll_wait()</code> and this resulted in the thundering herd problems described above.</p>
<p>The proposal here is to use signals and kicking a thread would just be sending a signal to that thread. Unfortunately there are only a few signals available on POSIX systems and most of them have pre-determined behavior leaving only a few signals <code>SIGUSR1</code>, <code>SIGUSR2</code> and <code>SIGRTx (SIGRTMIN to SIGRTMAX)</code> for custom use.</p>
<p>The calling application might have registered other signal handlers for these signals. `We will provide a new API where the applications can "give a signal number" to gRPC library to use for this purpose.</p>
<div class="fragment"><div class="line">void grpc_use_signal(int signal_num)</div>
</div><!-- fragment --><p>If the calling application does not provide a signal number, then the gRPC library will relegate to using a model similar to the current implementation (where every thread does a blocking <code>poll()</code> on its <code>wakeup_fd</code> and the <code>epoll_fd</code>). The function<code>psi_wait()</code>in figure 2 implements this logic.</p>
<p>**&gt;&gt; **(<b>NOTE</b>: Or alternatively, we can implement a turnstile polling (i.e having only one thread calling <code>epoll_wait()</code> on the epoll set at any time - which all other threads call poll on their <code>wakeup_fds</code>) in case of not getting a signal number from the applications.</p>
<h1><a class="anchor" id="autotoc_md100"></a>
Notes</h1>
<p>[^1]: Only exception is in case of name-resolution</p>
<p>[^2]: However, a <code><a class="el" href="grpc_8h.html#ab43d55077bcbeb324044d3dcd26a5c80" title="Blocks until an event is available, the completion queue is being shut down, or deadline is reached.">grpc_completion_queue_next()</a></code> and <code><a class="el" href="grpc_8h.html#a0292bf7a0c794771cd66766dc4b8276c" title="Blocks until an event with tag &#39;tag&#39; is available, the completion queue is being shutdown or deadline...">grpc_completion_queue_pluck()</a></code> must not be called in parallel on the same completion queue</p>
<p>[^3]: The threads first do a blocking<code>poll()</code> with <code>[wakeup_fd, epoll_fd]</code>. If the <code>poll()</code> returns due to an event of interest in the epoll set, they then call a non-blocking i.e a zero-timeout <code>epoll_wait()</code> on the <code>epoll_fd</code></p>
<p>[^4]: <code>event_fd</code> is the linux platform specific implementation of <code>grpc_wakeup_fd</code>. A <code>wakeup_fd</code> is used to wake up polling threads typically when the event for which the polling thread is waiting is already completed by some other thread. It is also used to wake up the polling threads in case of shutdowns or to re-evaluate the poller's interest in the fds to poll (the last scenario is only in case of <code>poll</code>-based (not <code>epoll</code>-based) implementation of <code>pollsets</code>).</p>
<p>[^5]: See more details about the issue here <a href="https://github.com/grpc/grpc/issues/5470">https://github.com/grpc/grpc/issues/5470</a> and for a proposed fix here: <a href="https://github.com/grpc/grpc/pull/6149">https://github.com/grpc/grpc/pull/6149</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 27 2023 17:50:37 for GRPC Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
