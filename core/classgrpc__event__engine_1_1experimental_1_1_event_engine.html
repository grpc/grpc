<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC Core: grpc_event_engine::experimental::EventEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC Core
   &#160;<span id="projectnumber">16.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegrpc__event__engine.html">grpc_event_engine</a></li><li class="navelem"><a class="el" href="namespacegrpc__event__engine_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html">EventEngine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">grpc_event_engine::experimental::EventEngine Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> encapsulates all platform-specific behaviors related to low level network I/O, timers, asynchronous execution, and DNS resolution.  
 <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="event__engine_8h_source.html">event_engine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html" title="The DNSResolver that provides asynchronous resolution.">DNSResolver</a> that provides asynchronous resolution.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html" title="An Endpoint represents one end of a connection between a gRPC client and server.">Endpoint</a> represents one end of a connection between a gRPC client and server.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="An EventEngine Listener listens for incoming connection requests from gRPC clients and initiates requ...">Listener</a> listens for incoming connection requests from gRPC clients and initiates request processing once connections are established.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thin wrapper around a platform-specific sockaddr type.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_run_options.html">RunOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intended for future expansion of Task run functionality.  <a href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_run_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback handle, used to cancel a callback.  <a href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae2d013587133788e31d8984cf0783050"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a> = std::function&lt; void(absl::Status)&gt;</td></tr>
<tr class="memdesc:ae2d013587133788e31d8984cf0783050"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic callable function.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">More...</a><br /></td></tr>
<tr class="separator:ae2d013587133788e31d8984cf0783050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38e4bd2a5559809d16246442460af3d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">OnConnectCallback</a> = std::function&lt; void(absl::StatusOr&lt; std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a> &gt; &gt;)&gt;</td></tr>
<tr class="memdesc:ad38e4bd2a5559809d16246442460af3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new connection is established.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">More...</a><br /></td></tr>
<tr class="separator:ad38e4bd2a5559809d16246442460af3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3fbe3f983ef770110fe7647fd143b9d8"><td class="memItemLeft" align="right" valign="top">virtual absl::StatusOr&lt; std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3fbe3f983ef770110fe7647fd143b9d8">CreateListener</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#ac9c54c9ad654a12ad80a7248bcdd1edd">Listener::AcceptCallback</a> on_accept, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a> on_shutdown, const ChannelArgs &amp;args, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator_factory.html">SliceAllocatorFactory</a> slice_allocator_factory)=0</td></tr>
<tr class="memdesc:a3fbe3f983ef770110fe7647fd143b9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a network listener / server.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3fbe3f983ef770110fe7647fd143b9d8">More...</a><br /></td></tr>
<tr class="separator:a3fbe3f983ef770110fe7647fd143b9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f18420478c34c4f2beca2ed62bcc259"><td class="memItemLeft" align="right" valign="top">virtual absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3f18420478c34c4f2beca2ed62bcc259">Connect</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">OnConnectCallback</a> on_connect, const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a> &amp;addr, const ChannelArgs &amp;args, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator.html">SliceAllocator</a> slice_allocator, absl::Time deadline)=0</td></tr>
<tr class="memdesc:a3f18420478c34c4f2beca2ed62bcc259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a client network connection to a remote network listener.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3f18420478c34c4f2beca2ed62bcc259">More...</a><br /></td></tr>
<tr class="separator:a3f18420478c34c4f2beca2ed62bcc259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283885518525b71339f166e15932cd1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aa283885518525b71339f166e15932cd1">~EventEngine</a> ()=default</td></tr>
<tr class="separator:aa283885518525b71339f166e15932cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e34811ee9c4ee8374b77f9bce673f1"><td class="memItemLeft" align="right" valign="top">virtual absl::StatusOr&lt; std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad5e34811ee9c4ee8374b77f9bce673f1">GetDNSResolver</a> ()=0</td></tr>
<tr class="memdesc:ad5e34811ee9c4ee8374b77f9bce673f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an instance of a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html" title="The DNSResolver that provides asynchronous resolution.">DNSResolver</a>.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad5e34811ee9c4ee8374b77f9bce673f1">More...</a><br /></td></tr>
<tr class="separator:ad5e34811ee9c4ee8374b77f9bce673f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c24cd7623fcd6c28f07428a5efb528"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a70c24cd7623fcd6c28f07428a5efb528">Run</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a> fn, <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_run_options.html">RunOptions</a> opts)=0</td></tr>
<tr class="memdesc:a70c24cd7623fcd6c28f07428a5efb528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a callback as soon as possible.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a70c24cd7623fcd6c28f07428a5efb528">More...</a><br /></td></tr>
<tr class="separator:a70c24cd7623fcd6c28f07428a5efb528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f692931265b6cc56fa4c23e506c376"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ab3f692931265b6cc56fa4c23e506c376">RunAt</a> (absl::Time when, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a> fn, <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_run_options.html">RunOptions</a> opts)=0</td></tr>
<tr class="memdesc:ab3f692931265b6cc56fa4c23e506c376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonymous with scheduling an alarm to run at time <em>when</em>.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ab3f692931265b6cc56fa4c23e506c376">More...</a><br /></td></tr>
<tr class="separator:ab3f692931265b6cc56fa4c23e506c376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93effe8154cd154075dfaf54a083c8de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a93effe8154cd154075dfaf54a083c8de">TryCancel</a> (<a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> handle)=0</td></tr>
<tr class="memdesc:a93effe8154cd154075dfaf54a083c8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately tries to cancel a callback.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a93effe8154cd154075dfaf54a083c8de">More...</a><br /></td></tr>
<tr class="separator:a93effe8154cd154075dfaf54a083c8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25339c7fab530be8234a1b06e4b3311a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a25339c7fab530be8234a1b06e4b3311a">Shutdown</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a> on_shutdown_complete)=0</td></tr>
<tr class="memdesc:a25339c7fab530be8234a1b06e4b3311a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately run all callbacks with status indicating the shutdown.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a25339c7fab530be8234a1b06e4b3311a">More...</a><br /></td></tr>
<tr class="separator:a25339c7fab530be8234a1b06e4b3311a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> encapsulates all platform-specific behaviors related to low level network I/O, timers, asynchronous execution, and DNS resolution. </p>
<p>This interface allows developers to provide their own event management and network stacks. Motivating uses cases for supporting custom EventEngines include the ability to hook into external event loops, and using different <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> instances for each channel to better insulate network I/O and callback processing from other channels.</p>
<p>A default cross-platform <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> instance is provided by gRPC.</p>
<p>LIFESPAN AND OWNERSHIP</p>
<p>gRPC takes shared ownership of EventEngines via std::shared_ptrs to ensure that the engines remain available until they are no longer needed. Depending on the use case, engines may live until gRPC is shut down.</p>
<p>EXAMPLE USAGE (Not yet implemented)</p>
<p>Custom EventEngines can be specified per channel, and allow configuration for both clients and servers. To set a custom <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> for a client channel, you can do something like the following:</p>
<p>ChannelArguments args; std::shared_ptr&lt;EventEngine&gt; engine = std::make_shared&lt;MyEngine&gt;(...); args.SetEventEngine(engine); MyAppClient client(grpc::CreateCustomChannel( "localhost:50051", grpc::InsecureChannelCredentials(), args));</p>
<p>A gRPC server can use a custom <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> by calling the ServerBuilder::SetEventEngine method:</p>
<p>ServerBuilder builder; std::shared_ptr&lt;EventEngine&gt; engine = std::make_shared&lt;MyEngine&gt;(...); builder.SetEventEngine(engine); std::unique_ptr&lt;Server&gt; server(builder.BuildAndStart()); server-&gt;Wait(); </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae2d013587133788e31d8984cf0783050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d013587133788e31d8984cf0783050">&#9670;&nbsp;</a></span>Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">grpc_event_engine::experimental::EventEngine::Callback</a> =  std::function&lt;void(absl::Status)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic callable function. </p>
<p>The first argument to all callbacks is an absl::Status indicating the status of the operation associated with this callback. Each <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> method that takes a callback parameter, defines the expected sets and meanings of statuses for that use case. </p>

</div>
</div>
<a id="ad38e4bd2a5559809d16246442460af3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38e4bd2a5559809d16246442460af3d">&#9670;&nbsp;</a></span>OnConnectCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">grpc_event_engine::experimental::EventEngine::OnConnectCallback</a> =  std::function&lt;void(absl::StatusOr&lt;std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a>&gt; &gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new connection is established. </p>
<p>If the connection attempt was not successful, implementations should pass the appropriate statuses to this callback. For example, callbacks might expect to receive DEADLINE_EXCEEDED statuses when appropriate, or CANCELLED statuses on <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> shutdown. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa283885518525b71339f166e15932cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa283885518525b71339f166e15932cd1">&#9670;&nbsp;</a></span>~EventEngine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual grpc_event_engine::experimental::EventEngine::~EventEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f18420478c34c4f2beca2ed62bcc259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f18420478c34c4f2beca2ed62bcc259">&#9670;&nbsp;</a></span>Connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual absl::Status grpc_event_engine::experimental::EventEngine::Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">OnConnectCallback</a>&#160;</td>
          <td class="paramname"><em>on_connect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChannelArgs &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator.html">SliceAllocator</a>&#160;</td>
          <td class="paramname"><em>slice_allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Time&#160;</td>
          <td class="paramname"><em>deadline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a client network connection to a remote network listener. </p>
<p><em>Connect</em> may return an error status immediately if there was a failure in the synchronous part of establishing a connection. In that event, the <em>on_connect</em> callback <em>will not</em> have been executed. Otherwise, it is expected that the <em>on_connect</em> callback will be asynchronously executed exactly once by the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a>.</p>
<p>Implementation Note: it is important that the <em>slice_allocator</em> be used for all read/write buffer allocations in the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> implementation. This allows gRPC's <em>ResourceQuota</em> system to monitor and control memory usage with graceful degradation mechanisms. Please see the <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator.html">SliceAllocator</a></em> API for more information. </p>

</div>
</div>
<a id="a3fbe3f983ef770110fe7647fd143b9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbe3f983ef770110fe7647fd143b9d8">&#9670;&nbsp;</a></span>CreateListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual absl::StatusOr&lt;std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a>&gt; &gt; grpc_event_engine::experimental::EventEngine::CreateListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#ac9c54c9ad654a12ad80a7248bcdd1edd">Listener::AcceptCallback</a>&#160;</td>
          <td class="paramname"><em>on_accept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a>&#160;</td>
          <td class="paramname"><em>on_shutdown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ChannelArgs &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator_factory.html">SliceAllocatorFactory</a>&#160;</td>
          <td class="paramname"><em>slice_allocator_factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create a network listener / server. </p>
<p>Once a <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="An EventEngine Listener listens for incoming connection requests from gRPC clients and initiates requ...">Listener</a></em> is created and started, the <em>on_accept</em> callback will be called once asynchronously for each established connection. Note that unlike other callbacks, there is no status code parameter since the callback will only be called in healthy scenarios where connections can be accepted.</p>
<p>This method may return a non-OK status immediately if an error was encountered in any synchronous steps required to create the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="An EventEngine Listener listens for incoming connection requests from gRPC clients and initiates requ...">Listener</a>. In this case, <em>on_shutdown</em> will never be called.</p>
<p>If this method returns a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="An EventEngine Listener listens for incoming connection requests from gRPC clients and initiates requ...">Listener</a>, then <em>on_shutdown</em> will be invoked exactly once, when the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="An EventEngine Listener listens for incoming connection requests from gRPC clients and initiates requ...">Listener</a> is shut down. The status passed to it will indicate if there was a problem during shutdown.</p>
<p>The provided <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator_factory.html">SliceAllocatorFactory</a></em> is used to create <em>SliceAllocators</em> for <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html" title="An Endpoint represents one end of a connection between a gRPC client and server.">Endpoint</a> construction. </p>

</div>
</div>
<a id="ad5e34811ee9c4ee8374b77f9bce673f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e34811ee9c4ee8374b77f9bce673f1">&#9670;&nbsp;</a></span>GetDNSResolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual absl::StatusOr&lt;std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a>&gt; &gt; grpc_event_engine::experimental::EventEngine::GetDNSResolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an instance of a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html" title="The DNSResolver that provides asynchronous resolution.">DNSResolver</a>. </p>

</div>
</div>
<a id="a70c24cd7623fcd6c28f07428a5efb528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c24cd7623fcd6c28f07428a5efb528">&#9670;&nbsp;</a></span>Run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> grpc_event_engine::experimental::EventEngine::Run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_run_options.html">RunOptions</a>&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run a callback as soon as possible. </p>
<p>The <em>fn</em> callback's <em>status</em> argument is used to indicate whether it was executed normally. For example, the status may be CANCELLED if <em>TryCancel</em> was called, or if the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> is being shut down. </p>

</div>
</div>
<a id="ab3f692931265b6cc56fa4c23e506c376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f692931265b6cc56fa4c23e506c376">&#9670;&nbsp;</a></span>RunAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> grpc_event_engine::experimental::EventEngine::RunAt </td>
          <td>(</td>
          <td class="paramtype">absl::Time&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_run_options.html">RunOptions</a>&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonymous with scheduling an alarm to run at time <em>when</em>. </p>
<p>The callback <em>fn</em> will execute when either when time <em>when</em> arrives (receiving status OK), or when the <em>fn</em> is cancelled (reveiving status CANCELLED). The callback is guaranteed to be called exactly once. </p>

</div>
</div>
<a id="a25339c7fab530be8234a1b06e4b3311a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25339c7fab530be8234a1b06e4b3311a">&#9670;&nbsp;</a></span>Shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc_event_engine::experimental::EventEngine::Shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a>&#160;</td>
          <td class="paramname"><em>on_shutdown_complete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immediately run all callbacks with status indicating the shutdown. </p>
<p>Every <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> is expected to shut down exactly once. No new callbacks/tasks should be scheduled after shutdown has begun, no new connections should be created.</p>
<p>If the <em>on_shutdown_complete</em> callback is given a non-OK status, errors are expected to be unrecoverable. For example, an implementation could warn callers about leaks if memory cannot be freed within a certain timeframe. </p>

</div>
</div>
<a id="a93effe8154cd154075dfaf54a083c8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93effe8154cd154075dfaf54a083c8de">&#9670;&nbsp;</a></span>TryCancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc_event_engine::experimental::EventEngine::TryCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Immediately tries to cancel a callback. </p>
<p>Note that this is a "best effort" cancellation. No guarantee is made that the callback will be cancelled, the call could be in any stage.</p>
<p>There are three scenarios in which we may cancel a scheduled function:</p><ol type="1">
<li>We cancel the execution before it has run.</li>
<li>The callback has already run.</li>
<li>We can't cancel it because it is "in flight".</li>
</ol>
<p>In all cases, the cancellation is still considered successful, the callback will be run exactly once from either cancellation or from its activation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/grpc/event_engine/<a class="el" href="event__engine_8h_source.html">event_engine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 2 2021 06:57:46 for GRPC Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
