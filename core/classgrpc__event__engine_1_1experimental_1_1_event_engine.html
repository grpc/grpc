<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC Core: grpc_event_engine::experimental::EventEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC Core
   &#160;<span id="projectnumber">19.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegrpc__event__engine.html">grpc_event_engine</a></li><li class="navelem"><a class="el" href="namespacegrpc__event__engine_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html">EventEngine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">grpc_event_engine::experimental::EventEngine Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> encapsulates all platform-specific behaviors related to low level network I/O, timers, asynchronous execution, and DNS resolution.  
 <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="event__engine_8h_source.html">event_engine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides asynchronous resolution.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One end of a connection between a gRPC client and server.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listens for incoming connection requests from gRPC clients and initiates request processing once connections are established.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin wrapper around a platform-specific sockaddr type.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback handle, used to cancel a callback.  <a href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae2d013587133788e31d8984cf0783050"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a> = std::function&lt; void(absl::Status)&gt;</td></tr>
<tr class="memdesc:ae2d013587133788e31d8984cf0783050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic callable function.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">More...</a><br /></td></tr>
<tr class="separator:ae2d013587133788e31d8984cf0783050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38e4bd2a5559809d16246442460af3d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">OnConnectCallback</a> = std::function&lt; void(absl::StatusOr&lt; std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a> &gt; &gt;)&gt;</td></tr>
<tr class="memdesc:ad38e4bd2a5559809d16246442460af3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new connection is established.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">More...</a><br /></td></tr>
<tr class="separator:ad38e4bd2a5559809d16246442460af3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a887c568bc8142e3067e6826e453eb1c6"><td class="memItemLeft" align="right" valign="top">virtual absl::StatusOr&lt; std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a887c568bc8142e3067e6826e453eb1c6">CreateListener</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#af57919c84f1672ac35838cd396f9f43a">Listener::AcceptCallback</a> on_accept, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a> on_shutdown, const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;config, std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator_factory.html">SliceAllocatorFactory</a> &gt; slice_allocator_factory)=0</td></tr>
<tr class="memdesc:a887c568bc8142e3067e6826e453eb1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a network listener / server.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a887c568bc8142e3067e6826e453eb1c6">More...</a><br /></td></tr>
<tr class="separator:a887c568bc8142e3067e6826e453eb1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a93980888e7f1fee07b2f987af3ff3"><td class="memItemLeft" align="right" valign="top">virtual absl::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a77a93980888e7f1fee07b2f987af3ff3">Connect</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">OnConnectCallback</a> on_connect, const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a> &amp;addr, const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;args, std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator.html">SliceAllocator</a> &gt; slice_allocator, absl::Time deadline)=0</td></tr>
<tr class="memdesc:a77a93980888e7f1fee07b2f987af3ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a client network connection to a remote network listener.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a77a93980888e7f1fee07b2f987af3ff3">More...</a><br /></td></tr>
<tr class="separator:a77a93980888e7f1fee07b2f987af3ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283885518525b71339f166e15932cd1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aa283885518525b71339f166e15932cd1">~EventEngine</a> ()=default</td></tr>
<tr class="memdesc:aa283885518525b71339f166e15932cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">At time of destruction, the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> must have no active responsibilities.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aa283885518525b71339f166e15932cd1">More...</a><br /></td></tr>
<tr class="separator:aa283885518525b71339f166e15932cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9dbb26c374daf51b6460da89a7d586"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#afb9dbb26c374daf51b6460da89a7d586">IsWorkerThread</a> ()=0</td></tr>
<tr class="separator:afb9dbb26c374daf51b6460da89a7d586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955326b931bda68cecff3f75605c0689"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a955326b931bda68cecff3f75605c0689">GetDNSResolver</a> ()=0</td></tr>
<tr class="memdesc:a955326b931bda68cecff3f75605c0689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns an instance of a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html" title="Provides asynchronous resolution.">DNSResolver</a>.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a955326b931bda68cecff3f75605c0689">More...</a><br /></td></tr>
<tr class="separator:a955326b931bda68cecff3f75605c0689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930ed5ebb5ee9758d4e09c4ed1d363ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a930ed5ebb5ee9758d4e09c4ed1d363ed">Run</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a> fn)=0</td></tr>
<tr class="memdesc:a930ed5ebb5ee9758d4e09c4ed1d363ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a callback as soon as possible.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a930ed5ebb5ee9758d4e09c4ed1d363ed">More...</a><br /></td></tr>
<tr class="separator:a930ed5ebb5ee9758d4e09c4ed1d363ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f18c91ce0a397799d9998aa9cd524e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a2f18c91ce0a397799d9998aa9cd524e4">RunAt</a> (absl::Time when, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a> fn)=0</td></tr>
<tr class="memdesc:a2f18c91ce0a397799d9998aa9cd524e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonymous with scheduling an alarm to run at time <em>when</em>.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a2f18c91ce0a397799d9998aa9cd524e4">More...</a><br /></td></tr>
<tr class="separator:a2f18c91ce0a397799d9998aa9cd524e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93effe8154cd154075dfaf54a083c8de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a93effe8154cd154075dfaf54a083c8de">TryCancel</a> (<a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> handle)=0</td></tr>
<tr class="memdesc:a93effe8154cd154075dfaf54a083c8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to cancel a callback.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a93effe8154cd154075dfaf54a083c8de">More...</a><br /></td></tr>
<tr class="separator:a93effe8154cd154075dfaf54a083c8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> encapsulates all platform-specific behaviors related to low level network I/O, timers, asynchronous execution, and DNS resolution. </p>
<p>This interface allows developers to provide their own event management and network stacks. Motivating uses cases for supporting custom EventEngines include the ability to hook into external event loops, and using different <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> instances for each channel to better insulate network I/O and callback processing from other channels.</p>
<p>A default cross-platform <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> instance is provided by gRPC.</p>
<p>LIFESPAN AND OWNERSHIP</p>
<p>gRPC takes shared ownership of EventEngines via std::shared_ptrs to ensure that the engines remain available until they are no longer needed. Depending on the use case, engines may live until gRPC is shut down.</p>
<p>EXAMPLE USAGE (Not yet implemented)</p>
<p>Custom EventEngines can be specified per channel, and allow configuration for both clients and servers. To set a custom <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> for a client channel, you can do something like the following:</p>
<p>ChannelArguments args; std::shared_ptr&lt;EventEngine&gt; engine = std::make_shared&lt;MyEngine&gt;(...); args.SetEventEngine(engine); MyAppClient client(grpc::CreateCustomChannel( "localhost:50051", grpc::InsecureChannelCredentials(), args));</p>
<p>A gRPC server can use a custom <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> by calling the ServerBuilder::SetEventEngine method:</p>
<p>ServerBuilder builder; std::shared_ptr&lt;EventEngine&gt; engine = std::make_shared&lt;MyEngine&gt;(...); builder.SetEventEngine(engine); std::unique_ptr&lt;Server&gt; server(builder.BuildAndStart()); server-&gt;Wait(); </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae2d013587133788e31d8984cf0783050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d013587133788e31d8984cf0783050">&#9670;&nbsp;</a></span>Callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">grpc_event_engine::experimental::EventEngine::Callback</a> =  std::function&lt;void(absl::Status)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic callable function. </p>
<p>The first argument to all callbacks is an absl::Status indicating the status of the operation associated with this callback. Each <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> method that takes a callback parameter, defines the expected sets and meanings of statuses for that use case. </p>

</div>
</div>
<a id="ad38e4bd2a5559809d16246442460af3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38e4bd2a5559809d16246442460af3d">&#9670;&nbsp;</a></span>OnConnectCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">grpc_event_engine::experimental::EventEngine::OnConnectCallback</a> =  std::function&lt;void(absl::StatusOr&lt;std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a>&gt; &gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new connection is established. </p>
<p>If the connection attempt was not successful, implementations should pass the appropriate statuses to this callback. For example, callbacks might expect to receive DEADLINE_EXCEEDED statuses when appropriate, or CANCELLED statuses on <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> shutdown. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa283885518525b71339f166e15932cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa283885518525b71339f166e15932cd1">&#9670;&nbsp;</a></span>~EventEngine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual grpc_event_engine::experimental::EventEngine::~EventEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>At time of destruction, the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> must have no active responsibilities. </p>
<p><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> users (applications) are responsible for cancelling all tasks and DNS lookups, shutting down listeners and endpoints, prior to <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> destruction. If there are any outstanding tasks, any running listeners, etc. at time of <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> destruction, that is an invalid use of the API, and it will result in undefined behavior. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a77a93980888e7f1fee07b2f987af3ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a93980888e7f1fee07b2f987af3ff3">&#9670;&nbsp;</a></span>Connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual absl::Status grpc_event_engine::experimental::EventEngine::Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">OnConnectCallback</a>&#160;</td>
          <td class="paramname"><em>on_connect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator.html">SliceAllocator</a> &gt;&#160;</td>
          <td class="paramname"><em>slice_allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Time&#160;</td>
          <td class="paramname"><em>deadline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a client network connection to a remote network listener. </p>
<p>May return an error status immediately if there was a failure in the synchronous part of establishing a connection. In that event, the <em>on_connect</em> callback <em>will not</em> have been executed. Otherwise, it is expected that the <em>on_connect</em> callback will be asynchronously executed exactly once by the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a>.</p>
<p>Implementation Note: it is important that the <em>slice_allocator</em> be used for all read/write buffer allocations in the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> implementation. This allows gRPC's <em>ResourceQuota</em> system to monitor and control memory usage with graceful degradation mechanisms. Please see the <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator.html">SliceAllocator</a></em> API for more information. </p>

</div>
</div>
<a id="a887c568bc8142e3067e6826e453eb1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887c568bc8142e3067e6826e453eb1c6">&#9670;&nbsp;</a></span>CreateListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual absl::StatusOr&lt;std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a>&gt; &gt; grpc_event_engine::experimental::EventEngine::CreateListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#af57919c84f1672ac35838cd396f9f43a">Listener::AcceptCallback</a>&#160;</td>
          <td class="paramname"><em>on_accept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a>&#160;</td>
          <td class="paramname"><em>on_shutdown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator_factory.html">SliceAllocatorFactory</a> &gt;&#160;</td>
          <td class="paramname"><em>slice_allocator_factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create a network listener / server. </p>
<p>Once a <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a></em> is created and started, the <em>on_accept</em> callback will be called once asynchronously for each established connection. This method may return a non-OK status immediately if an error was encountered in any synchronous steps required to create the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a>. In this case, <em>on_shutdown</em> will never be called.</p>
<p>If this method returns a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a>, then <em>on_shutdown</em> will be invoked exactly once, when the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a> is shut down. The status passed to it will indicate if there was a problem during shutdown.</p>
<p>The provided <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_slice_allocator_factory.html">SliceAllocatorFactory</a></em> is used to create <em>SliceAllocators</em> for <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html" title="One end of a connection between a gRPC client and server.">Endpoint</a> construction. </p>

</div>
</div>
<a id="a955326b931bda68cecff3f75605c0689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955326b931bda68cecff3f75605c0689">&#9670;&nbsp;</a></span>GetDNSResolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a>&gt; grpc_event_engine::experimental::EventEngine::GetDNSResolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns an instance of a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html" title="Provides asynchronous resolution.">DNSResolver</a>. </p>

</div>
</div>
<a id="afb9dbb26c374daf51b6460da89a7d586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9dbb26c374daf51b6460da89a7d586">&#9670;&nbsp;</a></span>IsWorkerThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool grpc_event_engine::experimental::EventEngine::IsWorkerThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a930ed5ebb5ee9758d4e09c4ed1d363ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930ed5ebb5ee9758d4e09c4ed1d363ed">&#9670;&nbsp;</a></span>Run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc_event_engine::experimental::EventEngine::Run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a>&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a callback as soon as possible. </p>
<p>The <em>fn</em> callback's <em>status</em> argument is used to indicate whether it was executed normally. For example, the status may be CANCELLED if the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> is being shut down. <em>fn</em> is guaranteed to be called exactly once. </p>

</div>
</div>
<a id="a2f18c91ce0a397799d9998aa9cd524e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f18c91ce0a397799d9998aa9cd524e4">&#9670;&nbsp;</a></span>RunAt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> grpc_event_engine::experimental::EventEngine::RunAt </td>
          <td>(</td>
          <td class="paramtype">absl::Time&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ae2d013587133788e31d8984cf0783050">Callback</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonymous with scheduling an alarm to run at time <em>when</em>. </p>
<p>The callback <em>fn</em> will execute when either when time <em>when</em> arrives (receiving status OK), or when the <em>fn</em> is cancelled (receiving status CANCELLED). The callback is guaranteed to be called exactly once. </p>

</div>
</div>
<a id="a93effe8154cd154075dfaf54a083c8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93effe8154cd154075dfaf54a083c8de">&#9670;&nbsp;</a></span>TryCancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc_event_engine::experimental::EventEngine::TryCancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to cancel a callback. </p>
<p>Note that this is a "best effort" cancellation. No guarantee is made that the callback will be cancelled, the call could be in any stage.</p>
<p>There are three scenarios in which we may cancel a scheduled task:</p><ol type="1">
<li>We cancel the execution before it has run.</li>
<li>The callback has already run.</li>
<li>We can't cancel it because it is "in flight".</li>
</ol>
<p>In all cases, the cancellation is still considered successful, the callback will be run exactly once from either cancellation or from its activation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/grpc/event_engine/<a class="el" href="event__engine_8h_source.html">event_engine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 5 2021 22:54:11 for GRPC Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
