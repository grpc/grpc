<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC Core: gRPC Security Audit</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC Core
   &#160;<span id="projectnumber">24.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">gRPC Security Audit </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A third-party security audit of gRPC C++ stack was performed by <a href="https://cure53.de">Cure53</a> in October 2019. The full report can be found <a href="https://github.com/grpc/grpc/tree/master/doc/grpc_security_audit.pdf">here</a>.</p>
<h1><a class="anchor" id="autotoc_md236"></a>
Addressing grpc_security_audit</h1>
<p>The following describes how gRPC team has or will address each of the security issues pointed out in the report.</p>
<h2><a class="anchor" id="autotoc_md237"></a>
GRP-01-001 DoS through uninitialized pointer dereference</h2>
<p>GRP-01-001 was fixed in version 1.24.0 and above with <a href="https://github.com/grpc/grpc/pull/20351">https://github.com/grpc/grpc/pull/20351</a>. The fix was also patched in version 1.23.1.</p>
<h2><a class="anchor" id="autotoc_md238"></a>
GRP-01-002 Refs to freed memory not automatically nulled</h2>
<p>GRP-01-002 describes a programming pattern in gRPC Core where <code>gpr_free</code> is called and then the pointer is nulled afterwards. GRP-01-002 can be split into two concerns: 1) dangling pointer bugs and 2) the potential vulnerability of leveraging other bugs to access data through a freed pointer.</p>
<p>Regarding 1), gRPC uses a suite of sanitizer tests (asan, tsan, etc) to detect and fix any memory-related bugs. gRPC is also in the process of moving to c++ and the standard library, enabling the use of smart pointers in Core and thus making it harder to generate memory-related bugs. There are also plans to remove <code>gpr_free</code> in general.</p>
<p>Regarding 2), moving to smart pointers (in particular, unique_ptr) will help this issue as well. In addition, gRPC has continuous fuzzing tests to find and resolve security issues, and the pen test did not discover any concrete vulnerabilities in this area.</p>
<p>Below is a list of alternatives that gRPC team considered.</p>
<h3><a class="anchor" id="autotoc_md239"></a>
Alternative #1: Rewrite gpr_free to take void**</h3>
<p>One solution is to change the API of <code>gpr_free</code> so that it automatically nulls the given pointer after freeing it.</p>
<div class="fragment"><div class="line">gpr_free (void** ptr) {</div>
<div class="line">  ...</div>
<div class="line">  *ptr = nullptr;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This defensive programming pattern would help protect gRPC from the potential exploits and latent dangling pointer bugs mentioned in the security report.</p>
<p>However, performance would be a significant concern as we are now unconditionally adding a store to every gpr_free call, and there are potentially hundreds of these per RPC. At the RPC layer, this can add up to prohibitive costs.</p>
<p>Maintainability is also an issue since this approach impacts use of <code>*const</code>. Member pointers that are set in the initialization list of a constructor and not changed thereafter can be declared <code>*const</code>. This is a useful compile-time check if the member is taking ownership of something that was passed in by argument or allocated through a helper function called by the constructor initializer list. If this thing needs to be <code>gpr_free</code>'d using the proposed syntax, it can no longer be <code>*const</code> and we lose these checks (or we have to const_cast it which is also error-prone).</p>
<p>Another concern is readability - this <code>gpr_free</code> interface is less intuitive than the current one.</p>
<p>Yet another concern is that the use of non-smart pointers doesn’t imply ownership - it doesn’t protect against spare copies of the same pointers.</p>
<h3><a class="anchor" id="autotoc_md240"></a>
Alternative #2: Add another gpr_free to the Core API</h3>
<p>Adding an alternative <code>gpr_free</code> that nulls the given pointer is undesirable because we cannot enforce that we’re using this version of <code>gpr_free</code> everywhere we need to. It doesn’t solve the original problem because it doesn’t reduce the chance of programmer error.</p>
<p>Like alternative #1, this solution doesn’t protect against spare copies of the same pointers and is subject to the same maintainability concerns.</p>
<h3><a class="anchor" id="autotoc_md241"></a>
Alternative #3: Rewrite gpr_free to take void*&amp;</h3>
<div class="fragment"><div class="line">gpr_free (void*&amp; ptr) {</div>
<div class="line">  ...</div>
<div class="line">  ptr = nullptr;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This falls into the same pitfalls as solution #1 and furthermore is C89 non-compliant, which is a current requirement for <code>gpr_free</code>. Moreover, Google’s style guide discourages non-const reference parameters, so this is even less desirable than solution #1.</p>
<h3><a class="anchor" id="autotoc_md242"></a>
Conclusion</h3>
<p>Because of performance and maintainability concerns, GRP-01-002 will be addressed through the ongoing work to move gRPC Core to C++ and smart pointers and the future work of removing <code>gpr_free</code> in general. We will continue to leverage our sanitizer and fuzzing tests to help expose vulnerabilities.</p>
<h2><a class="anchor" id="autotoc_md243"></a>
GRP-01-003 Calls to malloc suffer from potential integer overflows</h2>
<p>The vulnerability, as defined by the report, is that calls to <code>gpr_malloc</code> in the C-core codebase may suffer from potential integer overflow in cases where we multiply the array element size by the size of the array. The penetration testers did not identify a concrete place where this occurred, but rather emphasized that the coding pattern itself had potential to lead to vulnerabilities. The report’s suggested solution for GRP-01-003 was to create a <code>calloc(size_t nmemb, size_t size)</code> wrapper that contains integer overflow checks.</p>
<p>However, gRPC team firmly believes that gRPC Core should only use integer overflow checks in the places where they’re needed; for example, any place where remote input influences the input to <code>gpr_malloc</code> in an unverified way. This is because bounds-checking is very expensive at the RPC layer.</p>
<p>Determining exactly where bounds-checking is needed requires an audit of tracing each <code>gpr_malloc</code> (or <code>gpr_realloc</code> or <code>gpr_zalloc</code>) call up the stack to determine if the sufficient bounds-checking was performed. This kind of audit, done manually, is fairly expensive engineer-wise.</p>
<h3><a class="anchor" id="autotoc_md244"></a>
Conclusion</h3>
<p>GRP-01-003 will be addressed through leveraging gRPC Core fuzzer tests to actively identify and resolve any integer overflow issues. If any issues are identified, we may create a <code>gpr_safe_malloc(size_t nmemb, size_t size)</code> wrapper to consolidate bounds-checking in one place. This function will <em>not</em> zero out memory because of performance concerns, and so will not be a calloc-style wrapper. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 18 2022 17:42:13 for GRPC Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
