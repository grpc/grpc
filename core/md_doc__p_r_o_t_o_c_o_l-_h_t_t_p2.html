<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC Core: gRPC over HTTP2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC Core
   &#160;<span id="projectnumber">6.0.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">gRPC over HTTP2 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>This document serves as a detailed description for an implementation of gRPC carried over <a href="https://tools.ietf.org/html/rfc7540">HTTP2 framing</a>. It assumes familiarity with the HTTP2 specification.</p>
<h2>Protocol</h2>
<p>Production rules are using <a href="http://tools.ietf.org/html/rfc5234">ABNF syntax</a>.</p>
<h3>Outline</h3>
<p>The following is the general sequence of message atoms in a GRPC request &amp; response message stream</p>
<ul>
<li>Request → Request-Headers *Length-Prefixed-Message EOS</li>
<li>Response → (Response-Headers *Length-Prefixed-Message Trailers) / Trailers-Only</li>
</ul>
<h3>Requests</h3>
<ul>
<li>Request → Request-Headers *Length-Prefixed-Message EOS</li>
</ul>
<p>Request-Headers are delivered as HTTP2 headers in HEADERS + CONTINUATION frames.</p>
<ul>
<li><b>Request-Headers</b> → Call-Definition *Custom-Metadata</li>
<li><b>Call-Definition</b> → Method Scheme Path TE [Authority] [Timeout] Content-Type [Message-Type] [Message-Encoding] [Message-Accept-Encoding] [User-Agent]</li>
<li><b>Method</b> → ":method POST"</li>
<li><b>Scheme</b> → ":scheme " ("http" / "https")</li>
<li><b>Path</b> → ":path" "/" Service-Name "/" {<em>method name</em>} # But see note below.</li>
<li><b>Service-Name</b> → {<em>IDL-specific service name</em>}</li>
<li><b>Authority</b> → ":authority" {<em>virtual host name of authority</em>}</li>
<li><b>TE</b> → "te" "trailers" # Used to detect incompatible proxies</li>
<li><b>Timeout</b> → "grpc-timeout" TimeoutValue TimeoutUnit</li>
<li><b>TimeoutValue</b> → {<em>positive integer as ASCII string of at most 8 digits</em>}</li>
<li><b>TimeoutUnit</b> → Hour / Minute / Second / Millisecond / Microsecond / Nanosecond</li>
<li><b>Hour</b> → "H"</li>
<li><b>Minute</b> → "M"</li>
<li><b>Second</b> → "S"</li>
<li><b>Millisecond</b> → "m"</li>
<li><b>Microsecond</b> → "u"</li>
<li><b>Nanosecond</b> → "n"</li>
<li><b>Content-Type</b> → "content-type" "application/grpc" [("+proto" / "+json" / {<em>custom</em>})]</li>
<li><b>Content-Coding</b> → "identity" / "gzip" / "deflate" / "snappy" / {<em>custom</em>}</li>
<li><a class="anchor" id="message-encoding"></a>**Message-Encoding** → "grpc-encoding" Content-Coding</li>
<li><b>Message-Accept-Encoding</b> → "grpc-accept-encoding" Content-Coding *("," Content-Coding)</li>
<li><b>User-Agent</b> → "user-agent" {<em>structured user-agent string</em>}</li>
<li><b>Message-Type</b> → "grpc-message-type" {<em>type name for message schema</em>}</li>
<li><b>Custom-Metadata</b> → Binary-Header / ASCII-Header</li>
<li><b>Binary-Header</b> → {Header-Name "-bin" } {<em>base64 encoded value</em>}</li>
<li><b>ASCII-Header</b> → Header-Name ASCII-Value</li>
<li><b>Header-Name</b> → 1*( x30-39 / x61-7A / "\_" / "-" / ".") ; 0-9 a-z _ - .</li>
<li><b>ASCII-Value</b> → 1*( x20-x7E ) ; space and printable ASCII</li>
</ul>
<p>HTTP2 requires that reserved headers, ones starting with ":" appear before all other headers. Additionally implementations should send <b>Timeout</b> immediately after the reserved headers and they should send the <b>Call-Definition</b> headers before sending <b>Custom-Metadata</b>.</p>
<p>Some gRPC implementations may allow the <b>Path</b> format shown above to be overridden, but this functionality is strongly discouraged. gRPC does not go out of its way to break users that are using this kind of override, but we do not actively support it, and some functionality (e.g., service config support) will not work when the path is not of the form shown above.</p>
<p>If <b>Timeout</b> is omitted a server should assume an infinite timeout. Client implementations are free to send a default minimum timeout based on their deployment requirements.</p>
<p><b>Custom-Metadata</b> is an arbitrary set of key-value pairs defined by the application layer. Header names starting with "grpc-" but not listed here are reserved for future GRPC use and should not be used by applications as <b>Custom-Metadata</b>.</p>
<p>Note that HTTP2 does not allow arbitrary octet sequences for header values so binary header values must be encoded using Base64 as per <a href="https://tools.ietf.org/html/rfc4648#section-4">https://tools.ietf.org/html/rfc4648#section-4</a>. Implementations MUST accept padded and un-padded values and should emit un-padded values. Applications define binary headers by having their names end with "-bin". Runtime libraries use this suffix to detect binary headers and properly apply base64 encoding &amp; decoding as headers are sent and received.</p>
<p><b>Custom-Metadata</b> header order is not guaranteed to be preserved except for values with duplicate header names. Duplicate header names may have their values joined with "," as the delimiter and be considered semantically equivalent. Implementations must split **Binary-Header**s on "," before decoding the Base64-encoded values.</p>
<p><b>ASCII-Value</b> should not have leading or trailing whitespace. If it contains leading or trailing whitespace, it may be stripped. The <b>ASCII-Value</b> character range defined is more strict than HTTP. Implementations must not error due to receiving an invalid <b>ASCII-Value</b> that's a valid <b>field-value</b> in HTTP, but the precise behavior is not strictly defined: they may throw the value away or accept the value. If accepted, care must be taken to make sure that the application is permitted to echo the value back as metadata. For example, if the metadata is provided to the application as a list in a request, the application should not trigger an error by providing that same list as the metadata in the response.</p>
<p>Servers may limit the size of <b>Request-Headers</b>, with a default of 8 KiB suggested. Implementations are encouraged to compute total header size like HTTP/2's <code>SETTINGS_MAX_HEADER_LIST_SIZE</code>: the sum of all header fields, for each field the sum of the uncompressed field name and value lengths plus 32, with binary values' lengths being post-Base64.</p>
<p>The repeated sequence of <b>Length-Prefixed-Message</b> items is delivered in DATA frames</p>
<ul>
<li><b>Length-Prefixed-Message</b> → Compressed-Flag Message-Length Message</li>
<li><a class="anchor" id="compressed-flag"></a>**Compressed-Flag** → 0 / 1 # encoded as 1 byte unsigned integer</li>
<li><b>Message-Length</b> → {<em>length of Message</em>} # encoded as 4 byte unsigned integer</li>
<li><b>Message</b> → *{binary octet}</li>
</ul>
<p>A <b>Compressed-Flag</b> value of 1 indicates that the binary octet sequence of <b>Message</b> is compressed using the mechanism declared by the <b>Message-Encoding</b> header. A value of 0 indicates that no encoding of <b>Message</b> bytes has occurred. Compression contexts are NOT maintained over message boundaries, implementations must create a new context for each message in the stream. If the <b>Message-Encoding</b> header is omitted then the <b>Compressed-Flag</b> must be 0.</p>
<p>For requests, <b>EOS</b> (end-of-stream) is indicated by the presence of the END_STREAM flag on the last received DATA frame. In scenarios where the <b>Request</b> stream needs to be closed but no data remains to be sent implementations MUST send an empty DATA frame with this flag set.</p>
<h3>Responses</h3>
<ul>
<li><b>Response</b> → (Response-Headers *Length-Prefixed-Message Trailers) / Trailers-Only</li>
<li><b>Response-Headers</b> → HTTP-Status [Message-Encoding] [Message-Accept-Encoding] Content-Type *Custom-Metadata</li>
<li><b>Trailers-Only</b> → HTTP-Status Content-Type Trailers</li>
<li><b>Trailers</b> → Status [Status-Message] *Custom-Metadata</li>
<li><b>HTTP-Status</b> → ":status 200"</li>
<li><b>Status</b> → "grpc-status" 1*DIGIT ; 0-9</li>
<li><b>Status-Message</b> → "grpc-message" Percent-Encoded</li>
<li><b>Percent-Encoded</b> → 1*(Percent-Byte-Unencoded / Percent-Byte-Encoded)</li>
<li><b>Percent-Byte-Unencoded</b> → 1*( x20-x24 / x26-x7E ) ; space and VCHAR, except %</li>
<li><b>Percent-Byte-Encoded</b> → "%" 2HEXDIGIT ; 0-9 A-F</li>
</ul>
<p><b>Response-Headers</b> &amp; <b>Trailers-Only</b> are each delivered in a single HTTP2 HEADERS frame block. Most responses are expected to have both headers and trailers but <b>Trailers-Only</b> is permitted for calls that produce an immediate error. Status must be sent in <b>Trailers</b> even if the status code is OK.</p>
<p>For responses end-of-stream is indicated by the presence of the END_STREAM flag on the last received HEADERS frame that carries <b>Trailers</b>.</p>
<p>Implementations should expect broken deployments to send non-200 HTTP status codes in responses as well as a variety of non-GRPC content-types and to omit <b>Status</b> &amp; <b>Status-Message</b>. Implementations must synthesize a <b>Status</b> &amp; <b>Status-Message</b> to propagate to the application layer when this occurs.</p>
<p>Clients may limit the size of <b>Response-Headers</b>, <b>Trailers</b>, and <b>Trailers-Only</b>, with a default of 8 KiB each suggested.</p>
<p>The value portion of <b>Status</b> is a decimal-encoded integer as an ASCII string, without any leading zeros.</p>
<p>The value portion of <b>Status-Message</b> is conceptually a Unicode string description of the error, physically encoded as UTF-8 followed by percent-encoding. Percent-encoding is specified in <a href="https://tools.ietf.org/html/rfc3986#section-2.1">RFC 3986 §2.1</a>, although the form used here has different restricted characters. When decoding invalid values, implementations MUST NOT error or throw away the message. At worst, the implementation can abort decoding the status message altogether such that the user would received the raw percent-encoded form. Alternatively, the implementation can decode valid portions while leaving broken %-encodings as-is or replacing them with a replacement character (e.g., '?' or the Unicode replacement character).</p>
<h4>Example</h4>
<p>Sample unary-call showing HTTP2 framing sequence</p>
<p><b>Request</b></p>
<div class="fragment"><div class="line">HEADERS (flags = END_HEADERS)</div><div class="line">:method = POST</div><div class="line">:scheme = http</div><div class="line">:path = /google.pubsub.v2.PublisherService/CreateTopic</div><div class="line">:authority = pubsub.googleapis.com</div><div class="line">grpc-timeout = 1S</div><div class="line">content-type = application/grpc+proto</div><div class="line">grpc-encoding = gzip</div><div class="line">authorization = Bearer y235.wef315yfh138vh31hv93hv8h3v</div><div class="line"></div><div class="line">DATA (flags = END_STREAM)</div><div class="line">&lt;Length-Prefixed Message&gt;</div></div><!-- fragment --><p> <b>Response</b> </p><div class="fragment"><div class="line">HEADERS (flags = END_HEADERS)</div><div class="line">:status = 200</div><div class="line">grpc-encoding = gzip</div><div class="line">content-type = application/grpc+proto</div><div class="line"></div><div class="line">DATA</div><div class="line">&lt;Length-Prefixed Message&gt;</div><div class="line"></div><div class="line">HEADERS (flags = END_STREAM, END_HEADERS)</div><div class="line">grpc-status = 0 # OK</div><div class="line">trace-proto-bin = jher831yy13JHy3hc</div></div><!-- fragment --><h4>User Agents</h4>
<p>While the protocol does not require a user-agent to function it is recommended that clients provide a structured user-agent string that provides a basic description of the calling library, version &amp; platform to facilitate issue diagnosis in heterogeneous environments. The following structure is recommended to library developers </p><div class="fragment"><div class="line">User-Agent → &quot;grpc-&quot; Language ?(&quot;-&quot; Variant) &quot;/&quot; Version ?( &quot; (&quot;  *(AdditionalProperty &quot;;&quot;) &quot;)&quot; )</div></div><!-- fragment --><p> E.g.</p>
<div class="fragment"><div class="line">grpc-java/1.2.3</div><div class="line">grpc-ruby/1.2.3</div><div class="line">grpc-ruby-jruby/1.3.4</div><div class="line">grpc-java-android/0.9.1 (gingerbread/1.2.4; nexus5; tmobile)</div></div><!-- fragment --><h4>Idempotency and Retries</h4>
<p>Unless explicitly defined to be, gRPC Calls are not assumed to be idempotent. Specifically:</p>
<ul>
<li>Calls that cannot be proven to have started will not be retried.</li>
<li>There is no mechanism for duplicate suppression as it is not necessary.</li>
<li>Calls that are marked as idempotent may be sent multiple times.</li>
</ul>
<h4>HTTP2 Transport Mapping</h4>
<h5>Stream Identification</h5>
<p>All GRPC calls need to specify an internal ID. We will use HTTP2 stream-ids as call identifiers in this scheme. NOTE: These ids are contextual to an open HTTP2 session and will not be unique within a given process that is handling more than one HTTP2 session nor can they be used as GUIDs.</p>
<h5>Data Frames</h5>
<p>DATA frame boundaries have no relation to <b>Length-Prefixed-Message</b> boundaries and implementations should make no assumptions about their alignment.</p>
<h5>Errors</h5>
<p>When an application or runtime error occurs during an RPC a <b>Status</b> and <b>Status-Message</b> are delivered in <b>Trailers</b>.</p>
<p>In some cases it is possible that the framing of the message stream has become corrupt and the RPC runtime will choose to use an <b>RST_STREAM</b> frame to indicate this state to its peer. RPC runtime implementations should interpret RST_STREAM as immediate full-closure of the stream and should propagate an error up to the calling application layer.</p>
<p>The following mapping from RST_STREAM error codes to GRPC error codes is applied.</p>
<table class="doxtable">
<tr>
<th>HTTP2 Code</th><th>GRPC Code  </th></tr>
<tr>
<td>NO_ERROR(0)</td><td>INTERNAL - An explicit GRPC status of OK should have been sent but this might be used to aggressively lameduck in some scenarios. </td></tr>
<tr>
<td>PROTOCOL_ERROR(1)</td><td>INTERNAL </td></tr>
<tr>
<td>INTERNAL_ERROR(2)</td><td>INTERNAL </td></tr>
<tr>
<td>FLOW_CONTROL_ERROR(3)</td><td>INTERNAL </td></tr>
<tr>
<td>SETTINGS_TIMEOUT(4)</td><td>INTERNAL </td></tr>
<tr>
<td>STREAM_CLOSED</td><td>No mapping as there is no open stream to propagate to. Implementations should log. </td></tr>
<tr>
<td>FRAME_SIZE_ERROR</td><td>INTERNAL </td></tr>
<tr>
<td>REFUSED_STREAM</td><td>UNAVAILABLE - Indicates that no processing occurred and the request can be retried, possibly elsewhere. </td></tr>
<tr>
<td>CANCEL(8)</td><td>Mapped to call cancellation when sent by a client.Mapped to CANCELLED when sent by a server. Note that servers should only use this mechanism when they need to cancel a call but the payload byte sequence is incomplete. </td></tr>
<tr>
<td>COMPRESSION_ERROR</td><td>INTERNAL </td></tr>
<tr>
<td>CONNECT_ERROR</td><td>INTERNAL </td></tr>
<tr>
<td>ENHANCE_YOUR_CALM</td><td>RESOURCE_EXHAUSTED ...with additional error detail provided by runtime to indicate that the exhausted resource is bandwidth. </td></tr>
<tr>
<td>INADEQUATE_SECURITY</td><td>PERMISSION_DENIED … with additional detail indicating that permission was denied as protocol is not secure enough for call. </td></tr>
</table>
<h5>Security</h5>
<p>The HTTP2 specification mandates the use of TLS 1.2 or higher when TLS is used with HTTP2. It also places some additional constraints on the allowed ciphers in deployments to avoid known-problems as well as requiring SNI support. It is also expected that HTTP2 will be used in conjunction with proprietary transport security mechanisms about which the specification can make no meaningful recommendations.</p>
<h5>Connection Management</h5>
<h6>GOAWAY Frame</h6>
<p>Sent by servers to clients to indicate that they will no longer accept any new streams on the associated connections. This frame includes the id of the last successfully accepted stream by the server. Clients should consider any stream initiated after the last successfully accepted stream as UNAVAILABLE and retry the call elsewhere. Clients are free to continue working with the already accepted streams until they complete or the connection is terminated.</p>
<p>Servers should send GOAWAY before terminating a connection to reliably inform clients which work has been accepted by the server and is being executed.</p>
<h6>PING Frame</h6>
<p>Both clients and servers can send a PING frame that the peer must respond to by precisely echoing what they received. This is used to assert that the connection is still live as well as providing a means to estimate end-to-end latency. If a server initiated PING does not receive a response within the deadline expected by the runtime all outstanding calls on the server will be closed with a CANCELLED status. An expired client initiated PING will cause all calls to be closed with an UNAVAILABLE status. Note that the frequency of PINGs is highly dependent on the network environment, implementations are free to adjust PING frequency based on network and application requirements.</p>
<h6>Connection failure</h6>
<p>If a detectable connection failure occurs on the client all calls will be closed with an UNAVAILABLE status. For servers open calls will be closed with a CANCELLED status.</p>
<h3>Appendix A - GRPC for Protobuf</h3>
<p>The service interfaces declared by protobuf are easily mapped onto GRPC by code generation extensions to protoc. The following defines the mapping to be used.</p>
<ul>
<li><b>Service-Name</b> → ?( {<em>proto package name</em>} "." ) {<em>service name</em>}</li>
<li><b>Message-Type</b> → {<em>fully qualified proto message name</em>}</li>
<li><b>Content-Type</b> → "application/grpc+proto" </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 15 2018 17:01:00 for GRPC Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
