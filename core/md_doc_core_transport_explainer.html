<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC Core: Transport Explainer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC Core
   &#160;<span id="projectnumber">37.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Transport Explainer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>@vjpai</p>
<h1><a class="anchor" id="autotoc_md131"></a>
Existing Transports</h1>
<p><a href="https://github.com/grpc/grpc/tree/master/src/core/ext/transport">gRPC transports</a> plug in below the core API (one level below the C++ or other wrapped-language API). You can write your transport in C or C++ though; currently (Nov 2017) all the transports are nominally written in C++ though they are idiomatically C. The existing transports are:</p>
<ul>
<li><a href="https://github.com/grpc/grpc/tree/master/src/core/ext/transport/chttp2">HTTP/2</a></li>
<li><a href="https://github.com/grpc/grpc/tree/master/src/core/ext/transport/cronet">Cronet</a></li>
<li><a href="https://github.com/grpc/grpc/tree/master/src/core/ext/transport/inproc">In-process</a></li>
</ul>
<p>Among these, the in-process is likely the easiest to understand, though arguably also the least similar to a "real" sockets-based transport since it is only used in a single process.</p>
<h1><a class="anchor" id="autotoc_md132"></a>
Transport stream ops</h1>
<p>In the gRPC core implementation, a fundamental struct is the <code>grpc_transport_stream_op_batch</code> which represents a collection of stream operations sent to a transport. (Note that in gRPC, <em>stream</em> and <em>RPC</em> are used synonymously since all RPCs are actually streams internally.) The ops in a batch can include:</p>
<ul>
<li>send_initial_metadata<ul>
<li>Client: initiate an RPC</li>
<li>Server: supply response headers</li>
</ul>
</li>
<li>recv_initial_metadata<ul>
<li>Client: get response headers</li>
<li>Server: accept an RPC</li>
</ul>
</li>
<li>send_message (zero or more) : send a data buffer</li>
<li>recv_message (zero or more) : receive a data buffer</li>
<li>send_trailing_metadata<ul>
<li>Client: half-close indicating that no more messages will be coming</li>
<li>Server: full-close providing final status for the RPC</li>
</ul>
</li>
<li>recv_trailing_metadata: get final status for the RPC<ul>
<li>Server extra: This op shouldn't actually be considered complete until the server has also sent trailing metadata to provide the other side with final status</li>
</ul>
</li>
<li>cancel_stream: Attempt to cancel an RPC</li>
<li>collect_stats: Get stats</li>
</ul>
<p>The fundamental responsibility of the transport is to transform between this internal format and an actual wire format, so the processing of these operations is largely transport-specific.</p>
<p>One or more of these ops are grouped into a batch. Applications can start all of a call's ops in a single batch, or they can split them up into multiple batches. Results of each batch are returned asynchronously via a completion queue.</p>
<p>Internally, we use callbacks to indicate completion. The surface layer creates a callback when starting a new batch and sends it down the filter stack along with the batch. The transport must invoke this callback when the batch is complete, and then the surface layer returns an event to the application via the completion queue. Each batch can have up to 3 callbacks:</p>
<ul>
<li>recv_initial_metadata_ready (called by the transport when the recv_initial_metadata op is complete)</li>
<li>recv_message_ready (called by the transport when the recv_message op is complete)</li>
<li>on_complete (called by the transport when the entire batch is complete)</li>
</ul>
<h1><a class="anchor" id="autotoc_md133"></a>
Timelines of transport stream op batches</h1>
<p>The transport's job is to sequence and interpret various possible interleavings of the basic stream ops. For example, a sample timeline of batches would be:</p>
<ol type="1">
<li>Client send_initial_metadata: Initiate an RPC with a path (method) and authority</li>
</ol>
<ol type="1">
<li>Server recv_initial_metadata: accept an RPC</li>
</ol>
<ol type="1">
<li>Client send_message: Supply the input proto for the RPC</li>
</ol>
<ol type="1">
<li>Server recv_message: Get the input proto from the RPC</li>
</ol>
<ol type="1">
<li>Client send_trailing_metadata: This is a half-close indicating that the client will not be sending any more messages</li>
</ol>
<ol type="1">
<li>Server recv_trailing_metadata: The server sees this from the client and knows that it will not get any more messages. This won't complete yet though, as described above.</li>
</ol>
<ol type="1">
<li>Server send_initial_metadata, send_message, send_trailing_metadata: A batch can contain multiple ops, and this batch provides the RPC response headers, response content, and status. Note that sending the trailing metadata will also complete the server's receive of trailing metadata.</li>
</ol>
<ol type="1">
<li>Client recv_initial_metadata: The number of ops in one side of the batch has no relation with the number of ops on the other side of the batch. In this case, the client is just collecting the response headers.</li>
</ol>
<ol type="1">
<li>Client recv_message, recv_trailing_metadata: Get the data response and status</li>
</ol>
<p>There are other possible sample timelines. For example, for client-side streaming, a "typical" sequence would be:</p>
<ol type="1">
<li>Server: recv_initial_metadata<ul>
<li>At API-level, that would be the server requesting an RPC</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Server: recv_trailing_metadata<ul>
<li>This is for when the server wants to know the final completion of the RPC through an <code>AsyncNotifyWhenDone</code> API in C++</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Client: send_initial_metadata, recv_message, recv_trailing_metadata<ul>
<li>At API-level, that's a client invoking a client-side streaming call. The send_initial_metadata is the call invocation, the recv_message collects the final response from the server, and the recv_trailing_metadata gets the <code>grpc::Status</code> value that will be returned from the call</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Client: send_message / Server: recv_message<ul>
<li>Repeat the above step numerous times; these correspond to a client issuing <code>Write</code> in a loop and a server doing <code>Read</code> in a loop until <code>Read</code> fails</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Client: send_trailing_metadata / Server: recv_message that indicates doneness (NULL)<ul>
<li>These correspond to a client issuing <code>WritesDone</code> which causes the server's <code>Read</code> to fail</li>
</ul>
</li>
</ol>
<ol type="1">
<li>Server: send_message, send_trailing_metadata<ul>
<li>These correspond to the server doing <code>Finish</code></li>
</ul>
</li>
</ol>
<p>The sends on one side will call their own callbacks when complete, and they will in turn trigger actions that cause the other side's recv operations to complete. In some transports, a send can sometimes complete before the recv on the other side (e.g., in HTTP/2 if there is sufficient flow-control buffer space available)</p>
<h1><a class="anchor" id="autotoc_md134"></a>
Other transport duties</h1>
<p>In addition to these basic stream ops, the transport must handle cancellations of a stream at any time and pass their effects to the other side. For example, in HTTP/2, this triggers a <code>RST_STREAM</code> being sent on the wire. The transport must perform operations like pings and statistics that are used to shape transport-level characteristics like flow control (see, for example, their use in the HTTP/2 transport).</p>
<h1><a class="anchor" id="autotoc_md135"></a>
Putting things together with detail: Sending Metadata</h1>
<ul>
<li>API layer: <code>map&lt;string, string&gt;</code> that is specific to this RPC</li>
<li>Core surface layer: array of <code>{slice, slice}</code> pairs where each slice references an underlying string</li>
<li><a href="https://github.com/grpc/grpc/tree/master/src/core/lib/transport">Core transport layer</a>: list of <code>{slice, slice}</code> pairs that includes the above plus possibly some general metadata (e.g., Method and Authority for initial metadata)</li>
<li><a href="https://github.com/grpc/grpc/tree/master/src/core/ext/transport">Specific transport layer</a>:<ul>
<li>Either send it to the other side using transport-specific API (e.g., Cronet)</li>
<li>Or have it sent through the <a href="https://github.com/grpc/grpc/tree/master/src/core/lib/iomgr">iomgr/endpoint layer</a> (e.g., HTTP/2)</li>
<li>Or just manipulate pointers to get it from one side to the other (e.g., In-process)</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md136"></a>
Requirements for any transport</h1>
<p>Each transport implements several operations in a vtbl (may change to actual virtual functions as transport moves to idiomatic C++).</p>
<p>The most important and common one is <code>perform_stream_op</code>. This function processes a single stream op batch on a specific stream that is associated with a specific transport:</p>
<ul>
<li>Gets the 6 ops/cancel passed down from the surface</li>
<li>Pass metadata from one side to the other as described above</li>
<li>Transform messages between slice buffer structure and stream of bytes to pass to other side<ul>
<li>May require insertion of extra bytes (e.g., per-message headers in HTTP/2)</li>
</ul>
</li>
<li>React to metadata to preserve expected orderings (*)</li>
<li>Schedule invocation of completion callbacks</li>
</ul>
<p>There are other functions in the vtbl as well.</p>
<ul>
<li><code>perform_transport_op</code><ul>
<li>Configure the transport instance for the connectivity state change notifier or the server-side accept callback</li>
<li>Disconnect transport or set up a goaway for later streams</li>
</ul>
</li>
<li><code>init_stream</code><ul>
<li>Starts a stream from the client-side</li>
<li>(*) Server-side of the transport must call <code>accept_stream_cb</code> when a new stream is available<ul>
<li>Triggers request-matcher</li>
</ul>
</li>
</ul>
</li>
<li><code>destroy_stream</code>, <code>destroy_transport</code><ul>
<li>Free up data related to a stream or transport</li>
</ul>
</li>
<li><code>set_pollset</code>, <code>set_pollset_set</code>, <code>get_endpoint</code><ul>
<li>Map each specific instance of the transport to FDs being used by iomgr (for HTTP/2)</li>
<li>Get a pointer to the endpoint structure that actually moves the data (wrapper around a socket for HTTP/2)</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md137"></a>
Book-keeping responsibilities of the transport layer</h1>
<p>A given transport must keep all of its transport and streams ref-counted. This is essential to make sure that no struct disappears before it is done being used.</p>
<p>A transport must also preserve relevant orders for the different categories of ops on a stream, as described above. A transport must also make sure that all relevant batch operations have completed before scheduling the <code>on_complete</code> closure for a batch. Further examples include the idea that the server logic expects to not complete recv_trailing_metadata until after it actually sends trailing metadata since it would have already found this out by seeing a NULL’ed recv_message. This is considered part of the transport's duties in preserving orders. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 9 2023 01:02:56 for GRPC Core by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
