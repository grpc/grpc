// Generated by the gRPC client protobuf plugin.
// If you make any local change, they will be lost.
// source: helloworld.proto
#include <iostream>
#include <memory>
#include <string>
#include <cstdint>
#include <thread>
#include <gflags/gflags.h>
#include <grpc++/grpc++.h>
#include <grpc/support/log.h>
#include <grpc/support/useful.h>

#include "helloworld.grpc.pb.h"

// In some distros, gflags is in the namespace google, and in some others,
// in gflags. This hack is enabling us to find both.
namespace google {}
namespace gflags {}
using namespace google;
using namespace gflags;

DEFINE_bool(use_tls, false, "Whether to use tls.");
DEFINE_string(custom_ca_file, "", "File path to override SSL roots.");
DEFINE_int32(server_port, 8080, "Server port.");
DEFINE_string(server_host, "localhost", "Server host to connect to");
DEFINE_string(server_host_override, "foo.test.google.fr",
		"Override the server host which is sent in HTTP header");

using grpc::Channel;
using grpc::ClientContext;
using grpc::ClientReader;
using grpc::ClientReaderWriter;
using grpc::ClientWriter;
using grpc::Status;

using helloworld::Greeter;

class GreeterClientImpl final {
 public:
  GreeterClientImpl(std::shared_ptr<Channel> channel)
    : stub_(Greeter::NewStub(channel)) {}

  void SayHello() {

    // This is the request message type that the RPC expects.
    // We declare it here, and will populate it below
    ::helloworld::HelloRequest hellorequest_request;

    // This is the response message type that we will receive.
    // We declare it here, and will populate it below
    ::helloworld::HelloReply helloreply_response;

    // This context will be used by the RPC to track metadata
    ClientContext context;

    // Here we recursively populate the request message with random data.
    // This would be a good section to modify with data that makes
    // more sense for your service specifically.
    {
      // adding the field name
      std::string name = "finite company";
      hellorequest_request.set_name(name);

    }
    // Done populating the request type

    // This is where the actual RPC is performed
    Status status = stub_->SayHello(&context, hellorequest_request, &helloreply_response);

    if (status.ok()) {

      // Recursively print all elements of the response message type
      std::cout << "Printing message: name" << std::endl;
      std::cout << "\thelloreply_response.message() = " << helloreply_response.message() << "\n";
      // Done printing response

    } else {
      std::cout << "\tAn error was encountered while performing the RPC SayHello" << std::endl;
      std::cout << "\tError code: " << status.error_code() << ", Error message: " << status.error_message() << std::endl;
    }
  }

 private:
  std::unique_ptr<Greeter::Stub> stub_;
};


std::shared_ptr<Channel> CreateChannel() {
  const int host_port_buf_size = 1024;
  char host_port[host_port_buf_size];
  snprintf(host_port, host_port_buf_size, "%s:%d", FLAGS_server_host.c_str(), FLAGS_server_port);
  return grpc::CreateChannel(host_port, grpc::InsecureChannelCredentials());
}

int main(int argc, char** argv) {

  ParseCommandLineFlags(&argc, &argv, true);

  GreeterClientImpl greeter(CreateChannel());

  std::cout << "Calling Greeter.SayHello:" << std::endl;
  greeter.SayHello();
  std::cout << "Done with Greeter.SayHello\n\n";


  return 0;
}
