%YAML 1.2
--- |
  # GRPC global makefile
  # This currently builds C and C++ code.
  # This file has been automatically generated from a template file.
  # Please look at the templates directory instead.
  # This file can be regenerated from the template by running
  # tools/buildgen/generate_projects.sh

  # Copyright 2015, Google Inc.
  # All rights reserved.
  #
  # Redistribution and use in source and binary forms, with or without
  # modification, are permitted provided that the following conditions are
  # met:
  #
  #     * Redistributions of source code must retain the above copyright
  # notice, this list of conditions and the following disclaimer.
  #     * Redistributions in binary form must reproduce the above
  # copyright notice, this list of conditions and the following disclaimer
  # in the documentation and/or other materials provided with the
  # distribution.
  #     * Neither the name of Google Inc. nor the names of its
  # contributors may be used to endorse or promote products derived from
  # this software without specific prior written permission.
  #
  # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  <%!
    import re
    import os

    proto_re = re.compile('(.*)\\.proto')

    def proto_to_cc(filename):
      m = proto_re.match(filename)
      if not m:
        return filename
      return '$(GENDIR)/' + m.group(1) + '.pb.cc $(GENDIR)/' + m.group(1) + '.grpc.pb.cc'

    sources_that_need_openssl = set()
    sources_that_don_t_need_openssl = set()

    # warnings we'd like, but that dont exist in all compilers
    PREFERRED_WARNINGS=['shadow', 'extra-semi']
    CHECK_WARNINGS=PREFERRED_WARNINGS + ['no-shift-negative-value']

    def warning_var(fmt, warning):
      return fmt % warning.replace('-', '_').upper()

    def neg_warning(warning):
      if warning[0:3] == 'no-':
        return warning[3:]
      else:
        return 'no-' + warning

    lang_to_var = {
      'c': 'CORE',
      'c++': 'CPP',
      'csharp': 'CSHARP'
    }
  %>


  comma := ,


  # Basic platform detection
  HOST_SYSTEM = $(shell uname | cut -f 1 -d_)
  SYSTEM ?= $(HOST_SYSTEM)
  ifeq ($(SYSTEM),MSYS)
  SYSTEM = MINGW32
  endif
  ifeq ($(SYSTEM),MINGW64)
  SYSTEM = MINGW32
  endif


  MAKEFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))
  ifndef BUILDDIR
  BUILDDIR_ABSOLUTE = $(patsubst %/,%,$(dir $(MAKEFILE_PATH)))
  else
  BUILDDIR_ABSOLUTE = $(abspath $(BUILDDIR))
  endif

  HAS_GCC = $(shell which gcc > /dev/null 2> /dev/null && echo true || echo false)
  HAS_CC = $(shell which cc > /dev/null 2> /dev/null && echo true || echo false)
  HAS_CLANG = $(shell which clang > /dev/null 2> /dev/null && echo true || echo false)

  ifeq ($(HAS_CC),true)
  DEFAULT_CC = cc
  DEFAULT_CXX = c++
  else
  ifeq ($(HAS_GCC),true)
  DEFAULT_CC = gcc
  DEFAULT_CXX = g++
  else
  ifeq ($(HAS_CLANG),true)
  DEFAULT_CC = clang
  DEFAULT_CXX = clang++
  else
  DEFAULT_CC = no_c_compiler
  DEFAULT_CXX = no_c++_compiler
  endif
  endif
  endif


  BINDIR = $(BUILDDIR_ABSOLUTE)/bins
  OBJDIR = $(BUILDDIR_ABSOLUTE)/objs
  LIBDIR = $(BUILDDIR_ABSOLUTE)/libs
  GENDIR = $(BUILDDIR_ABSOLUTE)/gens

  # Configurations

  % for name, args in configs.iteritems():
  VALID_CONFIG_${name} = 1
  %  if args.get('compile_the_world', False):
  REQUIRE_CUSTOM_LIBRARIES_${name} = 1
  %  endif
  %  for tool, default in [('CC', 'CC'), ('CXX', 'CXX'), ('LD', 'CC'), ('LDXX', 'CXX')]:
  ${tool}_${name} = ${args.get(tool, '$(DEFAULT_%s)' % default)}
  %  endfor
  %  for arg in ['CFLAGS', 'CXXFLAGS', 'CPPFLAGS', 'LDFLAGS', 'DEFINES']:
  %   if args.get(arg, None) is not None:
  ${arg}_${name} = ${args.get(arg)}
  %   endif
  %  endfor

  % endfor


  # General settings.
  # You may want to change these depending on your system.

  prefix ?= /usr/local

  PROTOC ?= protoc
  DTRACE ?= dtrace
  CONFIG ?= opt
  # Doing X ?= Y is the same as:
  # ifeq ($(origin X), undefined)
  #  X = Y
  # endif
  # but some variables, such as CC, CXX, LD or AR, have defaults.
  # So instead of using ?= on them, we need to check their origin.
  # See:
  #  https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html
  #  https://www.gnu.org/software/make/manual/html_node/Flavors.html#index-_003f_003d
  #  https://www.gnu.org/software/make/manual/html_node/Origin-Function.html
  ifeq ($(origin CC), default)
  CC = $(CC_$(CONFIG))
  endif
  ifeq ($(origin CXX), default)
  CXX = $(CXX_$(CONFIG))
  endif
  ifeq ($(origin LD), default)
  LD = $(LD_$(CONFIG))
  endif
  LDXX ?= $(LDXX_$(CONFIG))
  ifeq ($(SYSTEM),Linux)
  ifeq ($(origin AR), default)
  AR = ar rcs
  endif
  STRIP ?= strip --strip-unneeded
  else
  ifeq ($(SYSTEM),Darwin)
  ifeq ($(origin AR), default)
  AR = libtool -no_warning_for_no_symbols -o
  endif
  STRIP ?= strip -x
  else
  ifeq ($(SYSTEM),MINGW32)
  ifeq ($(origin AR), default)
  AR = ar rcs
  endif
  STRIP ?= strip --strip-unneeded
  else
  ifeq ($(origin AR), default)
  AR = ar rcs
  endif
  STRIP ?= strip
  endif
  endif
  endif
  INSTALL ?= install
  RM ?= rm -f
  PKG_CONFIG ?= pkg-config

  ifndef VALID_CONFIG_$(CONFIG)
  $(error Invalid CONFIG value '$(CONFIG)')
  endif

  ifeq ($(SYSTEM),Linux)
  TMPOUT = /dev/null
  else
  TMPOUT = `mktemp /tmp/test-out-XXXXXX`
  endif

  # Detect if we can use C++11
  CXX11_CHECK_CMD = $(CXX) -std=c++11 -o $(TMPOUT) -c test/build/c++11.cc
  HAS_CXX11 = $(shell $(CXX11_CHECK_CMD) 2> /dev/null && echo true || echo false)

  %for warning in CHECK_WARNINGS:
  ${warning_var('CHECK_%s_WORKS_CMD', warning)} = $(CC) -std=c99 -Werror -W${warning} -o $(TMPOUT) -c test/build/${warning}.c
  ${warning_var('HAS_WORKING_%s', warning)} = $(shell $(${warning_var('CHECK_%s_WORKS_CMD', warning)}) 2> /dev/null && echo true || echo false)
  ifeq ($(${warning_var('HAS_WORKING_%s', warning)}),true)
  ${warning_var('W_%s', warning)}=-W${warning}
  ${warning_var('NO_W_%s', warning)}=-W${neg_warning(warning)}
  endif
  %endfor

  # The HOST compiler settings are used to compile the protoc plugins.
  # In most cases, you won't have to change anything, but if you are
  # cross-compiling, you can override these variables from GNU make's
  # command line: make CC=cross-gcc HOST_CC=gcc

  HOST_CC ?= $(CC)
  HOST_CXX ?= $(CXX)
  HOST_LD ?= $(LD)
  HOST_LDXX ?= $(LDXX)

  CFLAGS += -std=c99 -Wsign-conversion -Wconversion ${' '.join(warning_var('$(W_%s)', warning) for warning in PREFERRED_WARNINGS)}
  ifeq ($(HAS_CXX11),true)
  CXXFLAGS += -std=c++11
  else
  CXXFLAGS += -std=c++0x
  endif
  % for arg in ['CFLAGS', 'CXXFLAGS', 'CPPFLAGS', 'LDFLAGS', 'DEFINES']:
  %  if defaults.get('global', []).get(arg, None) is not None:
  ${arg} += ${defaults.get('global').get(arg)}
  %  endif
  % endfor

  CPPFLAGS += $(CPPFLAGS_$(CONFIG))
  CFLAGS += $(CFLAGS_$(CONFIG))
  CXXFLAGS += $(CXXFLAGS_$(CONFIG))
  DEFINES += $(DEFINES_$(CONFIG)) INSTALL_PREFIX=\"$(prefix)\"
  LDFLAGS += $(LDFLAGS_$(CONFIG))

  ifneq ($(SYSTEM),MINGW32)
  PIC_CPPFLAGS = -fPIC
  CPPFLAGS += -fPIC
  LDFLAGS += -fPIC
  endif

  INCLUDES = . include $(GENDIR)
  LDFLAGS += -Llibs/$(CONFIG)

  ifeq ($(SYSTEM),Darwin)
  ifneq ($(wildcard /usr/local/ssl/include),)
  INCLUDES += /usr/local/ssl/include
  endif
  ifneq ($(wildcard /opt/local/include),)
  INCLUDES += /opt/local/include
  endif
  ifneq ($(wildcard /usr/local/include),)
  INCLUDES += /usr/local/include
  endif
  LIBS = m z
  ifneq ($(wildcard /usr/local/ssl/lib),)
  LDFLAGS += -L/usr/local/ssl/lib
  endif
  ifneq ($(wildcard /opt/local/lib),)
  LDFLAGS += -L/opt/local/lib
  endif
  ifneq ($(wildcard /usr/local/lib),)
  LDFLAGS += -L/usr/local/lib
  endif
  endif

  ifeq ($(SYSTEM),Linux)
  LIBS = dl rt m pthread
  LDFLAGS += -pthread
  endif

  ifeq ($(SYSTEM),MINGW32)
  LIBS = m pthread ws2_32
  LDFLAGS += -pthread
  endif

  #
  # The steps for cross-compiling are as follows:
  # First, clone and make install of grpc using the native compilers for the host.
  # Also, install protoc (e.g., from a package like apt-get)
  # Then clone a fresh grpc for the actual cross-compiled build
  # Set the environment variable GRPC_CROSS_COMPILE to true
  # Set CC, CXX, LD, LDXX, AR, and STRIP to the cross-compiling binaries
  # Also set PROTOBUF_CONFIG_OPTS to indicate cross-compilation to protobuf (e.g.,
  #  PROTOBUF_CONFIG_OPTS="--host=arm-linux --with-protoc=/usr/local/bin/protoc" )
  # Set HAS_PKG_CONFIG=false
  # To build tests, go to third_party/gflags and follow its ccmake instructions
  # Make sure that you enable building shared libraries and set your prefix to
  # something useful like /usr/local/cross
  # You will also need to set GRPC_CROSS_LDOPTS and GRPC_CROSS_AROPTS to hold
  # additional required arguments for LD and AR (examples below)
  # Then you can do a make from the cross-compiling fresh clone!
  #
  ifeq ($(GRPC_CROSS_COMPILE),true)
  LDFLAGS += $(GRPC_CROSS_LDOPTS) # e.g. -L/usr/local/lib -L/usr/local/cross/lib
  AROPTS = $(GRPC_CROSS_AROPTS) # e.g., rc --target=elf32-little
  USE_BUILT_PROTOC = false
  endif

  GTEST_LIB = -Ithird_party/googletest/googletest/include -Ithird_party/googletest/googletest third_party/googletest/googletest/src/gtest-all.cc
  GTEST_LIB += -lgflags
  ifeq ($(V),1)
  E = @:
  Q =
  else
  E = @echo
  Q = @
  endif

  CORE_VERSION = ${settings.core_version}
  CPP_VERSION = ${settings.cpp_version}
  CSHARP_VERSION = ${settings.csharp_version}

  CPPFLAGS_NO_ARCH += $(addprefix -I, $(INCLUDES)) $(addprefix -D, $(DEFINES))
  CPPFLAGS += $(CPPFLAGS_NO_ARCH) $(ARCH_FLAGS)

  LDFLAGS += $(ARCH_FLAGS)
  LDLIBS += $(addprefix -l, $(LIBS))
  LDLIBSXX += $(addprefix -l, $(LIBSXX))


  % for arg in ['CFLAGS', 'CXXFLAGS', 'CPPFLAGS', 'LDFLAGS', 'DEFINES', 'LDLIBS']:
  ${arg} += $(EXTRA_${arg})
  % endfor

  HOST_CPPFLAGS = $(CPPFLAGS)
  HOST_CFLAGS = $(CFLAGS)
  HOST_CXXFLAGS = $(CXXFLAGS)
  HOST_LDFLAGS = $(LDFLAGS)
  HOST_LDLIBS = $(LDLIBS)

  # These are automatically computed variables.
  # There shouldn't be any need to change anything from now on.

  -include cache.mk

  CACHE_MK =

  HAS_PKG_CONFIG ?= $(shell command -v $(PKG_CONFIG) >/dev/null 2>&1 && echo true || echo false)

  ifeq ($(HAS_PKG_CONFIG), true)
  CACHE_MK += HAS_PKG_CONFIG = true,
  endif

  CORE_PC_TEMPLATE = prefix=$(prefix),\
  exec_prefix=${'\$${prefix}'},\
  includedir=${'\$${prefix}'}/include,\
  libdir=${'\$${exec_prefix}'}/lib,\
  ,\
  Name: $(PC_NAME),\
  Description: $(PC_DESCRIPTION),\
  Version: $(CORE_VERSION),\
  Cflags: -I${'\$${includedir}'} $(PC_CFLAGS),\
  Requires.private: $(PC_REQUIRES_PRIVATE),\
  Libs: -L${'\$${libdir}'} $(PC_LIB),\
  Libs.private: $(PC_LIBS_PRIVATE)

  CPP_PC_TEMPLATE = prefix=$(prefix),\
  exec_prefix=${'\$${prefix}'},\
  includedir=${'\$${prefix}'}/include,\
  libdir=${'\$${exec_prefix}'}/lib,\
  ,\
  Name: $(PC_NAME),\
  Description: $(PC_DESCRIPTION),\
  Version: $(CPP_VERSION),\
  Cflags: -I${'\$${includedir}'} $(PC_CFLAGS),\
  Requires.private: $(PC_REQUIRES_PRIVATE),\
  Libs: -L${'\$${libdir}'} $(PC_LIB),\
  Libs.private: $(PC_LIBS_PRIVATE)

  CSHARP_PC_TEMPLATE = prefix=$(prefix),\
  exec_prefix=${'\$${prefix}'},\
  includedir=${'\$${prefix}'}/include,\
  libdir=${'\$${exec_prefix}'}/lib,\
  ,\
  Name: $(PC_NAME),\
  Description: $(PC_DESCRIPTION),\
  Version: $(CSHARP_VERSION),\
  Cflags: -I${'\$${includedir}'} $(PC_CFLAGS),\
  Requires.private: $(PC_REQUIRES_PRIVATE),\
  Libs: -L${'\$${libdir}'} $(PC_LIB),\
  Libs.private: $(PC_LIBS_PRIVATE)

  ifeq ($(SYSTEM),MINGW32)
  EXECUTABLE_SUFFIX = .exe
  SHARED_EXT_CORE = dll
  SHARED_EXT_CPP = dll
  SHARED_EXT_CSHARP = dll
  SHARED_PREFIX =
  SHARED_VERSION_CORE = -${settings.core_version.major}
  SHARED_VERSION_CPP = -${settings.cpp_version.major}
  SHARED_VERSION_CSHARP = -${settings.csharp_version.major}
  else ifeq ($(SYSTEM),Darwin)
  EXECUTABLE_SUFFIX =
  SHARED_EXT_CORE = dylib
  SHARED_EXT_CPP = dylib
  SHARED_EXT_CSHARP = dylib
  SHARED_PREFIX = lib
  SHARED_VERSION_CORE =
  SHARED_VERSION_CPP =
  SHARED_VERSION_CSHARP =
  else
  EXECUTABLE_SUFFIX =
  SHARED_EXT_CORE = so.$(CORE_VERSION)
  SHARED_EXT_CPP = so.$(CPP_VERSION)
  SHARED_EXT_CSHARP = so.$(CSHARP_VERSION)
  SHARED_PREFIX = lib
  SHARED_VERSION_CORE =
  SHARED_VERSION_CPP =
  SHARED_VERSION_CSHARP =
  endif

  ifeq ($(wildcard .git),)
  IS_GIT_FOLDER = false
  else
  IS_GIT_FOLDER = true
  endif

  ifeq ($(HAS_PKG_CONFIG),true)
  OPENSSL_ALPN_CHECK_CMD = $(PKG_CONFIG) --atleast-version=1.0.2 openssl
  OPENSSL_NPN_CHECK_CMD = $(PKG_CONFIG) --atleast-version=1.0.1 openssl
  ZLIB_CHECK_CMD = $(PKG_CONFIG) --exists zlib
  PROTOBUF_CHECK_CMD = $(PKG_CONFIG) --atleast-version=3.0.0 protobuf
  CARES_CHECK_CMD = $(PKG_CONFIG) --exists libcares
  else # HAS_PKG_CONFIG

  ifeq ($(SYSTEM),MINGW32)
  OPENSSL_LIBS = ssl32 eay32
  else
  OPENSSL_LIBS = ssl crypto
  endif

  OPENSSL_ALPN_CHECK_CMD = $(CC) $(CPPFLAGS) $(CFLAGS) -o $(TMPOUT) test/build/openssl-alpn.c $(addprefix -l, $(OPENSSL_LIBS)) $(LDFLAGS)
  OPENSSL_NPN_CHECK_CMD = $(CC) $(CPPFLAGS) $(CFLAGS) -o $(TMPOUT) test/build/openssl-npn.c $(addprefix -l, $(OPENSSL_LIBS)) $(LDFLAGS)
  BORINGSSL_COMPILE_CHECK_CMD = $(CC) $(CPPFLAGS) ${defaults.boringssl.CPPFLAGS} $(CFLAGS) ${defaults.boringssl.CFLAGS} -o $(TMPOUT) test/build/boringssl.c $(LDFLAGS)
  ZLIB_CHECK_CMD = $(CC) $(CPPFLAGS) $(CFLAGS) -o $(TMPOUT) test/build/zlib.c -lz $(LDFLAGS)
  PROTOBUF_CHECK_CMD = $(CXX) $(CPPFLAGS) $(CXXFLAGS) -o $(TMPOUT) test/build/protobuf.cc -lprotobuf $(LDFLAGS)
  CARES_CHECK_CMD = $(CXX) $(CPPFLAGS) $(CXXFLAGS) -o $(TMPOUT) test/build/c-ares.c -lcares $(LDFLAGS)

  endif # HAS_PKG_CONFIG

  PERFTOOLS_CHECK_CMD = $(CC) $(CPPFLAGS) $(CFLAGS) -o $(TMPOUT) test/build/perftools.c -lprofiler $(LDFLAGS)

  PROTOC_CHECK_CMD = which protoc > /dev/null
  PROTOC_CHECK_VERSION_CMD = protoc --version | grep -q libprotoc.3
  DTRACE_CHECK_CMD = which dtrace > /dev/null
  SYSTEMTAP_HEADERS_CHECK_CMD = $(CC) $(CPPFLAGS) $(CFLAGS) -o $(TMPOUT) test/build/systemtap.c $(LDFLAGS)

  ifndef REQUIRE_CUSTOM_LIBRARIES_$(CONFIG)
  HAS_SYSTEM_PERFTOOLS ?= $(shell $(PERFTOOLS_CHECK_CMD) 2> /dev/null && echo true || echo false)
  ifeq ($(HAS_SYSTEM_PERFTOOLS),true)
  DEFINES += GRPC_HAVE_PERFTOOLS
  LIBS += profiler
  CACHE_MK += HAS_SYSTEM_PERFTOOLS = true,
  endif
  endif

  HAS_SYSTEM_PROTOBUF_VERIFY = $(shell $(PROTOBUF_CHECK_CMD) 2> /dev/null && echo true || echo false)
  ifndef REQUIRE_CUSTOM_LIBRARIES_$(CONFIG)
  HAS_SYSTEM_OPENSSL_ALPN ?= $(shell $(OPENSSL_ALPN_CHECK_CMD) 2> /dev/null && echo true || echo false)
  ifeq ($(HAS_SYSTEM_OPENSSL_ALPN),true)
  HAS_SYSTEM_OPENSSL_NPN = true
  CACHE_MK += HAS_SYSTEM_OPENSSL_ALPN = true,
  else
  HAS_SYSTEM_OPENSSL_NPN ?= $(shell $(OPENSSL_NPN_CHECK_CMD) 2> /dev/null && echo true || echo false)
  endif
  ifeq ($(HAS_SYSTEM_OPENSSL_NPN),true)
  CACHE_MK += HAS_SYSTEM_OPENSSL_NPN = true,
  endif
  HAS_SYSTEM_ZLIB ?= $(shell $(ZLIB_CHECK_CMD) 2> /dev/null && echo true || echo false)
  ifeq ($(HAS_SYSTEM_ZLIB),true)
  CACHE_MK += HAS_SYSTEM_ZLIB = true,
  endif
  HAS_SYSTEM_PROTOBUF ?= $(HAS_SYSTEM_PROTOBUF_VERIFY)
  ifeq ($(HAS_SYSTEM_PROTOBUF),true)
  CACHE_MK += HAS_SYSTEM_PROTOBUF = true,
  endif
  HAS_SYSTEM_CARES ?=  $(shell $(CARES_CHECK_CMD) 2> /dev/null && echo true || echo false)
  ifeq ($(HAS_SYSTEM_CARES),true)
  CACHE_MK += HAS_SYSTEM_CARES = true,
  endif
  else
  # override system libraries if the config requires a custom compiled library
  HAS_SYSTEM_OPENSSL_ALPN = false
  HAS_SYSTEM_OPENSSL_NPN = false
  HAS_SYSTEM_ZLIB = false
  HAS_SYSTEM_PROTOBUF = false
  HAS_SYSTEM_CARES = false
  endif

  HAS_PROTOC ?= $(shell $(PROTOC_CHECK_CMD) 2> /dev/null && echo true || echo false)
  ifeq ($(HAS_PROTOC),true)
  CACHE_MK += HAS_PROTOC = true,
  HAS_VALID_PROTOC ?= $(shell $(PROTOC_CHECK_VERSION_CMD) 2> /dev/null && echo true || echo false)
  ifeq ($(HAS_VALID_PROTOC),true)
  CACHE_MK += HAS_VALID_PROTOC = true,
  endif
  else
  HAS_VALID_PROTOC = false
  endif

  # Check for Systemtap (https://sourceware.org/systemtap/), first by making sure <sys/sdt.h> is present
  # in the system and secondly by checking for the "dtrace" binary (on Linux, this is part of the Systemtap
  # distribution. It's part of the base system on BSD/Solaris machines).
  ifndef HAS_SYSTEMTAP
  HAS_SYSTEMTAP_HEADERS = $(shell $(SYSTEMTAP_HEADERS_CHECK_CMD) 2> /dev/null && echo true || echo false)
  HAS_DTRACE = $(shell $(DTRACE_CHECK_CMD) 2> /dev/null && echo true || echo false)
  HAS_SYSTEMTAP = false
  ifeq ($(HAS_SYSTEMTAP_HEADERS),true)
  ifeq ($(HAS_DTRACE),true)
  HAS_SYSTEMTAP = true
  endif
  endif
  endif

  ifeq ($(HAS_SYSTEMTAP),true)
  CACHE_MK += HAS_SYSTEMTAP = true,
  endif

  # Note that for testing purposes, one can do:
  #   make HAS_EMBEDDED_OPENSSL_ALPN=false
  # to emulate the fact we do not have OpenSSL in the third_party folder.
  ifneq ($(wildcard third_party/${openssl_fallback.extraction_dir}/libssl.a),)
  HAS_EMBEDDED_OPENSSL_ALPN = third_party/${openssl_fallback.extraction_dir}
  else ifeq ($(wildcard third_party/boringssl/include/openssl/ssl.h),)
  HAS_EMBEDDED_OPENSSL_ALPN = false
  else
  CAN_COMPILE_EMBEDDED_OPENSSL ?= $(shell $(BORINGSSL_COMPILE_CHECK_CMD) 2> /dev/null && echo true || echo false)
  HAS_EMBEDDED_OPENSSL_ALPN = $(CAN_COMPILE_EMBEDDED_OPENSSL)
  endif

  ifeq ($(wildcard third_party/zlib/zlib.h),)
  HAS_EMBEDDED_ZLIB = false
  else
  HAS_EMBEDDED_ZLIB = true
  endif

  ifeq ($(wildcard third_party/protobuf/src/google/protobuf/descriptor.pb.h),)
  HAS_EMBEDDED_PROTOBUF = false
  ifneq ($(HAS_VALID_PROTOC),true)
  NO_PROTOC = true
  endif
  else
  HAS_EMBEDDED_PROTOBUF = true
  endif

  ifeq ($(wildcard third_party/cares/cares/ares.h),)
  HAS_EMBEDDED_CARES = false
  else
  HAS_EMBEDDED_CARES = true
  endif

  PC_REQUIRES_GRPC =
  PC_LIBS_GRPC =

  ifeq ($(HAS_SYSTEM_ZLIB),false)
  ifeq ($(HAS_EMBEDDED_ZLIB), true)
  EMBED_ZLIB ?= true
  else
  DEP_MISSING += zlib
  EMBED_ZLIB ?= broken
  endif
  else
  EMBED_ZLIB ?= false
  endif

  ifeq ($(EMBED_ZLIB),true)
  ZLIB_DEP = $(LIBDIR)/$(CONFIG)/libz.a
  ZLIB_MERGE_LIBS = $(LIBDIR)/$(CONFIG)/libz.a
  ZLIB_MERGE_OBJS = $(LIBZ_OBJS)
  CPPFLAGS += -Ithird_party/zlib
  LDFLAGS += -L$(LIBDIR)/$(CONFIG)/zlib
  else
  ifeq ($(HAS_PKG_CONFIG),true)
  CPPFLAGS += $(shell $(PKG_CONFIG) --cflags zlib)
  LDFLAGS += $(shell $(PKG_CONFIG) --libs-only-L zlib)
  LIBS += $(patsubst -l%,%,$(shell $(PKG_CONFIG) --libs-only-l zlib))
  PC_REQUIRES_GRPC += zlib
  else
  PC_LIBS_GRPC += -lz
  LIBS += z
  endif
  endif

  CARES_PKG_CONFIG = false

  ifeq ($(HAS_SYSTEM_CARES),false)
  ifeq ($(HAS_EMBEDDED_CARES), true)
  EMBED_CARES ?= true
  else
  DEP_MISSING += cares
  EMBED_CARES ?= broken
  endif
  else
  EMBED_CARES ?= false
  endif

  ifeq ($(EMBED_CARES),true)
  CARES_DEP = $(LIBDIR)/$(CONFIG)/libares.a
  CARES_MERGE_OBJS = $(LIBARES_OBJS)
  CARES_MERGE_LIBS = $(LIBDIR)/$(CONFIG)/libares.a
  CPPFLAGS := -Ithird_party/cares -Ithird_party/cares/cares $(CPPFLAGS)
  LDFLAGS := -L$(LIBDIR)/$(CONFIG)/c-ares $(LDFLAGS)
  else
  ifeq ($(HAS_PKG_CONFIG),true)
  PC_REQUIRES_GRPC += libcares
  CPPFLAGS += $(shell $(PKG_CONFIG) --cflags libcares)
  LDFLAGS += $(shell $(PKG_CONFIG) --libs-only-L libcares)
  LIBS += $(patsubst -l%,%,$(shell $(PKG_CONFIG) --libs-only-l libcares))
  else
  PC_LIBS_GRPC += -lcares
  LIBS += cares
  endif
  endif

  OPENSSL_PKG_CONFIG = false

  PC_REQUIRES_SECURE =
  PC_LIBS_SECURE =

  ifeq ($(HAS_SYSTEM_OPENSSL_ALPN),true)
  EMBED_OPENSSL ?= false
  NO_SECURE ?= false
  else # HAS_SYSTEM_OPENSSL_ALPN=false
  ifneq ($(HAS_EMBEDDED_OPENSSL_ALPN),false)
  EMBED_OPENSSL ?= $(HAS_EMBEDDED_OPENSSL_ALPN)
  NO_SECURE ?= false
  else # HAS_EMBEDDED_OPENSSL_ALPN=false
  ifeq ($(HAS_SYSTEM_OPENSSL_NPN),true)
  EMBED_OPENSSL ?= false
  NO_SECURE ?= false
  else
  NO_SECURE ?= true
  endif # HAS_SYSTEM_OPENSSL_NPN=true
  endif # HAS_EMBEDDED_OPENSSL_ALPN
  endif # HAS_SYSTEM_OPENSSL_ALPN

  OPENSSL_DEP :=
  OPENSSL_MERGE_LIBS :=
  ifeq ($(NO_SECURE),false)
  ifeq ($(EMBED_OPENSSL),true)
  OPENSSL_DEP += $(LIBDIR)/$(CONFIG)/libboringssl.a
  OPENSSL_MERGE_LIBS += $(LIBDIR)/$(CONFIG)/libboringssl.a
  OPENSSL_MERGE_OBJS += $(LIBBORINGSSL_OBJS)
  # need to prefix these to ensure overriding system libraries
  CPPFLAGS := -Ithird_party/boringssl/include $(CPPFLAGS)
  else ifneq ($(EMBED_OPENSSL),false)
  OPENSSL_DEP += $(EMBED_OPENSSL)/libssl.a $(EMBED_OPENSSL)/libcrypto.a
  OPENSSL_MERGE_LIBS += $(EMBED_OPENSSL)/libssl.a $(EMBED_OPENSSL)/libcrypto.a
  OPENSSL_MERGE_OBJS += $(wildcard $(EMBED_OPENSSL)/grpc_obj/*.o)
  # need to prefix these to ensure overriding system libraries
  CPPFLAGS := -I$(EMBED_OPENSSL)/include $(CPPFLAGS)
  else # EMBED_OPENSSL=false
  ifeq ($(HAS_PKG_CONFIG),true)
  OPENSSL_PKG_CONFIG = true
  PC_REQUIRES_SECURE = openssl
  CPPFLAGS := $(shell $(PKG_CONFIG) --cflags openssl) $(CPPFLAGS)
  LDFLAGS_OPENSSL_PKG_CONFIG = $(shell $(PKG_CONFIG) --libs-only-L openssl)
  ifeq ($(SYSTEM),Linux)
  ifneq ($(LDFLAGS_OPENSSL_PKG_CONFIG),)
  LDFLAGS_OPENSSL_PKG_CONFIG += $(shell $(PKG_CONFIG) --libs-only-L openssl | sed s/L/Wl,-rpath,/)
  endif # LDFLAGS_OPENSSL_PKG_CONFIG=''
  endif # System=Linux
  LDFLAGS := $(LDFLAGS_OPENSSL_PKG_CONFIG) $(LDFLAGS)
  else # HAS_PKG_CONFIG=false
  LIBS_SECURE = $(OPENSSL_LIBS)
  endif # HAS_PKG_CONFIG
  ifeq ($(HAS_SYSTEM_OPENSSL_NPN),true)
  CPPFLAGS += -DTSI_OPENSSL_ALPN_SUPPORT=0
  LIBS_SECURE = $(OPENSSL_LIBS)
  endif # HAS_SYSTEM_OPENSSL_NPN
  PC_LIBS_SECURE = $(addprefix -l, $(LIBS_SECURE))
  endif # EMBED_OPENSSL
  endif # NO_SECURE

  ifeq ($(OPENSSL_PKG_CONFIG),true)
  LDLIBS_SECURE += $(shell $(PKG_CONFIG) --libs-only-l openssl)
  else
  LDLIBS_SECURE += $(addprefix -l, $(LIBS_SECURE))
  endif

  # grpc .pc file
  PC_NAME = gRPC
  PC_DESCRIPTION = high performance general RPC framework
  PC_CFLAGS =
  PC_REQUIRES_PRIVATE = $(PC_REQUIRES_GRPC) $(PC_REQUIRES_SECURE)
  PC_LIBS_PRIVATE = $(PC_LIBS_GRPC) $(PC_LIBS_SECURE)
  PC_LIB = -lgrpc
  GRPC_PC_FILE := $(CORE_PC_TEMPLATE)

  # grpc_unsecure .pc file
  PC_NAME = gRPC unsecure
  PC_DESCRIPTION = high performance general RPC framework without SSL
  PC_CFLAGS =
  PC_REQUIRES_PRIVATE = $(PC_REQUIRES_GRPC)
  PC_LIBS_PRIVATE = $(PC_LIBS_GRPC)
  PC_LIB = -lgrpc
  GRPC_UNSECURE_PC_FILE := $(CORE_PC_TEMPLATE)

  PROTOBUF_PKG_CONFIG = false

  PC_REQUIRES_GRPCXX =
  PC_LIBS_GRPCXX =

  CPPFLAGS := -Ithird_party/googletest/googletest/include $(CPPFLAGS)

  PROTOC_PLUGINS_ALL =\
  % for tgt in targets:
  % if tgt.build == 'protoc':
   $(BINDIR)/$(CONFIG)/${tgt.name}\
  % endif
  % endfor

  PROTOC_PLUGINS_DIR = $(BINDIR)/$(CONFIG)

  ifeq ($(HAS_SYSTEM_PROTOBUF),true)
  ifeq ($(HAS_PKG_CONFIG),true)
  PROTOBUF_PKG_CONFIG = true
  PC_REQUIRES_GRPCXX = protobuf
  CPPFLAGS := $(shell $(PKG_CONFIG) --cflags protobuf) $(CPPFLAGS)
  LDFLAGS_PROTOBUF_PKG_CONFIG = $(shell $(PKG_CONFIG) --libs-only-L protobuf)
  ifeq ($(SYSTEM),Linux)
  ifneq ($(LDFLAGS_PROTOBUF_PKG_CONFIG),)
  LDFLAGS_PROTOBUF_PKG_CONFIG += $(shell $(PKG_CONFIG) --libs-only-L protobuf | sed s/L/Wl,-rpath,/)
  endif
  endif
  else
  PC_LIBS_GRPCXX = -lprotobuf
  endif
  PROTOC_PLUGINS = $(PROTOC_PLUGINS_ALL)
  else
  ifeq ($(HAS_EMBEDDED_PROTOBUF),true)
  PROTOBUF_DEP = $(LIBDIR)/$(CONFIG)/protobuf/libprotobuf.a
  CPPFLAGS := -Ithird_party/protobuf/src $(CPPFLAGS)
  LDFLAGS := -L$(LIBDIR)/$(CONFIG)/protobuf $(LDFLAGS)
  ifneq ($(USE_BUILT_PROTOC),false)
  PROTOC = $(BINDIR)/$(CONFIG)/protobuf/protoc
  PROTOC_PLUGINS = $(PROTOC_PLUGINS_ALL)
  else
  PROTOC_PLUGINS =
  PROTOC_PLUGINS_DIR = $(prefix)/bin
  endif
  else
  NO_PROTOBUF = true
  endif
  endif

  LIBS_PROTOBUF = protobuf
  LIBS_PROTOC = protoc protobuf

  HOST_LDLIBS_PROTOC += $(addprefix -l, $(LIBS_PROTOC))

  ifeq ($(PROTOBUF_PKG_CONFIG),true)
  LDLIBS_PROTOBUF += $(shell $(PKG_CONFIG) --libs-only-l protobuf)
  else
  LDLIBS_PROTOBUF += $(addprefix -l, $(LIBS_PROTOBUF))
  endif

  # grpc++ .pc file
  PC_NAME = gRPC++
  PC_DESCRIPTION = C++ wrapper for gRPC
  PC_CFLAGS =
  PC_REQUIRES_PRIVATE = grpc $(PC_REQUIRES_GRPCXX)
  PC_LIBS_PRIVATE = $(PC_LIBS_GRPCXX)
  PC_LIB = -lgrpc++
  GRPCXX_PC_FILE := $(CPP_PC_TEMPLATE)

  # grpc++_unsecure .pc file
  PC_NAME = gRPC++ unsecure
  PC_DESCRIPTION = C++ wrapper for gRPC without SSL
  PC_CFLAGS =
  PC_REQUIRES_PRIVATE = grpc_unsecure $(PC_REQUIRES_GRPCXX)
  PC_LIBS_PRIVATE = $(PC_LIBS_GRPCXX)
  PC_LIB = -lgrpc++
  GRPCXX_UNSECURE_PC_FILE := $(CPP_PC_TEMPLATE)

  ifeq ($(MAKECMDGOALS),clean)
  NO_DEPS = true
  endif

  .SECONDARY = %.pb.h %.pb.cc

  ifeq ($(DEP_MISSING),)
  all: static shared plugins\
  % for tgt in targets:
  % if tgt.build == 'all':
   $(BINDIR)/$(CONFIG)/${tgt.name}\
  % endif
  % endfor

  dep_error:
  	@echo "You shouldn't see this message - all of your dependencies are correct."
  else
  all: dep_error git_update stop

  dep_error:
  	@echo
  	@echo "DEPENDENCY ERROR"
  	@echo
  	@echo "You are missing system dependencies that are essential to build grpc,"
  	@echo "and the third_party directory doesn't have them:"
  	@echo
  	@echo "  $(DEP_MISSING)"
  	@echo
  	@echo "Installing the development packages for your system will solve"
  	@echo "this issue. Please consult INSTALL to get more information."
  	@echo
  	@echo "If you need information about why these tests failed, run:"
  	@echo
  	@echo "  make run_dep_checks"
  	@echo
  endif

  git_update:
  ifeq ($(IS_GIT_FOLDER),true)
  	@echo "Additionally, since you are in a git clone, you can download the"
  	@echo "missing dependencies in third_party by running the following command:"
  	@echo
  	@echo "  git submodule update --init"
  	@echo
  endif

  openssl_dep_error: openssl_dep_message git_update stop

  protobuf_dep_error: protobuf_dep_message git_update stop

  protoc_dep_error: protoc_dep_message git_update stop

  openssl_dep_message:
  	@echo
  	@echo "DEPENDENCY ERROR"
  	@echo
  	@echo "The target you are trying to run requires an OpenSSL implementation."
  	@echo "Your system doesn't have one, and either the third_party directory"
  	@echo "doesn't have it, or your compiler can't build BoringSSL."
  	@echo
  	@echo "Please consult INSTALL to get more information."
  	@echo
  	@echo "If you need information about why these tests failed, run:"
  	@echo
  	@echo "  make run_dep_checks"
  	@echo

  protobuf_dep_message:
  	@echo
  	@echo "DEPENDENCY ERROR"
  	@echo
  	@echo "The target you are trying to run requires protobuf 3.0.0+"
  	@echo "Your system doesn't have it, and neither does the third_party directory."
  	@echo
  	@echo "Please consult INSTALL to get more information."
  	@echo
  	@echo "If you need information about why these tests failed, run:"
  	@echo
  	@echo "  make run_dep_checks"
  	@echo

  protoc_dep_message:
  	@echo
  	@echo "DEPENDENCY ERROR"
  	@echo
  	@echo "The target you are trying to run requires protobuf-compiler 3.0.0+"
  	@echo "Your system doesn't have it, and neither does the third_party directory."
  	@echo
  	@echo "Please consult INSTALL to get more information."
  	@echo
  	@echo "If you need information about why these tests failed, run:"
  	@echo
  	@echo "  make run_dep_checks"
  	@echo

  systemtap_dep_error:
  	@echo
  	@echo "DEPENDENCY ERROR"
  	@echo
  	@echo "Under the '$(CONFIG)' configutation, the target you are trying "
  	@echo "to build requires systemtap 2.7+ (on Linux) or dtrace (on other "
  	@echo "platforms such as Solaris and *BSD). "
  	@echo
  	@echo "Please consult INSTALL to get more information."
  	@echo

  stop:
  	@false

  % for tgt in targets:
  ${tgt.name}: $(BINDIR)/$(CONFIG)/${tgt.name}
  % endfor

  run_dep_checks:
  	$(OPENSSL_ALPN_CHECK_CMD) || true
  	$(OPENSSL_NPN_CHECK_CMD) || true
  	$(ZLIB_CHECK_CMD) || true
  	$(PERFTOOLS_CHECK_CMD) || true
  	$(PROTOBUF_CHECK_CMD) || true
  	$(PROTOC_CHECK_VERSION_CMD) || true
  	$(CARES_CHECK_CMD) || true

  third_party/protobuf/configure:
  	$(E) "[AUTOGEN] Preparing protobuf"
  	$(Q)(cd third_party/protobuf ; autoreconf -f -i -Wall,no-obsolete)

  $(LIBDIR)/$(CONFIG)/protobuf/libprotobuf.a: third_party/protobuf/configure
  	$(E) "[MAKE]    Building protobuf"
  	$(Q)(cd third_party/protobuf ; CC="$(CC)" CXX="$(CXX)" LDFLAGS="$(LDFLAGS_$(CONFIG)) -g $(PROTOBUF_LDFLAGS_EXTRA)" CPPFLAGS="$(PIC_CPPFLAGS) $(CPPFLAGS_$(CONFIG)) -g $(PROTOBUF_CPPFLAGS_EXTRA)" ./configure --disable-shared --enable-static $(PROTOBUF_CONFIG_OPTS))
  	$(Q)$(MAKE) -C third_party/protobuf clean
  	$(Q)$(MAKE) -C third_party/protobuf
  	$(Q)mkdir -p $(LIBDIR)/$(CONFIG)/protobuf
  	$(Q)mkdir -p $(BINDIR)/$(CONFIG)/protobuf
  	$(Q)cp third_party/protobuf/src/.libs/libprotoc.a $(LIBDIR)/$(CONFIG)/protobuf
  	$(Q)cp third_party/protobuf/src/.libs/libprotobuf.a $(LIBDIR)/$(CONFIG)/protobuf
  	$(Q)cp third_party/protobuf/src/protoc $(BINDIR)/$(CONFIG)/protobuf

  static: static_c static_cxx

  static_c: pc_c pc_c_unsecure cache.mk \
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.build == 'all' and lib.language == 'c' and not lib.get('external_deps', None):
   $(LIBDIR)/$(CONFIG)/lib${lib.name}.a\
  % endif
  % endif
  % endfor


  static_cxx: pc_cxx pc_cxx_unsecure cache.mk \
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.build == 'all' and lib.language == 'c++':
   $(LIBDIR)/$(CONFIG)/lib${lib.name}.a\
  % endif
  % endif
  % endfor


  shared: shared_c shared_cxx

  shared_c: pc_c pc_c_unsecure cache.mk\
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.build == 'all' and lib.language == 'c' and not lib.get('external_deps', None):
   $(LIBDIR)/$(CONFIG)/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_CORE).$(SHARED_EXT_CORE)\
  % endif
  % endif
  % endfor

  shared_cxx: pc_cxx pc_cxx_unsecure cache.mk\
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.build == 'all' and lib.language == 'c++':
   $(LIBDIR)/$(CONFIG)/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_CPP).$(SHARED_EXT_CPP)\
  % endif
  % endif
  % endfor


  shared_csharp: shared_c \
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.build == 'all' and lib.language == 'csharp':
   $(LIBDIR)/$(CONFIG)/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_CSHARP).$(SHARED_EXT_CSHARP)\
  % endif
  % endif
  % endfor

  grpc_csharp_ext: shared_csharp

  plugins: $(PROTOC_PLUGINS)

  privatelibs: privatelibs_c privatelibs_cxx

  privatelibs_c: \
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.build == 'private' and lib.language == 'c' and not lib.get('external_deps', None) and not lib.boringssl:
   $(LIBDIR)/$(CONFIG)/lib${lib.name}.a\
  % endif
  % endif
  % endfor

  pc_c: $(LIBDIR)/$(CONFIG)/pkgconfig/grpc.pc

  pc_c_unsecure: $(LIBDIR)/$(CONFIG)/pkgconfig/grpc_unsecure.pc

  pc_cxx: $(LIBDIR)/$(CONFIG)/pkgconfig/grpc++.pc

  pc_cxx_unsecure: $(LIBDIR)/$(CONFIG)/pkgconfig/grpc++_unsecure.pc

  ifeq ($(EMBED_OPENSSL),true)
  privatelibs_cxx: \
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.build == 'private' and lib.language == 'c++' and not lib.get('external_deps', None):
   $(LIBDIR)/$(CONFIG)/lib${lib.name}.a\
  % endif
  % endif
  % endfor

  else
  privatelibs_cxx: \
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.build == 'private' and lib.language == 'c++' and not lib.get('external_deps', None) and not lib.boringssl:
   $(LIBDIR)/$(CONFIG)/lib${lib.name}.a\
  % endif
  % endif
  % endfor

  endif


  buildtests: buildtests_c buildtests_cxx

  buildtests_c: privatelibs_c <%text>\</%text>
  % for tgt in targets:
  % if tgt.build == 'test' and not tgt.language == 'c++' and not tgt.get('external_deps', None):
    $(BINDIR)/$(CONFIG)/${tgt.name} <%text>\</%text>
  % endif
  % endfor


  ifeq ($(EMBED_OPENSSL),true)
  buildtests_cxx: privatelibs_cxx <%text>\</%text>
  % for tgt in targets:
  % if tgt.build == 'test' and tgt.language == 'c++' and not tgt.get('external_deps', None):
    $(BINDIR)/$(CONFIG)/${tgt.name} <%text>\</%text>
  % endif
  % endfor

  else
  buildtests_cxx: privatelibs_cxx <%text>\</%text>
  % for tgt in targets:
  % if tgt.build == 'test' and tgt.language == 'c++' and not tgt.get('external_deps', None) and not tgt.boringssl:
    $(BINDIR)/$(CONFIG)/${tgt.name} <%text>\</%text>
  % endif
  % endfor

  endif


  test: test_c test_cxx

  flaky_test: flaky_test_c flaky_test_cxx

  test_c: buildtests_c
  % for tgt in targets:
  % if tgt.build == 'test' and tgt.get('run', True) and not tgt.language == 'c++' and not tgt.get('flaky', False) and not tgt.get('external_deps', None):
  	$(E) "[RUN]     Testing ${tgt.name}"
  	$(Q) $(BINDIR)/$(CONFIG)/${tgt.name} || ( echo test ${tgt.name} failed ; exit 1 )
  % endif
  % endfor


  flaky_test_c: buildtests_c
  % for tgt in targets:
  % if tgt.build == 'test' and tgt.get('run', True) and not tgt.language == 'c++' and tgt.get('flaky', False) and not tgt.get('external_deps', None):
  	$(E) "[RUN]     Testing ${tgt.name}"
  	$(Q) $(BINDIR)/$(CONFIG)/${tgt.name} || ( echo test ${tgt.name} failed ; exit 1 )
  % endif
  % endfor


  test_cxx: buildtests_cxx
  % for tgt in targets:
  % if tgt.build == 'test' and tgt.get('run', True) and tgt.language == 'c++' and not tgt.get('flaky', False) and not tgt.get('external_deps', None):
  	$(E) "[RUN]     Testing ${tgt.name}"
  	$(Q) $(BINDIR)/$(CONFIG)/${tgt.name} || ( echo test ${tgt.name} failed ; exit 1 )
  % endif
  % endfor


  flaky_test_cxx: buildtests_cxx
  % for tgt in targets:
  % if tgt.build == 'test' and tgt.get('run', True) and tgt.language == 'c++' and tgt.get('flaky', False) and not tgt.get('external_deps', None):
  	$(E) "[RUN]     Testing ${tgt.name}"
  	$(Q) $(BINDIR)/$(CONFIG)/${tgt.name} || ( echo test ${tgt.name} failed ; exit 1 )
  % endif
  % endfor


  test_python: static_c
  	$(E) "[RUN]     Testing python code"
  	$(Q) tools/run_tests/run_tests.py -lpython -c$(CONFIG)


  tools: tools_c tools_cxx


  tools_c: privatelibs_c\
  % for tgt in targets:
  % if tgt.build == 'tool' and not tgt.language=='c++':
   $(BINDIR)/$(CONFIG)/${tgt.name}\
  % endif
  % endfor


  tools_cxx: privatelibs_cxx\
  % for tgt in targets:
  % if tgt.build == 'tool' and tgt.language=='c++':
   $(BINDIR)/$(CONFIG)/${tgt.name}\
  % endif
  % endfor


  buildbenchmarks: privatelibs\
  % for tgt in targets:
  % if tgt.build == 'benchmark':
   $(BINDIR)/$(CONFIG)/${tgt.name}\
  % endif
  % endfor


  benchmarks: buildbenchmarks

  strip: strip-static strip-shared

  strip-static: strip-static_c strip-static_cxx

  strip-shared: strip-shared_c strip-shared_cxx


  # TODO(nnoble): the strip target is stripping in-place, instead
  # of copying files in a temporary folder.
  # This prevents proper debugging after running make install.

  strip-static_c: static_c
  ifeq ($(CONFIG),opt)
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.language == "c":
  % if lib.build == "all":
  % if not lib.get('external_deps', None):
  	$(E) "[STRIP]   Stripping lib${lib.name}.a"
  	$(Q) $(STRIP) $(LIBDIR)/$(CONFIG)/lib${lib.name}.a
  % endif
  % endif
  % endif
  % endif
  % endfor
  endif

  strip-static_cxx: static_cxx
  ifeq ($(CONFIG),opt)
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.language == "c++":
  % if lib.build == "all":
  	$(E) "[STRIP]   Stripping lib${lib.name}.a"
  	$(Q) $(STRIP) $(LIBDIR)/$(CONFIG)/lib${lib.name}.a
  % endif
  % endif
  % endif
  % endfor
  endif

  strip-shared_c: shared_c
  ifeq ($(CONFIG),opt)
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.language == "c":
  % if lib.build == "all":
  % if not lib.get('external_deps', None):
  	$(E) "[STRIP]   Stripping $(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_CORE).$(SHARED_EXT_CORE)"
  	$(Q) $(STRIP) $(LIBDIR)/$(CONFIG)/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_CORE).$(SHARED_EXT_CORE)
  % endif
  % endif
  % endif
  % endif
  % endfor
  endif

  strip-shared_cxx: shared_cxx
  ifeq ($(CONFIG),opt)
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.language == "c++":
  % if lib.build == "all":
  	$(E) "[STRIP]   Stripping $(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_CPP).$(SHARED_EXT_CPP)"
  	$(Q) $(STRIP) $(LIBDIR)/$(CONFIG)/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_CPP).$(SHARED_EXT_CPP)
  % endif
  % endif
  % endif
  % endfor
  endif

  strip-shared_csharp: shared_csharp
  ifeq ($(CONFIG),opt)
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.language == "csharp":
  % if lib.build == "all":
  	$(E) "[STRIP]   Stripping $(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_CSHARP).$(SHARED_EXT_CSHARP)"
  	$(Q) $(STRIP) $(LIBDIR)/$(CONFIG)/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_CSHARP).$(SHARED_EXT_CSHARP)
  % endif
  % endif
  % endif
  % endfor
  endif

  cache.mk::
  	$(E) "[MAKE]    Generating $@"
  	$(Q) echo "$(CACHE_MK)" | tr , '\n' >$@

  $(LIBDIR)/$(CONFIG)/pkgconfig/grpc.pc:
  	$(E) "[MAKE]    Generating $@"
  	$(Q) mkdir -p $(@D)
  	$(Q) echo "$(GRPC_PC_FILE)" | tr , '\n' >$@

  $(LIBDIR)/$(CONFIG)/pkgconfig/grpc_unsecure.pc:
  	$(E) "[MAKE]    Generating $@"
  	$(Q) mkdir -p $(@D)
  	$(Q) echo "$(GRPC_UNSECURE_PC_FILE)" | tr , '\n' >$@

  $(LIBDIR)/$(CONFIG)/pkgconfig/grpc++.pc:
  	$(E) "[MAKE]    Generating $@"
  	$(Q) mkdir -p $(@D)
  	$(Q) echo "$(GRPCXX_PC_FILE)" | tr , '\n' >$@

  $(LIBDIR)/$(CONFIG)/pkgconfig/grpc++_unsecure.pc:
  	$(E) "[MAKE]    Generating $@"
  	$(Q) mkdir -p $(@D)
  	$(Q) echo "$(GRPCXX_UNSECURE_PC_FILE)" | tr , '\n' >$@

  % for p in protos:
  ifeq ($(NO_PROTOC),true)
  $(GENDIR)/${p}.pb.cc: protoc_dep_error
  $(GENDIR)/${p}.grpc.pb.cc: protoc_dep_error
  else
  $(GENDIR)/${p}.pb.cc: ${p}.proto $(PROTOBUF_DEP) $(PROTOC_PLUGINS) ${' '.join('$(GENDIR)/%s.pb.cc' % q for q in proto_deps.get(p, []))}
  	$(E) "[PROTOC]  Generating protobuf CC file from $<"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(PROTOC) -Ithird_party/protobuf/src -I. --cpp_out=$(GENDIR) $<

  $(GENDIR)/${p}.grpc.pb.cc: ${p}.proto $(PROTOBUF_DEP) $(PROTOC_PLUGINS) ${' '.join('$(GENDIR)/%s.pb.cc $(GENDIR)/%s.grpc.pb.cc' % (q,q) for q in proto_deps.get(p, []))}
  	$(E) "[GRPC]    Generating gRPC's protobuf service CC file from $<"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(PROTOC) -Ithird_party/protobuf/src -I. --grpc_out=$(GENDIR) --plugin=protoc-gen-grpc=$(PROTOC_PLUGINS_DIR)/grpc_cpp_plugin$(EXECUTABLE_SUFFIX) $<
  endif

  % endfor

  ifeq ($(CONFIG),stapprof)
  src/core/profiling/stap_timers.c: $(GENDIR)/src/core/profiling/stap_probes.h
  ifeq ($(HAS_SYSTEMTAP),true)
  $(GENDIR)/src/core/profiling/stap_probes.h: src/core/profiling/stap_probes.d
  	$(E) "[DTRACE]  Compiling $<"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(DTRACE) -C -h -s $< -o $@
  else
  $(GENDIR)/src/core/profiling/stap_probes.h: systemtap_dep_error stop
  endif
  endif

  $(OBJDIR)/$(CONFIG)/%.o : %.c
  	$(E) "[C]       Compiling $<"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(CC) $(CPPFLAGS) $(CFLAGS) -MMD -MF $(addsuffix .dep, $(basename $@)) -c -o $@ $<

  $(OBJDIR)/$(CONFIG)/%.o : $(GENDIR)/%.pb.cc
  	$(E) "[CXX]     Compiling $<"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(CXX) $(CPPFLAGS) $(CXXFLAGS) -MMD -MF $(addsuffix .dep, $(basename $@)) -c -o $@ $<

  $(OBJDIR)/$(CONFIG)/src/compiler/%.o : src/compiler/%.cc
  	$(E) "[HOSTCXX] Compiling $<"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(HOST_CXX) $(HOST_CXXFLAGS) $(HOST_CPPFLAGS) -MMD -MF $(addsuffix .dep, $(basename $@)) -c -o $@ $<

  $(OBJDIR)/$(CONFIG)/%.o : %.cc
  	$(E) "[CXX]     Compiling $<"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(CXX) $(CPPFLAGS) $(CXXFLAGS) -MMD -MF $(addsuffix .dep, $(basename $@)) -c -o $@ $<

  install: install_c install_cxx install-plugins install-certs

  install_c: install-headers_c install-static_c install-shared_c

  install_cxx: install-headers_cxx install-static_cxx install-shared_cxx

  install_csharp: install-shared_csharp install_c

  install_grpc_csharp_ext: install_csharp

  install-headers: install-headers_c install-headers_cxx

  install-headers_c:
  	$(E) "[INSTALL] Installing public C headers"
  	$(Q) $(foreach h, $(PUBLIC_HEADERS_C), $(INSTALL) -d $(prefix)/$(dir $(h)) && ) exit 0 || exit 1
  	$(Q) $(foreach h, $(PUBLIC_HEADERS_C), $(INSTALL) $(h) $(prefix)/$(h) && ) exit 0 || exit 1

  install-headers_cxx:
  	$(E) "[INSTALL] Installing public C++ headers"
  	$(Q) $(foreach h, $(PUBLIC_HEADERS_CXX), $(INSTALL) -d $(prefix)/$(dir $(h)) && ) exit 0 || exit 1
  	$(Q) $(foreach h, $(PUBLIC_HEADERS_CXX), $(INSTALL) $(h) $(prefix)/$(h) && ) exit 0 || exit 1

  install-static: install-static_c install-static_cxx

  install-static_c: static_c strip-static_c install-pkg-config_c
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.language == "c":
  % if lib.build == "all":
  % if not lib.get('external_deps', None):
  	$(E) "[INSTALL] Installing lib${lib.name}.a"
  	$(Q) $(INSTALL) -d $(prefix)/lib
  	$(Q) $(INSTALL) $(LIBDIR)/$(CONFIG)/lib${lib.name}.a $(prefix)/lib/lib${lib.name}.a
  % endif
  % endif
  % endif
  % endif
  % endfor

  install-static_cxx: static_cxx strip-static_cxx install-pkg-config_cxx
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.language == "c++":
  % if lib.build == "all":
  	$(E) "[INSTALL] Installing lib${lib.name}.a"
  	$(Q) $(INSTALL) -d $(prefix)/lib
  	$(Q) $(INSTALL) $(LIBDIR)/$(CONFIG)/lib${lib.name}.a $(prefix)/lib/lib${lib.name}.a
  % endif
  % endif
  % endif
  % endfor

  <%def name="install_shared(lang_filter)">\
  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  % if lib.language == lang_filter:
  % if lib.build == "all":
  % if not lib.get('external_deps', None):
  	$(E) "[INSTALL] Installing $(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]})"
  	$(Q) $(INSTALL) -d $(prefix)/lib
  	$(Q) $(INSTALL) $(LIBDIR)/$(CONFIG)/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]}) $(prefix)/lib/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]})
  ifeq ($(SYSTEM),MINGW32)
  	$(Q) $(INSTALL) $(LIBDIR)/$(CONFIG)/lib${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]})-dll.a $(prefix)/lib/lib${lib.name}.a
  else ifneq ($(SYSTEM),Darwin)
  	$(Q) ln -sf $(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]}) $(prefix)/lib/lib${lib.name}.so.${settings.core_version.major}
  	$(Q) ln -sf $(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]}) $(prefix)/lib/lib${lib.name}.so
  endif
  % endif
  % endif
  % endif
  % endif
  % endfor
  ifneq ($(SYSTEM),MINGW32)
  ifneq ($(SYSTEM),Darwin)
  	$(Q) ldconfig || true
  endif
  endif
  </%def>

  install-shared_c: shared_c strip-shared_c install-pkg-config_c
  ${install_shared("c")}

  install-shared_cxx: shared_cxx strip-shared_cxx install-shared_c install-pkg-config_cxx
  ${install_shared("c++")}

  install-shared_csharp: shared_csharp strip-shared_csharp
  ${install_shared("csharp")}

  install-plugins: $(PROTOC_PLUGINS)
  	$(E) "[INSTALL] Installing grpc protoc plugins"
  % for tgt in targets:
  % if tgt.build == 'protoc':
  	$(Q) $(INSTALL) -d $(prefix)/bin
  	$(Q) $(INSTALL) $(BINDIR)/$(CONFIG)/${tgt.name} $(prefix)/bin/${tgt.name}
  % endif
  % endfor

  install-pkg-config_c: pc_c pc_c_unsecure
  	$(E) "[INSTALL] Installing C pkg-config files"
  	$(Q) $(INSTALL) -d $(prefix)/lib/pkgconfig
  	$(Q) $(INSTALL) $(LIBDIR)/$(CONFIG)/pkgconfig/grpc.pc $(prefix)/lib/pkgconfig/grpc.pc
  	$(Q) $(INSTALL) $(LIBDIR)/$(CONFIG)/pkgconfig/grpc_unsecure.pc $(prefix)/lib/pkgconfig/grpc_unsecure.pc

  install-pkg-config_cxx: pc_cxx pc_cxx_unsecure
  	$(E) "[INSTALL] Installing C++ pkg-config files"
  	$(Q) $(INSTALL) -d $(prefix)/lib/pkgconfig
  	$(Q) $(INSTALL) $(LIBDIR)/$(CONFIG)/pkgconfig/grpc++.pc $(prefix)/lib/pkgconfig/grpc++.pc
  	$(Q) $(INSTALL) $(LIBDIR)/$(CONFIG)/pkgconfig/grpc++_unsecure.pc $(prefix)/lib/pkgconfig/grpc++_unsecure.pc

  install-certs: etc/roots.pem
  	$(E) "[INSTALL] Installing root certificates"
  	$(Q) $(INSTALL) -d $(prefix)/share/grpc
  	$(Q) $(INSTALL) etc/roots.pem $(prefix)/share/grpc/roots.pem

  clean:
  	$(E) "[CLEAN]   Cleaning build directories."
  	$(Q) $(RM) -rf $(OBJDIR) $(LIBDIR) $(BINDIR) $(GENDIR) cache.mk


  # The various libraries

  % for lib in libs:
  % if 'Makefile' in lib.get('build_system', ['Makefile']):
  ${makelib(lib)}
  % endif
  % endfor


  # All of the test targets, and protoc plugins

  % for tgt in targets:
  ${maketarget(tgt)}
  % endfor

  <%def name="makelib(lib)">
  LIB${lib.name.upper()}_SRC = \\

  % for src in lib.src:
      ${proto_to_cc(src)} \\

  % endfor

  % if "public_headers" in lib:
  % if lib.language == "c++":
  PUBLIC_HEADERS_CXX += \\

  % else:
  PUBLIC_HEADERS_C += \\

  % endif
  % for hdr in lib.public_headers:
      ${hdr} \\

  % endfor
  % endif

  LIB${lib.name.upper()}_OBJS = $(addprefix $(OBJDIR)/$(CONFIG)/, $(addsuffix .o, $(basename $(LIB${lib.name.upper()}_SRC))))

  % if lib.get('defaults', None):
  %  for name, value in defaults.get(lib.defaults).iteritems():
  $(LIB${lib.name.upper()}_OBJS): ${name} += ${value}
  %  endfor
  % endif

  ## If the library requires OpenSSL, let's add some restrictions.
  % if lib.get('secure', 'check') == True or lib.get('secure', 'check') == 'check':
  ifeq ($(NO_SECURE),true)

  # You can't build secure libraries if you don't have OpenSSL.

  $(LIBDIR)/$(CONFIG)/lib${lib.name}.a: openssl_dep_error

  % if lib.build == "all":
  $(LIBDIR)/$(CONFIG)/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]}): openssl_dep_error
  % endif

  else

  % if lib.language == 'c++':
  ifeq ($(NO_PROTOBUF),true)

  # You can't build a C++ library if you don't have protobuf - a bit overreached, but still okay.

  $(LIBDIR)/$(CONFIG)/lib${lib.name}.a: protobuf_dep_error

  % if lib.build == "all":
  $(LIBDIR)/$(CONFIG)/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]}): protobuf_dep_error
  % endif

  else
  % endif

  $(LIBDIR)/$(CONFIG)/lib${lib.name}.a: $(ZLIB_DEP) $(OPENSSL_DEP) $(CARES_DEP)\
  ## The else here corresponds to the if secure earlier.
  % else:
  % if lib.language == 'c++':
  ifeq ($(NO_PROTOBUF),true)

  # You can't build a C++ library if you don't have protobuf - a bit overreached, but still okay.

  $(LIBDIR)/$(CONFIG)/lib${lib.name}.a: protobuf_dep_error

  % if lib.build == "all":
  $(LIBDIR)/$(CONFIG)/$(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]}): protobuf_dep_error
  % endif

  else

  % endif
  $(LIBDIR)/$(CONFIG)/lib${lib.name}.a: \
  % if lib.name != 'z':
  $(ZLIB_DEP) \
  % endif
  % if lib.name != 'ares':
  $(CARES_DEP) \
  % endif
  % endif
  % if lib.language == 'c++':
   $(PROTOBUF_DEP)\
  % endif
   $(LIB${lib.name.upper()}_OBJS) \
  % if lib.get('baselib', False):
   $(LIBGPR_OBJS) \
   $(ZLIB_MERGE_OBJS) \
   $(CARES_MERGE_OBJS) \
  % if lib.get('secure', 'check') == True:
   $(OPENSSL_MERGE_OBJS) \
  % endif
  % endif

  	$(E) "[AR]      Creating $@"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) rm -f $(LIBDIR)/$(CONFIG)/lib${lib.name}.a
  	$(Q) $(AR) $(AROPTS) $(LIBDIR)/$(CONFIG)/lib${lib.name}.a $(LIB${lib.name.upper()}_OBJS) \
  % if lib.get('baselib', False):
   $(LIBGPR_OBJS) \
   $(ZLIB_MERGE_OBJS) \
   $(CARES_MERGE_OBJS) \
  % if lib.get('secure', 'check') == True:
   $(OPENSSL_MERGE_OBJS) \
  % endif
  % endif

  ifeq ($(SYSTEM),Darwin)
  	$(Q) ranlib -no_warning_for_no_symbols $(LIBDIR)/$(CONFIG)/lib${lib.name}.a
  endif

  <%

    if lib.language == 'c++':
      ld = '$(LDXX)'
    else:
      ld = '$(LD)'

    out_mingbase = '$(LIBDIR)/$(CONFIG)/' + lib.name + '$(SHARED_VERSION_' + lang_to_var[lib.language] + ')'
    out_libbase = '$(LIBDIR)/$(CONFIG)/lib' + lib.name + '$(SHARED_VERSION_' + lang_to_var[lib.language] + ')'

    common = '$(LIB' + lib.name.upper() + '_OBJS)'

    link_libs = ''
    lib_deps = ' $(ZLIB_DEP) $(CARES_DEP)'
    mingw_libs = ''
    mingw_lib_deps = ' $(ZLIB_DEP) $(CARES_DEP)'
    if lib.language == 'c++':
      lib_deps += ' $(PROTOBUF_DEP)'
      mingw_lib_deps += ' $(PROTOBUF_DEP)'
    if lib.get('deps_linkage', None) == 'static':
      for dep in lib.get('deps', []):
        lib_archive = '$(LIBDIR)/$(CONFIG)/lib' + dep + '.a'
        common = common + ' ' + lib_archive
        lib_deps = lib_deps + ' ' + lib_archive
        mingw_lib_deps = mingw_lib_deps + ' ' + lib_archive
    else:
      for dep in lib.get('deps', []):
        dep_lib = None
        for dl in libs:
          if dl.name == dep:
            dep_lib = dl
        assert dep_lib, 'lib %s not found (in %s)' % (dep, lib.name)
        link_libs = link_libs + ' -l' + dep
        lib_deps = lib_deps + ' $(LIBDIR)/$(CONFIG)/lib' + dep + '.$(SHARED_EXT_' + lang_to_var[dep_lib.language] + ')'
        mingw_libs = mingw_libs + ' -l' + dep + '$(SHARED_VERSION_' + lang_to_var[dep_lib.language] + ')-dll'
        mingw_lib_deps = mingw_lib_deps + ' $(LIBDIR)/$(CONFIG)/' + dep + '$(SHARED_VERSION_' + lang_to_var[dep_lib.language] + ').$(SHARED_EXT_' + lang_to_var[dep_lib.language] + ')'

    security = lib.get('secure', 'check')
    if security == True:
      common = common + ' $(OPENSSL_MERGE_LIBS) $(LDLIBS_SECURE)'
    common = common + ' $(ZLIB_MERGE_LIBS) $(CARES_MERGE_LIBS)'

    if security in [True, 'check']:
      for src in lib.src:
        if not proto_re.match(src):
          sources_that_need_openssl.add(src)
    else:
      for src in lib.src:
        sources_that_don_t_need_openssl.add(src)

    if lib.get('secure', 'check') == True or lib.get('secure', 'check') == 'check':
      lib_deps = lib_deps + ' $(OPENSSL_DEP)'
      mingw_lib_deps = mingw_lib_deps + ' $(OPENSSL_DEP)'

    if lib.language == 'c++':
      common = common + ' $(LDLIBSXX) $(LDLIBS_PROTOBUF)'

    ldflags = '$(LDFLAGS)'
    if lib.get('LDFLAGS', None):
      ldflags += ' ' + lib['LDFLAGS']

    common = common + ' $(LDLIBS)'
  %>

  % if lib.build == "all":
  ifeq ($(SYSTEM),MINGW32)
  ${out_mingbase}.$(SHARED_EXT_${lang_to_var[lib.language]}): $(LIB${lib.name.upper()}_OBJS) ${mingw_lib_deps}
  	$(E) "[LD]      Linking $@"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) ${ld} ${ldflags} -L$(LIBDIR)/$(CONFIG) -shared -Wl,--output-def=${out_mingbase}.def -Wl,--out-implib=${out_libbase}-dll.a -o ${out_mingbase}.$(SHARED_EXT_${lang_to_var[lib.language]}) ${common}${mingw_libs}
  else
  ${out_libbase}.$(SHARED_EXT_${lang_to_var[lib.language]}): $(LIB${lib.name.upper()}_OBJS) ${lib_deps}
  	$(E) "[LD]      Linking $@"
  	$(Q) mkdir -p `dirname $@`
  ifeq ($(SYSTEM),Darwin)
  	$(Q) ${ld} ${ldflags} -L$(LIBDIR)/$(CONFIG) -install_name $(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]}) -dynamiclib -o ${out_libbase}.$(SHARED_EXT_${lang_to_var[lib.language]}) ${common}${link_libs}
  else
  	$(Q) ${ld} ${ldflags} -L$(LIBDIR)/$(CONFIG) -shared -Wl,-soname,lib${lib.name}.so.${settings.get(lang_to_var[lib.language].lower() + '_version').major} -o ${out_libbase}.$(SHARED_EXT_${lang_to_var[lib.language]}) ${common}${link_libs}
  	$(Q) ln -sf $(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]}) ${out_libbase}.so.${settings.get(lang_to_var[lib.language].lower() + '_version').major}
  	$(Q) ln -sf $(SHARED_PREFIX)${lib.name}$(SHARED_VERSION_${lang_to_var[lib.language]}).$(SHARED_EXT_${lang_to_var[lib.language]}) ${out_libbase}.so
  endif
  endif
  % endif
  % if lib.get('secure', 'check') == True or lib.get('secure', 'check') == 'check':
  ## If the lib was secure, we have to close the Makefile's if that tested
  ## the presence of OpenSSL.

  endif
  % endif
  % if lib.language == 'c++':
  ## If the lib was C++, we have to close the Makefile's if that tested
  ## the presence of protobuf 3.0.0+

  endif
  % endif

  % if lib.get('secure', 'check') == True or lib.get('secure', 'check') == 'check':
  ifneq ($(NO_SECURE),true)
  % endif
  ifneq ($(NO_DEPS),true)
  -include $(LIB${lib.name.upper()}_OBJS:.o=.dep)
  endif
  % if lib.get('secure', 'check') == True or lib.get('secure', 'check') == 'check':
  endif
  % endif
  % for src in lib.src:
  % if not proto_re.match(src) and any(proto_re.match(src2) for src2 in lib.src):
  $(OBJDIR)/$(CONFIG)/${os.path.splitext(src)[0]}.o: ${' '.join(proto_to_cc(src2) for src2 in lib.src if proto_re.match(src2))}
  % endif
  % endfor
  </%def>

  <%def name="maketarget(tgt)"><% has_no_sources = not tgt.src %>
  % if not has_no_sources:
  ${tgt.name.upper()}_SRC = \\

  % for src in tgt.src:
      ${proto_to_cc(src)} \\

  % endfor

  ${tgt.name.upper()}_OBJS = $(addprefix $(OBJDIR)/$(CONFIG)/, $(addsuffix .o, $(basename $(${tgt.name.upper()}_SRC))))
  % endif
  % if tgt.get('secure', 'check') == True or tgt.get('secure', 'check') == 'check':
  ifeq ($(NO_SECURE),true)

  # You can't build secure targets if you don't have OpenSSL.

  $(BINDIR)/$(CONFIG)/${tgt.name}: openssl_dep_error

  else

  % endif

  % if tgt.boringssl:
  # boringssl needs an override to ensure that it does not include
  # system openssl headers regardless of other configuration
  # we do so here with a target specific variable assignment
  $(${tgt.name.upper()}_OBJS): CFLAGS := -Ithird_party/boringssl/include $(CFLAGS) -Wno-sign-conversion -Wno-conversion -Wno-unused-value $(NO_W_EXTRA_SEMI)
  $(${tgt.name.upper()}_OBJS): CXXFLAGS := -Ithird_party/boringssl/include $(CXXFLAGS)
  $(${tgt.name.upper()}_OBJS): CPPFLAGS += -DOPENSSL_NO_ASM -D_GNU_SOURCE
  % else:
  % endif

  ##
  ## We're not trying to add a dependency on building zlib and openssl here,
  ## as it's already done in the libraries. We're assuming that the build
  ## trickles down, and that a secure target requires a secure version of
  ## a library.
  ##
  ## That simplifies the codegen a bit, but prevents a fully defined Makefile.
  ## I can live with that.
  ##
  % if tgt.build == 'protoc' or tgt.language == 'c++':

  ifeq ($(NO_PROTOBUF),true)

  # You can't build the protoc plugins or protobuf-enabled targets if you don't have protobuf 3.0.0+.

  $(BINDIR)/$(CONFIG)/${tgt.name}: protobuf_dep_error

  else

  $(BINDIR)/$(CONFIG)/${tgt.name}: \
  % if not has_no_sources:
  $(PROTOBUF_DEP) $(${tgt.name.upper()}_OBJS)\
  % endif
  % else:
  $(BINDIR)/$(CONFIG)/${tgt.name}: \
  % if not has_no_sources:
  $(${tgt.name.upper()}_OBJS)\
  % endif
  % endif
  % for dep in tgt.deps:
   $(LIBDIR)/$(CONFIG)/lib${dep}.a\
  % endfor

  % if tgt.language == "c++" or tgt.boringssl or tgt.build == 'fuzzer':
  ## C++ targets specificies.
  % if tgt.build == 'protoc':
  	$(E) "[HOSTLD]  Linking $@"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(HOST_LDXX) $(HOST_LDFLAGS) \
  % if not has_no_sources:
  $(${tgt.name.upper()}_OBJS)\
  % endif
  % else:
  	$(E) "[LD]      Linking $@"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(LDXX) $(LDFLAGS) \
  % if not has_no_sources:
  $(${tgt.name.upper()}_OBJS)\
  % endif
  % endif
  % else:
  ## C-only targets specificities.
  	$(E) "[LD]      Linking $@"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(LD) $(LDFLAGS) \
  % if not has_no_sources:
  $(${tgt.name.upper()}_OBJS)\
  % endif
  % endif
  % for dep in tgt.deps:
   $(LIBDIR)/$(CONFIG)/lib${dep}.a\
  % endfor
  % if tgt.language == "c++":
  % if tgt.build == 'protoc':
   $(HOST_LDLIBSXX) $(HOST_LDLIBS_PROTOC)\
  % else:
   $(LDLIBSXX) $(LDLIBS_PROTOBUF)\
  % endif
  % endif
  % if tgt.build == 'protoc':
   $(HOST_LDLIBS)\
  % else:
   $(LDLIBS)\
  % endif
  % if tgt.build == 'protoc':
   $(HOST_LDLIBS_PROTOC)\
  % elif tgt.get('secure', 'check') == True or tgt.get('secure', 'check') == 'check':
   $(LDLIBS_SECURE)\
  % endif
  % if tgt.language == 'c++' and tgt.build == 'test':
   $(GTEST_LIB)\
  % elif tgt.language == 'c++' and tgt.build == 'benchmark':
   $(GTEST_LIB)\
  % endif
  % if tgt.build == 'fuzzer':
   -lFuzzer\
  % endif
   -o $(BINDIR)/$(CONFIG)/${tgt.name}
  % if tgt.build == 'protoc' or tgt.language == 'c++':

  endif
  % endif
  % if tgt.get('secure', 'check') == True or tgt.get('secure', 'check') == 'check':

  endif
  % endif

  % if tgt.get('defaults', None):
  %  for name, value in defaults.get(tgt.defaults).iteritems():
  $(${tgt.name.upper()}_OBJS): ${name} += ${value}
  %  endfor
  % endif
  % for src in tgt.src:
  $(OBJDIR)/$(CONFIG)/${os.path.splitext(src)[0]}.o: \
  % for dep in tgt.deps:
   $(LIBDIR)/$(CONFIG)/lib${dep}.a\
  % endfor

  % if tgt.language == 'c89':
  % for src in tgt.src:
  $(OBJDIR)/$(CONFIG)/${os.path.splitext(src)[0]}.o : ${src}
  	$(E) "[C]       Compiling $<"
  	$(Q) mkdir -p `dirname $@`
  	$(Q) $(CC) $(CPPFLAGS) $(CFLAGS) -std=c89 -pedantic -MMD -MF $(addsuffix .dep, $(basename $@)) -c -o $@ $<
  % endfor
  % endif

  % endfor
  % if not has_no_sources:
  deps_${tgt.name}: $(${tgt.name.upper()}_OBJS:.o=.dep)
  % endif

  % if not has_no_sources:
  % if tgt.get('secure', 'check') == True or tgt.get('secure', 'check') == 'check':
  ifneq ($(NO_SECURE),true)
  % endif
  ifneq ($(NO_DEPS),true)
  -include $(${tgt.name.upper()}_OBJS:.o=.dep)
  endif
  % if tgt.get('secure', 'check') == True or tgt.get('secure', 'check') == 'check':
  endif
  % endif
  % endif
  % for src in tgt.src:
  % if not proto_re.match(src) and any(proto_re.match(src2) for src2 in tgt.src):
  $(OBJDIR)/$(CONFIG)/${os.path.splitext(src)[0]}.o: ${' '.join(proto_to_cc(src2) for src2 in tgt.src if proto_re.match(src2))}
  % endif
  % endfor
  </%def>

  ifneq ($(OPENSSL_DEP),)
  # This is to ensure the embedded OpenSSL is built beforehand, properly
  # installing headers to their final destination on the drive. We need this
  # otherwise parallel compilation will fail if a source is compiled first.
  % for src in sorted(sources_that_need_openssl):
  % if src not in sources_that_don_t_need_openssl:
  ${src}: $(OPENSSL_DEP)
  % endif
  % endfor
  endif

  .PHONY: all strip tools \
  dep_error openssl_dep_error openssl_dep_message git_update stop \
  buildtests buildtests_c buildtests_cxx \
  test test_c test_cxx \
  install install_c install_cxx \
  install-headers install-headers_c install-headers_cxx \
  install-shared install-shared_c install-shared_cxx \
  install-static install-static_c install-static_cxx \
  strip strip-shared strip-static \
  strip_c strip-shared_c strip-static_c \
  strip_cxx strip-shared_cxx strip-static_cxx \
  dep_c dep_cxx bins_dep_c bins_dep_cxx \
  clean

  .PHONY: printvars
  printvars:
  	@$(foreach V,$(sort $(.VARIABLES)),                 \
  	  $(if $(filter-out environment% default automatic, \
  	  $(origin $V)),$(warning $V=$($V) ($(value $V)))))
