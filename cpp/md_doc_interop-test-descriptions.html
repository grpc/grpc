<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GRPC C++: Interoperability Test Case Descriptions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GRPC C++
   &#160;<span id="projectnumber">1.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Interoperability Test Case Descriptions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Client and server use <a href="../src/proto/grpc/testing/test.proto">test.proto</a> and the ./PROTOCOL-HTTP2.md "gRPC over HTTP/2 v2 protocol".</p>
<h2>Client </h2>
<p>Clients implement test cases that test certain functionally. Each client is provided the test case it is expected to run as a command-line parameter. Names should be lowercase and without spaces.</p>
<p>Clients should accept these arguments:</p>
<ul>
<li>&ndash;server_host=HOSTNAME<ul>
<li>The server host to connect to. For example, "localhost" or "127.0.0.1"</li>
</ul>
</li>
<li>&ndash;server_host_override=HOSTNAME<ul>
<li>The server host to claim to be connecting to, for use in TLS and HTTP/2 :authority header. If unspecified, the value of &ndash;server_host will be used</li>
</ul>
</li>
<li>&ndash;server_port=PORT<ul>
<li>The server port to connect to. For example, "8080"</li>
</ul>
</li>
<li>&ndash;test_case=TESTCASE<ul>
<li>The name of the test case to execute. For example, "empty_unary"</li>
</ul>
</li>
<li>&ndash;use_tls=BOOLEAN<ul>
<li>Whether to use a plaintext or encrypted connection</li>
</ul>
</li>
<li>&ndash;use_test_ca=BOOLEAN<ul>
<li>Whether to replace platform root CAs with <a href="https://github.com/grpc/grpc/blob/master/src/core/tsi/test_creds/ca.pem">ca.pem</a> as the CA root</li>
</ul>
</li>
<li>&ndash;default_service_account=ACCOUNT_EMAIL<ul>
<li>Email of the GCE default service account.</li>
</ul>
</li>
<li>&ndash;oauth_scope=SCOPE<ul>
<li>OAuth scope. For example, "https://www.googleapis.com/auth/xapi.zoo"</li>
</ul>
</li>
<li>&ndash;service_account_key_file=PATH<ul>
<li>The path to the service account JSON key file generated from GCE developer console.</li>
</ul>
</li>
</ul>
<p>Clients must support TLS with ALPN. Clients must not disable certificate checking.</p>
<h3>empty_unary</h3>
<p>This test verifies that implementations support zero-size messages. Ideally, client implementations would verify that the request and response were zero bytes serialized, but this is generally prohibitive to perform, so is not required.</p>
<p>Server features:</p>
<ul>
<li><a href="#emptycall">EmptyCall</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li>Client calls EmptyCall with the default Empty message</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>response is non-null</li>
</ul>
<p><em>It may be possible to use UnaryCall instead of EmptyCall, but it is harder to ensure that the proto serialized to zero bytes.</em></p>
<h3>cacheable_unary</h3>
<p>This test verifies that gRPC requests marked as cacheable use GET verb instead of POST, and that server sets appropriate cache control headers for the response to be cached by a proxy. This test requires that the server is behind a caching proxy. Use of current timestamp in the request prevents accidental cache matches left over from previous tests.</p>
<p>Server features:</p>
<ul>
<li><a href="#cacheableunarycall">CacheableUnaryCall</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li>Client calls CacheableUnaryCall with <code>SimpleRequest</code> request with payload set to current timestamp. Timestamp format is irrelevant, and resolution is in nanoseconds. Client adds a <code>x-user-ip</code> header with value <code>1.2.3.4</code> to the request. This is done since some proxys such as GFE will not cache requests from localhost. Client marks the request as cacheable by setting the cacheable flag in the request context. Longer term this should be driven by the method option specified in the proto file itself.</li>
<li>Client calls CacheableUnaryCall again immediately with the same request and configuration as the previous call.</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>Both calls were successful</li>
<li>The payload body of both responses is the same.</li>
</ul>
<h3>large_unary</h3>
<p>This test verifies unary calls succeed in sending messages, and touches on flow control (even if compression is enabled on the channel).</p>
<p>Server features:</p>
<ul>
<li><a href="#unarycall">UnaryCall</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li><p class="startli">Client calls UnaryCall with:</p>
<p class="startli">``` { response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</p>
</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>response payload body is 314159 bytes in size</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response message against a golden response</li>
</ul>
<h3>client_compressed_unary</h3>
<p>This test verifies the client can compress unary messages by sending two unary calls, for compressed and uncompressed payloads. It also sends an initial probing request to verify whether the server supports the <a href="#compressedrequest">CompressedRequest</a> feature by checking if the probing call fails with an <code>INVALID_ARGUMENT</code> status.</p>
<p>Server features:</p>
<ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#compressedrequest">CompressedRequest</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li>Client calls UnaryCall with the feature probe, an <em>uncompressed</em> message: ``` { expect_compressed:{ value: true } response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</li>
</ol>
<ol type="1">
<li><p class="startli">Client calls UnaryCall with the <em>compressed</em> message:</p>
<p class="startli">``` { expect_compressed:{ value: true } response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</p>
</li>
</ol>
<ol type="1">
<li><p class="startli">Client calls UnaryCall with the <em>uncompressed</em> message:</p>
<p class="startli">``` { expect_compressed:{ value: false } response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</p>
<p class="startli">Client asserts:</p>
<ul>
<li>First call failed with <code>INVALID_ARGUMENT</code> status.</li>
<li>Subsequent calls were successful.</li>
<li>Response payload body is 314159 bytes in size.</li>
<li>Clients are free to assert that the response payload body contents are zeros and comparing the entire response message against a golden response.</li>
</ul>
</li>
</ol>
<h3>server_compressed_unary</h3>
<p>This test verifies the server can compress unary messages. It sends two unary requests, expecting the server's response to be compressed or not according to the <code>response_compressed</code> boolean.</p>
<p>Whether compression was actually performed is determined by the compression bit in the response's message flags. <em>Note that some languages may not have access to the message flags, in which case the client will be unable to verify that the <code>response_compressed</code> boolean is obeyed by the server</em>.</p>
<p>Server features:</p>
<ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#compressedresponse">CompressedResponse</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li><p class="startli">Client calls UnaryCall with <code>SimpleRequest</code>:</p>
<p class="startli">``` { response_compressed:{ value: true } response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</p>
<p class="startli">``` { response_compressed:{ value: false } response_size: 314159 payload:{ body: 271828 bytes of zeros } } ``` Client asserts:</p>
<ul>
<li>call was successful</li>
<li>if supported by the implementation, when <code>response_compressed</code> is true, the response MUST have the compressed message flag set.</li>
<li>if supported by the implementation, when <code>response_compressed</code> is false, the response MUST NOT have the compressed message flag set.</li>
<li>response payload body is 314159 bytes in size in both cases.</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response message against a golden response</li>
</ul>
</li>
</ol>
<h3>client_streaming</h3>
<p>This test verifies that client-only streaming succeeds.</p>
<p>Server features:</p>
<ul>
<li><a href="#streaminginputcall">StreamingInputCall</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li>Client calls StreamingInputCall</li>
<li><p class="startli">Client sends:</p>
<p class="startli">``` { payload:{ body: 27182 bytes of zeros } } ```</p>
</li>
<li><p class="startli">Client then sends:</p>
<p class="startli">``` { payload:{ body: 8 bytes of zeros } } ```</p>
</li>
<li><p class="startli">Client then sends:</p>
<p class="startli">``` { payload:{ body: 1828 bytes of zeros } } ```</p>
</li>
<li><p class="startli">Client then sends:</p>
<p class="startli">``` { payload:{ body: 45904 bytes of zeros } } ```</p>
</li>
<li>Client half-closes</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>response aggregated_payload_size is 74922</li>
</ul>
<h3>client_compressed_streaming</h3>
<p>This test verifies the client can compress requests on per-message basis by performing a two-request streaming call. It also sends an initial probing request to verify whether the server supports the <a href="#compressedrequest">CompressedRequest</a> feature by checking if the probing call fails with an <code>INVALID_ARGUMENT</code> status.</p>
<p>Procedure:</p>
<ol type="1">
<li><p class="startli">Client calls <code>StreamingInputCall</code> and sends the following feature-probing <em>uncompressed</em> <code>StreamingInputCallRequest</code> message</p>
<p class="startli">``` { expect_compressed:{ value: true } payload:{ body: 27182 bytes of zeros } } ``<code> If the call does not fail with</code>INVALID_ARGUMENT`, the test fails. Otherwise, we continue.</p>
</li>
</ol>
<ol type="1">
<li><p class="startli">Client calls <code>StreamingInputCall</code> again, sending the <em>compressed</em> message</p>
<p class="startli">``` { expect_compressed:{ value: true } payload:{ body: 27182 bytes of zeros } } ```</p>
</li>
</ol>
<ol type="1">
<li>And finally, the <em>uncompressed</em> message ``` { expect_compressed:{ value: false } payload:{ body: 45904 bytes of zeros } } ```</li>
</ol>
<ol type="1">
<li>Client half-closes</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>First call fails with <code>INVALID_ARGUMENT</code>.</li>
<li>Next calls succeeds.</li>
<li>Response aggregated payload size is 73086.</li>
</ul>
<h3>server_streaming</h3>
<p>This test verifies that server-only streaming succeeds.</p>
<p>Server features:</p>
<ul>
<li><a href="#streamingoutputcall">StreamingOutputCall</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li><p class="startli">Client calls StreamingOutputCall with <code>StreamingOutputCallRequest</code>:</p>
<p class="startli">``` { response_parameters:{ size: 31415 } response_parameters:{ size: 9 } response_parameters:{ size: 2653 } response_parameters:{ size: 58979 } } ```</p>
</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>exactly four responses</li>
<li>response payload bodies are sized (in order): 31415, 9, 2653, 58979</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response messages against golden responses</li>
</ul>
<h3>server_compressed_streaming</h3>
<p>This test verifies that the server can compress streaming messages and disable compression on individual messages, expecting the server's response to be compressed or not according to the <code>response_compressed</code> boolean.</p>
<p>Whether compression was actually performed is determined by the compression bit in the response's message flags. <em>Note that some languages may not have access to the message flags, in which case the client will be unable to verify that the <code>response_compressed</code> boolean is obeyed by the server</em>.</p>
<p>Server features:</p>
<ul>
<li><a href="#streamingoutputcall">StreamingOutputCall</a></li>
<li><a href="#compressedresponse">CompressedResponse</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li><p class="startli">Client calls StreamingOutputCall with <code>StreamingOutputCallRequest</code>:</p>
<p class="startli">``` { response_parameters:{ compressed: { value: true } size: 31415 } response_parameters:{ compressed: { value: false } size: 92653 } } ```</p>
<p class="startli">Client asserts:</p>
<ul>
<li>call was successful</li>
<li>exactly two responses</li>
<li>if supported by the implementation, when <code>response_compressed</code> is false, the response's messages MUST NOT have the compressed message flag set.</li>
<li>if supported by the implementation, when <code>response_compressed</code> is true, the response's messages MUST have the compressed message flag set.</li>
<li>response payload bodies are sized (in order): 31415, 92653</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response messages against golden responses</li>
</ul>
</li>
</ol>
<h3>ping_pong</h3>
<p>This test verifies that full duplex bidi is supported.</p>
<p>Server features:</p>
<ul>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li><p class="startli">Client calls FullDuplexCall with:</p>
<p class="startli">``` { response_parameters:{ size: 31415 } payload:{ body: 27182 bytes of zeros } } ```</p>
</li>
<li><p class="startli">After getting a reply, it sends:</p>
<p class="startli">``` { response_parameters:{ size: 9 } payload:{ body: 8 bytes of zeros } } ```</p>
</li>
<li><p class="startli">After getting a reply, it sends:</p>
<p class="startli">``` { response_parameters:{ size: 2653 } payload:{ body: 1828 bytes of zeros } } ```</p>
</li>
<li><p class="startli">After getting a reply, it sends:</p>
<p class="startli">``` { response_parameters:{ size: 58979 } payload:{ body: 45904 bytes of zeros } } ```</p>
</li>
<li>After getting a reply, client half-closes</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>exactly four responses</li>
<li>response payload bodies are sized (in order): 31415, 9, 2653, 58979</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response messages against golden responses</li>
</ul>
<h3>empty_stream</h3>
<p>This test verifies that streams support having zero-messages in both directions.</p>
<p>Server features:</p>
<ul>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li>Client calls FullDuplexCall and then half-closes</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>exactly zero responses</li>
</ul>
<h3>compute_engine_creds</h3>
<p>This test is only for cloud-to-prod path.</p>
<p>This test verifies unary calls succeed in sending messages while using Service Credentials from GCE metadata server. The client instance needs to be created with desired oauth scope.</p>
<p>The test uses <code>--default_service_account</code> with GCE service account email and <code>--oauth_scope</code> with the OAuth scope to use. For testing against grpc-test.sandbox.googleapis.com, "https://www.googleapis.com/auth/xapi.zoo" should be passed in as <code>--oauth_scope</code>.</p>
<p>Server features:</p>
<ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-authenticated-username">Echo Authenticated Username</a></li>
<li><a href="#echo-oauth-scope">Echo OAuth Scope</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li>Client configures channel to use GCECredentials</li>
<li><p class="startli">Client calls UnaryCall on the channel with:</p>
<p class="startli">``` { response_size: 314159 payload:{ body: 271828 bytes of zeros } fill_username: true fill_oauth_scope: true } ```</p>
</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>received SimpleResponse.username equals the value of <code>--default_service_account</code> flag</li>
<li>received SimpleResponse.oauth_scope is in <code>--oauth_scope</code></li>
<li>response payload body is 314159 bytes in size</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response message against a golden response</li>
</ul>
<h3>jwt_token_creds</h3>
<p>This test is only for cloud-to-prod path.</p>
<p>This test verifies unary calls succeed in sending messages while using JWT token (created by the project's key file)</p>
<p>Test caller should set flag <code>--service_account_key_file</code> with the path to json key file downloaded from <a href="https://console.developers.google.com">https://console.developers.google.com</a>. Alternately, if using a usable auth implementation, she may specify the file location in the environment variable GOOGLE_APPLICATION_CREDENTIALS.</p>
<p>Server features:</p>
<ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-authenticated-username">Echo Authenticated Username</a></li>
<li><a href="#echo-oauth-scope">Echo OAuth Scope</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li>Client configures the channel to use JWTTokenCredentials</li>
<li><p class="startli">Client calls UnaryCall with:</p>
<p class="startli">``` { response_size: 314159 payload:{ body: 271828 bytes of zeros } fill_username: true } ```</p>
</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>received SimpleResponse.username is not empty and is in the json key file used by the auth library. The client can optionally check the username matches the email address in the key file or equals the value of <code>--default_service_account</code> flag.</li>
<li>response payload body is 314159 bytes in size</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response message against a golden response</li>
</ul>
<h3>oauth2_auth_token</h3>
<p>This test is only for cloud-to-prod path and some implementations may run in GCE only.</p>
<p>This test verifies unary calls succeed in sending messages using an OAuth2 token that is obtained out of band. For the purpose of the test, the OAuth2 token is actually obtained from a service account credentials or GCE credentials via the language-specific authorization library.</p>
<p>The difference between this test and the other auth tests is that it first uses the authorization library to obtain an authorization token.</p>
<p>The test</p>
<ul>
<li>uses the flag <code>--service_account_key_file</code> with the path to a json key file downloaded from <a href="https://console.developers.google.com">https://console.developers.google.com</a>. Alternately, if using a usable auth implementation, it may specify the file location in the environment variable GOOGLE_APPLICATION_CREDENTIALS, <em>OR</em> if GCE credentials is used to fetch the token, <code>--default_service_account</code> can be used to pass in GCE service account email.</li>
<li>uses the flag <code>--oauth_scope</code> for the oauth scope. For testing against grpc-test.sandbox.googleapis.com, "https://www.googleapis.com/auth/xapi.zoo" should be passed as the <code>--oauth_scope</code>.</li>
</ul>
<p>Server features:</p>
<ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-authenticated-username">Echo Authenticated Username</a></li>
<li><a href="#echo-oauth-scope">Echo OAuth Scope</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li>Client uses the auth library to obtain an authorization token</li>
<li>Client configures the channel to use AccessTokenCredentials with the access token obtained in step 1</li>
<li><p class="startli">Client calls UnaryCall with the following message</p>
<p class="startli">``` { fill_username: true fill_oauth_scope: true } ```</p>
</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>received SimpleResponse.username is valid. Depending on whether a service account key file or GCE credentials was used, client should check against the json key file or GCE default service account email.</li>
<li>received SimpleResponse.oauth_scope is in <code>--oauth_scope</code></li>
</ul>
<h3>per_rpc_creds</h3>
<p>Similar to the other auth tests, this test is only for cloud-to-prod path.</p>
<p>This test verifies unary calls succeed in sending messages using a JWT or a service account credentials set on the RPC.</p>
<p>The test</p>
<ul>
<li>uses the flag <code>--service_account_key_file</code> with the path to a json key file downloaded from <a href="https://console.developers.google.com">https://console.developers.google.com</a>. Alternately, if using a usable auth implementation, it may specify the file location in the environment variable GOOGLE_APPLICATION_CREDENTIALS</li>
<li>optionally uses the flag <code>--oauth_scope</code> for the oauth scope if implementator wishes to use service account credential instead of JWT credential. For testing against grpc-test.sandbox.googleapis.com, oauth scope "https://www.googleapis.com/auth/xapi.zoo" should be used.</li>
</ul>
<p>Server features:</p>
<ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-authenticated-username">Echo Authenticated Username</a></li>
<li><a href="#echo-oauth-scope">Echo OAuth Scope</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li>Client configures the channel with just SSL credentials</li>
<li><p class="startli">Client calls UnaryCall, setting per-call credentials to JWTTokenCredentials. The request is the following message</p>
<p class="startli">``` { fill_username: true } ```</p>
</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>received SimpleResponse.username is not empty and is in the json key file used by the auth library. The client can optionally check the username matches the email address in the key file.</li>
</ul>
<h3>custom_metadata</h3>
<p>This test verifies that custom metadata in either binary or ascii format can be sent as initial-metadata by the client and as both initial- and trailing-metadata by the server.</p>
<p>Server features:</p>
<ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
<li><a href="#echo-metadata">Echo Metadata</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li><p class="startli">The client attaches custom metadata with the following keys and values:</p>
<p class="startli">``` key: "x-grpc-test-echo-initial", value: "test_initial_metadata_value" key: "x-grpc-test-echo-trailing-bin", value: 0xababab ```</p>
<p class="startli">to a UnaryCall with request:</p>
<p class="startli">``` { response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</p>
</li>
<li><p class="startli">The client attaches custom metadata with the following keys and values:</p>
<p class="startli">``` key: "x-grpc-test-echo-initial", value: "test_initial_metadata_value" key: "x-grpc-test-echo-trailing-bin", value: 0xababab ```</p>
<p class="startli">to a FullDuplexCall with request:</p>
<p class="startli">``` { response_parameters:{ size: 314159 } payload:{ body: 271828 bytes of zeros } } ```</p>
<p class="startli">and then half-closes</p>
</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>call was successful</li>
<li>metadata with key <code>"x-grpc-test-echo-initial"</code> and value <code>"test_initial_metadata_value"</code>is received in the initial metadata for calls in Procedure steps 1 and 2.</li>
<li>metadata with key <code>"x-grpc-test-echo-trailing-bin"</code> and value <code>0xababab</code> is received in the trailing metadata for calls in Procedure steps 1 and 2.</li>
</ul>
<h3>status_code_and_message</h3>
<p>This test verifies unary calls succeed in sending messages, and propagate back status code and message sent along with the messages.</p>
<p>Server features:</p>
<ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
<li><a href="#echo-status">Echo Status</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li><p class="startli">Client calls UnaryCall with:</p>
<p class="startli">``` { response_status:{ code: 2 message: "test status message" } } ```</p>
</li>
<li><p class="startli">Client calls FullDuplexCall with:</p>
<p class="startli">``` { response_status:{ code: 2 message: "test status message" } } ```</p>
<p class="startli">and then half-closes</p>
</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>received status code is the same as the sent code for both Procedure steps 1 and 2</li>
<li>received status message is the same as the sent message for both Procedure steps 1 and 2</li>
</ul>
<h3>unimplemented_method</h3>
<p>This test verifies that calling an unimplemented RPC method returns the UNIMPLEMENTED status code.</p>
<p>Server features: N/A</p>
<p>Procedure:</p>
<ul>
<li><p class="startli">Client calls <code>grpc.testing.TestService/UnimplementedCall</code> with an empty request (defined as <code>grpc.testing.Empty</code>):</p>
<p class="startli">``` { } ```</p>
</li>
</ul>
<p>Client asserts:</p>
<ul>
<li>received status code is 12 (UNIMPLEMENTED)</li>
</ul>
<h3>unimplemented_service</h3>
<p>This test verifies calling an unimplemented server returns the UNIMPLEMENTED status code.</p>
<p>Server features: N/A</p>
<p>Procedure:</p>
<ul>
<li>Client calls <code>grpc.testing.UnimplementedService/UnimplementedCall</code> with an empty request (defined as <code>grpc.testing.Empty</code>)</li>
</ul>
<p>Client asserts:</p>
<ul>
<li>received status code is 12 (UNIMPLEMENTED)</li>
</ul>
<h3>cancel_after_begin</h3>
<p>This test verifies that a request can be cancelled after metadata has been sent but before payloads are sent.</p>
<p>Server features:</p>
<ul>
<li><a href="#streaminginputcall">StreamingInputCall</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li>Client starts StreamingInputCall</li>
<li>Client immediately cancels request</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>Call completed with status CANCELLED</li>
</ul>
<h3>cancel_after_first_response</h3>
<p>This test verifies that a request can be cancelled after receiving a message from the server.</p>
<p>Server features:</p>
<ul>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li><p class="startli">Client starts FullDuplexCall with</p>
<p class="startli">``` { response_parameters:{ size: 31415 } payload:{ body: 27182 bytes of zeros } } ```</p>
</li>
<li>After receiving a response, client cancels request</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>Call completed with status CANCELLED</li>
</ul>
<h3>timeout_on_sleeping_server</h3>
<p>This test verifies that an RPC request whose lifetime exceeds its configured timeout value will end with the DeadlineExceeded status.</p>
<p>Server features:</p>
<ul>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
</ul>
<p>Procedure:</p>
<ol type="1">
<li><p class="startli">Client calls FullDuplexCall with the following request and sets its timeout to 1ms</p>
<p class="startli">``` { payload:{ body: 27182 bytes of zeros } } ```</p>
</li>
<li>Client waits</li>
</ol>
<p>Client asserts:</p>
<ul>
<li>Call completed with status DEADLINE_EXCEEDED.</li>
</ul>
<h3>concurrent_large_unary</h3>
<p>Status: TODO</p>
<p>Client performs 1000 large_unary tests in parallel on the same channel.</p>
<h3>Flow control. Pushback at client for large messages (TODO: fix name)</h3>
<p>Status: TODO</p>
<p>This test verifies that a client sending faster than a server can drain sees pushback (i.e., attempts to send succeed only after appropriate delays).</p>
<h3>TODO Tests</h3>
<h4>High priority:</h4>
<p>Propagation of status code and message (yangg)</p>
<p>Multiple thousand simultaneous calls on same Channel (ctiller)</p>
<p>Metadata: client headers, server headers + trailers, binary+ascii</p>
<h4>Normal priority:</h4>
<p>Cancel before start (ctiller)</p>
<p>Cancel after sent first message (ctiller)</p>
<p>Cancel after received headers (ctiller)</p>
<p>Timeout but completed before expire (zhaoq)</p>
<p>Multiple thousand simultaneous calls timeout on same Channel (ctiller)</p>
<h4>Lower priority:</h4>
<p>Flow control. Pushback at client for large messages (abhishek)</p>
<p>Flow control. Pushback at server for large messages (abhishek)</p>
<p>Going over max concurrent streams doesn't fail (client controls itself) (abhishek)</p>
<p>RPC method not implemented (yangg)</p>
<p>Multiple thousand simultaneous calls on different Channels (ctiller)</p>
<p>Failed TLS hostname verification (ejona?)</p>
<p>Large amount of headers to cause CONTINUATIONs; 63K of 'X's, all in one header.</p>
<h4>To priorize:</h4>
<p>Start streaming RPC but don't send any requests, server responds</p>
<h3>Postponed Tests</h3>
<p>Resilience to buggy servers: These tests would verify that a client application isn't affected negatively by the responses put on the wire by a buggy server (e.g. the client library won't make the application crash).</p>
<p>Reconnect after transport failure</p>
<p>Reconnect backoff</p>
<p>Fuzz testing</p>
<h2>Server </h2>
<p>Servers implement various named features for clients to test with. Server features are orthogonal. If a server implements a feature, it is always available for clients. Names are simple descriptions for developer communication and tracking.</p>
<p>Servers should accept these arguments:</p>
<ul>
<li>&ndash;port=PORT<ul>
<li>The port to listen on. For example, "8080"</li>
</ul>
</li>
<li>&ndash;use_tls=BOOLEAN<ul>
<li>Whether to use a plaintext or encrypted connection</li>
</ul>
</li>
</ul>
<p>Servers must support TLS with ALPN. They should use <a href="https://github.com/grpc/grpc/blob/master/src/core/tsi/test_creds/server1.pem">server1.pem</a> for their certificate.</p>
<h3>EmptyCall</h3>
<p>Server implements EmptyCall which immediately returns the empty message.</p>
<h3>UnaryCall</h3>
<p>Server implements UnaryCall which immediately returns a SimpleResponse with a payload body of size <code>SimpleRequest.response_size</code> bytes and type as appropriate for the <code>SimpleRequest.response_type</code>. If the server does not support the <code>response_type</code>, then it should fail the RPC with <code>INVALID_ARGUMENT</code>.</p>
<h3>CacheableUnaryCall</h3>
<p>Server gets the default SimpleRequest proto as the request. The content of the request is ignored. It returns the SimpleResponse proto with the payload set to current timestamp. The timestamp is an integer representing current time with nanosecond resolution. This integer is formated as ASCII decimal in the response. The format is not really important as long as the response payload is different for each request. In addition it adds</p>
<ol type="1">
<li>cache control headers such that the response can be cached by proxies in the response path. Server should be behind a caching proxy for this test to pass. Currently we set the max-age to 60 seconds.</li>
</ol>
<h3>CompressedResponse</h3>
<p>When the client sets <code>response_compressed</code> to true, the server's response is sent back compressed. Note that <code>response_compressed</code> is present on both <code>SimpleRequest</code> (unary) and <code>StreamingOutputCallRequest</code> (streaming).</p>
<h3>CompressedRequest</h3>
<p>When the client sets <code>expect_compressed</code> to true, the server expects the client request to be compressed. If it's not, it fails the RPC with <code>INVALID_ARGUMENT</code>. Note that <code>response_compressed</code> is present on both <code>SimpleRequest</code> (unary) and <code>StreamingOutputCallRequest</code> (streaming).</p>
<h3>StreamingInputCall</h3>
<p>Server implements StreamingInputCall which upon half close immediately returns a StreamingInputCallResponse where aggregated_payload_size is the sum of all request payload bodies received.</p>
<h3>StreamingOutputCall</h3>
<p>Server implements StreamingOutputCall by replying, in order, with one StreamingOutputCallResponse for each ResponseParameters in StreamingOutputCallRequest. Each StreamingOutputCallResponse should have a payload body of size ResponseParameters.size bytes, as specified by its respective ResponseParameters. After sending all responses, it closes with OK.</p>
<h3>FullDuplexCall</h3>
<p>Server implements FullDuplexCall by replying, in order, with one StreamingOutputCallResponse for each ResponseParameters in each StreamingOutputCallRequest. Each StreamingOutputCallResponse should have a payload body of size ResponseParameters.size bytes, as specified by its respective ResponseParameters. After receiving half close and sending all responses, it closes with OK.</p>
<h3>Echo Status</h3>
<p>When the client sends a response_status in the request payload, the server closes the stream with the status code and messsage contained within said response_status. The server will not process any further messages on the stream sent by the client. This can be used by clients to verify correct handling of different status codes and associated status messages end-to-end.</p>
<h3>Echo Metadata</h3>
<p>When the client sends metadata with the key <code>"x-grpc-test-echo-initial"</code> with its request, the server sends back exactly this key and the corresponding value back to the client as part of initial metadata. When the client sends metadata with the key <code>"x-grpc-test-echo-trailing-bin"</code> with its request, the server sends back exactly this key and the corresponding value back to the client as trailing metadata.</p>
<h3>Observe ResponseParameters.interval_us</h3>
<p>In StreamingOutputCall and FullDuplexCall, server delays sending a StreamingOutputCallResponse by the ResponseParameters's <code>interval_us</code> for that particular response, relative to the last response sent. That is, <code>interval_us</code> acts like a sleep <em>before</em> sending the response and accumulates from one response to the next.</p>
<p>Interaction with flow control is unspecified.</p>
<h3>Echo Auth Information</h3>
<p>Status: Pending</p>
<h4>Echo Authenticated Username</h4>
<p>If a SimpleRequest has fill_username=true and that request was successfully authenticated, then the SimpleResponse should have username filled with the canonical form of the authenticated source. The canonical form is dependent on the authentication method, but is likely to be a base 10 integer identifier or an email address.</p>
<h4>Echo OAuth scope</h4>
<p>If a SimpleRequest has <code>fill_oauth_scope=true</code> and that request was successfully authenticated via OAuth, then the SimpleResponse should have oauth_scope filled with the scope of the method being invoked.</p>
<p>Although a general server-side feature, most test servers won't implement this feature. The TLS server <code>grpc-test.sandbox.googleapis.com:443</code> supports this feature. It requires at least the OAuth scope <code><a href="https://www.googleapis.com/auth/xapi.zoo">https://www.googleapis.com/auth/xapi.zoo</a></code> for authentication to succeed.</p>
<p>Discussion:</p>
<p>Ideally, this would be communicated via metadata and not in the request/response, but we want to use this test in code paths that don't yet fully communicate metadata. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 8 2017 09:46:06 for GRPC C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
