<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC C++: grpc_event_engine::experimental::EventEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC C++
   &#160;<span id="projectnumber">1.46.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegrpc__event__engine.html">grpc_event_engine</a></li><li class="navelem"><a class="el" href="namespacegrpc__event__engine_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html">EventEngine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">grpc_event_engine::experimental::EventEngine Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> encapsulates all platform-specific behaviors related to low level network I/O, timers, asynchronous execution, and DNS resolution.  
 <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="event__engine_8h_source.html">event_engine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html">Closure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom closure type for <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> task execution.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html">ConnectionHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a cancellable connection attempt.  <a href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides asynchronous resolution.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One end of a connection between a gRPC client and server.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listens for incoming connection requests from gRPC clients and initiates request processing once connections are established.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin wrapper around a platform-specific sockaddr type.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a scheduled task.  <a href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad38e4bd2a5559809d16246442460af3d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">OnConnectCallback</a> = std::function&lt; void(absl::StatusOr&lt; std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a> &gt; &gt;)&gt;</td></tr>
<tr class="memdesc:ad38e4bd2a5559809d16246442460af3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new connection is established.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">More...</a><br /></td></tr>
<tr class="separator:ad38e4bd2a5559809d16246442460af3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a57fe4d3cb961ef56f9f872e18a64f840"><td class="memItemLeft" align="right" valign="top">virtual absl::StatusOr&lt; std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a57fe4d3cb961ef56f9f872e18a64f840">CreateListener</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#a4ab93dee16f17ef34fe4ff0f0b95a1ab">Listener::AcceptCallback</a> on_accept, std::function&lt; void(absl::Status)&gt; on_shutdown, const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;config, std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator_factory.html">MemoryAllocatorFactory</a> &gt; memory_allocator_factory)=0</td></tr>
<tr class="memdesc:a57fe4d3cb961ef56f9f872e18a64f840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a network listener / server.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a57fe4d3cb961ef56f9f872e18a64f840">More...</a><br /></td></tr>
<tr class="separator:a57fe4d3cb961ef56f9f872e18a64f840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6d2fe70d8fd254ec4099f6c60b291f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html">ConnectionHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a9f6d2fe70d8fd254ec4099f6c60b291f">Connect</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">OnConnectCallback</a> on_connect, const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a> &amp;addr, const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;args, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator.html">MemoryAllocator</a> memory_allocator, absl::Time deadline)=0</td></tr>
<tr class="memdesc:a9f6d2fe70d8fd254ec4099f6c60b291f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a client network connection to a remote network listener.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a9f6d2fe70d8fd254ec4099f6c60b291f">More...</a><br /></td></tr>
<tr class="separator:a9f6d2fe70d8fd254ec4099f6c60b291f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad116ce06ec29f65ce4083b226d2d90c8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad116ce06ec29f65ce4083b226d2d90c8">CancelConnect</a> (<a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html">ConnectionHandle</a> handle)=0</td></tr>
<tr class="memdesc:ad116ce06ec29f65ce4083b226d2d90c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request cancellation of a connection attempt.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad116ce06ec29f65ce4083b226d2d90c8">More...</a><br /></td></tr>
<tr class="separator:ad116ce06ec29f65ce4083b226d2d90c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283885518525b71339f166e15932cd1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aa283885518525b71339f166e15932cd1">~EventEngine</a> ()=default</td></tr>
<tr class="memdesc:aa283885518525b71339f166e15932cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">At time of destruction, the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> must have no active responsibilities.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aa283885518525b71339f166e15932cd1">More...</a><br /></td></tr>
<tr class="separator:aa283885518525b71339f166e15932cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9dbb26c374daf51b6460da89a7d586"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#afb9dbb26c374daf51b6460da89a7d586">IsWorkerThread</a> ()=0</td></tr>
<tr class="separator:afb9dbb26c374daf51b6460da89a7d586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955326b931bda68cecff3f75605c0689"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a955326b931bda68cecff3f75605c0689">GetDNSResolver</a> ()=0</td></tr>
<tr class="memdesc:a955326b931bda68cecff3f75605c0689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns an instance of a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html" title="Provides asynchronous resolution.">DNSResolver</a>.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a955326b931bda68cecff3f75605c0689">More...</a><br /></td></tr>
<tr class="separator:a955326b931bda68cecff3f75605c0689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589e091e9af842bcda00411996d9255f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a589e091e9af842bcda00411996d9255f">Run</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html">Closure</a> *closure)=0</td></tr>
<tr class="memdesc:a589e091e9af842bcda00411996d9255f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously executes a task as soon as possible.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a589e091e9af842bcda00411996d9255f">More...</a><br /></td></tr>
<tr class="separator:a589e091e9af842bcda00411996d9255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5539922dc4f6599e38adb0891f44986"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#af5539922dc4f6599e38adb0891f44986">Run</a> (std::function&lt; void()&gt; closure)=0</td></tr>
<tr class="memdesc:af5539922dc4f6599e38adb0891f44986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously executes a task as soon as possible.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#af5539922dc4f6599e38adb0891f44986">More...</a><br /></td></tr>
<tr class="separator:af5539922dc4f6599e38adb0891f44986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254481ef518e7aba0e07bbb4c3d3e18c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a254481ef518e7aba0e07bbb4c3d3e18c">RunAt</a> (absl::Time when, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html">Closure</a> *closure)=0</td></tr>
<tr class="memdesc:a254481ef518e7aba0e07bbb4c3d3e18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonymous with scheduling an alarm to run at time <em>when</em>.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a254481ef518e7aba0e07bbb4c3d3e18c">More...</a><br /></td></tr>
<tr class="separator:a254481ef518e7aba0e07bbb4c3d3e18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c5e59baf71097104f5867f3b0b6d2e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a61c5e59baf71097104f5867f3b0b6d2e">RunAt</a> (absl::Time when, std::function&lt; void()&gt; closure)=0</td></tr>
<tr class="memdesc:a61c5e59baf71097104f5867f3b0b6d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonymous with scheduling an alarm to run at time <em>when</em>.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a61c5e59baf71097104f5867f3b0b6d2e">More...</a><br /></td></tr>
<tr class="separator:a61c5e59baf71097104f5867f3b0b6d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8a579f7dc8429c8d2aa2cd81da910b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aab8a579f7dc8429c8d2aa2cd81da910b">Cancel</a> (<a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> handle)=0</td></tr>
<tr class="memdesc:aab8a579f7dc8429c8d2aa2cd81da910b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request cancellation of a task.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aab8a579f7dc8429c8d2aa2cd81da910b">More...</a><br /></td></tr>
<tr class="separator:aab8a579f7dc8429c8d2aa2cd81da910b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> encapsulates all platform-specific behaviors related to low level network I/O, timers, asynchronous execution, and DNS resolution. </p>
<p>This interface allows developers to provide their own event management and network stacks. Motivating uses cases for supporting custom EventEngines include the ability to hook into external event loops, and using different <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> instances for each channel to better insulate network I/O and callback processing from other channels.</p>
<p>A default cross-platform <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> instance is provided by gRPC.</p>
<p>LIFESPAN AND OWNERSHIP</p>
<p>gRPC takes shared ownership of EventEngines via std::shared_ptrs to ensure that the engines remain available until they are no longer needed. Depending on the use case, engines may live until gRPC is shut down.</p>
<p>EXAMPLE USAGE (Not yet implemented)</p>
<p>Custom EventEngines can be specified per channel, and allow configuration for both clients and servers. To set a custom <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> for a client channel, you can do something like the following:</p>
<p>ChannelArguments args; std::shared_ptr&lt;EventEngine&gt; engine = std::make_shared&lt;MyEngine&gt;(...); args.SetEventEngine(engine); MyAppClient client(<a class="el" href="namespacegrpc.html#a4a5c8a2c77389604feaa5d38cdd7b8d3" title="Create a new custom Channel pointing to target.">grpc::CreateCustomChannel</a>( "localhost:50051", <a class="el" href="namespacegrpc.html#a72a5e2e0be4aa041cb587bea339589d7" title="Credentials for an unencrypted, unauthenticated channel.">grpc::InsecureChannelCredentials()</a>, args));</p>
<p>A gRPC server can use a custom <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> by calling the ServerBuilder::SetEventEngine method:</p>
<p>ServerBuilder builder; std::shared_ptr&lt;EventEngine&gt; engine = std::make_shared&lt;MyEngine&gt;(...); builder.SetEventEngine(engine); std::unique_ptr&lt;Server&gt; server(builder.BuildAndStart()); server-&gt;Wait(); </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad38e4bd2a5559809d16246442460af3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38e4bd2a5559809d16246442460af3d">&#9670;&nbsp;</a></span>OnConnectCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">grpc_event_engine::experimental::EventEngine::OnConnectCallback</a> =  std::function&lt;void(absl::StatusOr&lt;std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a>&gt; &gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new connection is established. </p>
<p>If the connection attempt was not successful, implementations should pass the appropriate statuses to this callback. For example, callbacks might expect to receive DEADLINE_EXCEEDED statuses when appropriate, or CANCELLED statuses on <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> shutdown. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa283885518525b71339f166e15932cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa283885518525b71339f166e15932cd1">&#9670;&nbsp;</a></span>~EventEngine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual grpc_event_engine::experimental::EventEngine::~EventEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>At time of destruction, the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> must have no active responsibilities. </p>
<p><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> users (applications) are responsible for cancelling all tasks and DNS lookups, shutting down listeners and endpoints, prior to <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> destruction. If there are any outstanding tasks, any running listeners, etc. at time of <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> destruction, that is an invalid use of the API, and it will result in undefined behavior. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aab8a579f7dc8429c8d2aa2cd81da910b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8a579f7dc8429c8d2aa2cd81da910b">&#9670;&nbsp;</a></span>Cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool grpc_event_engine::experimental::EventEngine::Cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request cancellation of a task. </p>
<p>If the associated closure has already been scheduled to run, it will not be cancelled, and this function will return false.</p>
<p>If the associated callback has not been scheduled to run, it will be cancelled, and the associated std::function or <em>Closure*</em> will not be executed. In this case, Cancel will return true. </p>

</div>
</div>
<a id="ad116ce06ec29f65ce4083b226d2d90c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad116ce06ec29f65ce4083b226d2d90c8">&#9670;&nbsp;</a></span>CancelConnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool grpc_event_engine::experimental::EventEngine::CancelConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html">ConnectionHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request cancellation of a connection attempt. </p>
<p>If the associated connection has already been completed, it will not be cancelled, and this method will return false.</p>
<p>If the associated connection has not been completed, it will be cancelled, and this method will return true. The <em>OnConnectCallback</em> will not be called. </p>

</div>
</div>
<a id="a9f6d2fe70d8fd254ec4099f6c60b291f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6d2fe70d8fd254ec4099f6c60b291f">&#9670;&nbsp;</a></span>Connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html">ConnectionHandle</a> grpc_event_engine::experimental::EventEngine::Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad38e4bd2a5559809d16246442460af3d">OnConnectCallback</a>&#160;</td>
          <td class="paramname"><em>on_connect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator.html">MemoryAllocator</a>&#160;</td>
          <td class="paramname"><em>memory_allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::Time&#160;</td>
          <td class="paramname"><em>deadline</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a client network connection to a remote network listener. </p>
<p>Even in the event of an error, it is expected that the <em>on_connect</em> callback will be asynchronously executed exactly once by the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a>. A connection attempt can be cancelled using the <em>CancelConnect</em> method.</p>
<p>Implementation Note: it is important that the <em>memory_allocator</em> be used for all read/write buffer allocations in the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> implementation. This allows gRPC's <em>ResourceQuota</em> system to monitor and control memory usage with graceful degradation mechanisms. Please see the <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator.html">MemoryAllocator</a></em> API for more information. </p>

</div>
</div>
<a id="a57fe4d3cb961ef56f9f872e18a64f840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fe4d3cb961ef56f9f872e18a64f840">&#9670;&nbsp;</a></span>CreateListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual absl::StatusOr&lt;std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a>&gt; &gt; grpc_event_engine::experimental::EventEngine::CreateListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#a4ab93dee16f17ef34fe4ff0f0b95a1ab">Listener::AcceptCallback</a>&#160;</td>
          <td class="paramname"><em>on_accept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(absl::Status)&gt;&#160;</td>
          <td class="paramname"><em>on_shutdown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator_factory.html">MemoryAllocatorFactory</a> &gt;&#160;</td>
          <td class="paramname"><em>memory_allocator_factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create a network listener / server. </p>
<p>Once a <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a></em> is created and started, the <em>on_accept</em> callback will be called once asynchronously for each established connection. This method may return a non-OK status immediately if an error was encountered in any synchronous steps required to create the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a>. In this case, <em>on_shutdown</em> will never be called.</p>
<p>If this method returns a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a>, then <em>on_shutdown</em> will be invoked exactly once, when the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a> is shut down. The status passed to it will indicate if there was a problem during shutdown.</p>
<p>The provided <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator_factory.html">MemoryAllocatorFactory</a></em> is used to create <em>MemoryAllocators</em> for <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html" title="One end of a connection between a gRPC client and server.">Endpoint</a> construction. </p>

</div>
</div>
<a id="a955326b931bda68cecff3f75605c0689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955326b931bda68cecff3f75605c0689">&#9670;&nbsp;</a></span>GetDNSResolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a>&gt; grpc_event_engine::experimental::EventEngine::GetDNSResolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns an instance of a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html" title="Provides asynchronous resolution.">DNSResolver</a>. </p>

</div>
</div>
<a id="afb9dbb26c374daf51b6460da89a7d586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9dbb26c374daf51b6460da89a7d586">&#9670;&nbsp;</a></span>IsWorkerThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool grpc_event_engine::experimental::EventEngine::IsWorkerThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a589e091e9af842bcda00411996d9255f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589e091e9af842bcda00411996d9255f">&#9670;&nbsp;</a></span>Run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc_event_engine::experimental::EventEngine::Run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html">Closure</a> *&#160;</td>
          <td class="paramname"><em>closure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously executes a task as soon as possible. </p>
<p><em>Closures</em> scheduled with <em>Run</em> cannot be cancelled. The <em>closure</em> will not be deleted after it has been run, ownership remains with the caller. </p>

</div>
</div>
<a id="af5539922dc4f6599e38adb0891f44986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5539922dc4f6599e38adb0891f44986">&#9670;&nbsp;</a></span>Run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc_event_engine::experimental::EventEngine::Run </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>closure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously executes a task as soon as possible. </p>
<p><em>Closures</em> scheduled with <em>Run</em> cannot be cancelled. Unlike the overloaded <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html" title="A custom closure type for EventEngine task execution.">Closure</a></em> alternative, the std::function version's <em>closure</em> will be deleted by the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> after the closure has been run.</p>
<p>This version of <em>Run</em> may be less performant than the <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html" title="A custom closure type for EventEngine task execution.">Closure</a></em> version in some scenarios. This overload is useful in situations where performance is not a critical concern. </p>

</div>
</div>
<a id="a254481ef518e7aba0e07bbb4c3d3e18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254481ef518e7aba0e07bbb4c3d3e18c">&#9670;&nbsp;</a></span>RunAt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> grpc_event_engine::experimental::EventEngine::RunAt </td>
          <td>(</td>
          <td class="paramtype">absl::Time&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html">Closure</a> *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonymous with scheduling an alarm to run at time <em>when</em>. </p>
<p>The <em>closure</em> will execute when time <em>when</em> arrives unless it has been cancelled via the <em>Cancel</em> method. If cancelled, the closure will not be run, nor will it be deleted. Ownership remains with the caller. </p>

</div>
</div>
<a id="a61c5e59baf71097104f5867f3b0b6d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c5e59baf71097104f5867f3b0b6d2e">&#9670;&nbsp;</a></span>RunAt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> grpc_event_engine::experimental::EventEngine::RunAt </td>
          <td>(</td>
          <td class="paramtype">absl::Time&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonymous with scheduling an alarm to run at time <em>when</em>. </p>
<p>The <em>closure</em> will execute when time <em>when</em> arrives unless it has been cancelled via the <em>Cancel</em> method. If cancelled, the closure will not be run. Unilke the overloaded <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html" title="A custom closure type for EventEngine task execution.">Closure</a></em> alternative, the std::function version's <em>closure</em> will be deleted by the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine encapsulates all platform-specific behaviors related to low level network I/O,...">EventEngine</a> after the closure has been run, or upon cancellation.</p>
<p>This version of <em>RunAt</em> may be less performant than the <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html" title="A custom closure type for EventEngine task execution.">Closure</a></em> version in some scenarios. This overload is useful in situations where performance is not a critical concern. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/grpc/event_engine/<a class="el" href="event__engine_8h_source.html">event_engine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 18 2022 17:42:14 for GRPC C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
