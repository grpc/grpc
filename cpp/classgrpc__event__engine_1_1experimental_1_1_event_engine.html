<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC C++: grpc_event_engine::experimental::EventEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC C++
   &#160;<span id="projectnumber">1.54.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegrpc__event__engine.html">grpc_event_engine</a></li><li class="navelem"><a class="el" href="namespacegrpc__event__engine_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html">EventEngine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">grpc_event_engine::experimental::EventEngine Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> Interface.  
 <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="event__engine_8h_source.html">event_engine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html">Closure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom closure type for <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> task execution.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html">ConnectionHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to a cancellable connection attempt.  <a href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides asynchronous resolution.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One end of a connection between a gRPC client and server.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listens for incoming connection requests from gRPC clients and initiates request processing once connections are established.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thin wrapper around a platform-specific sockaddr type.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a scheduled task.  <a href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3380997754430d27e6b9832174184327"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3380997754430d27e6b9832174184327">Duration</a> = std::chrono::duration&lt; int64_t, std::nano &gt;</td></tr>
<tr class="memdesc:a3380997754430d27e6b9832174184327"><td class="mdescLeft">&#160;</td><td class="mdescRight">A duration between two events.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3380997754430d27e6b9832174184327">More...</a><br /></td></tr>
<tr class="separator:a3380997754430d27e6b9832174184327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d190fa0d2978cce36684d203830496e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a9d190fa0d2978cce36684d203830496e">OnConnectCallback</a> = absl::AnyInvocable&lt; void(absl::StatusOr&lt; std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a> &gt; &gt;)&gt;</td></tr>
<tr class="memdesc:a9d190fa0d2978cce36684d203830496e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a new connection is established.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a9d190fa0d2978cce36684d203830496e">More...</a><br /></td></tr>
<tr class="separator:a9d190fa0d2978cce36684d203830496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a42219352c1ecf679da50671e9a1b35fb"><td class="memItemLeft" align="right" valign="top">virtual absl::StatusOr&lt; std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a42219352c1ecf679da50671e9a1b35fb">CreateListener</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#ab96fd5b221a41105db2be8b458f92a6c">Listener::AcceptCallback</a> on_accept, absl::AnyInvocable&lt; void(absl::Status)&gt; on_shutdown, const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;config, std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator_factory.html">MemoryAllocatorFactory</a> &gt; memory_allocator_factory)=0</td></tr>
<tr class="memdesc:a42219352c1ecf679da50671e9a1b35fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to create a network listener / server.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a42219352c1ecf679da50671e9a1b35fb">More...</a><br /></td></tr>
<tr class="separator:a42219352c1ecf679da50671e9a1b35fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0a8f1b88d47735c3b5bb7a51d8c4c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html">ConnectionHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a1b0a8f1b88d47735c3b5bb7a51d8c4c5">Connect</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a9d190fa0d2978cce36684d203830496e">OnConnectCallback</a> on_connect, const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a> &amp;addr, const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;args, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator.html">MemoryAllocator</a> memory_allocator, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3380997754430d27e6b9832174184327">Duration</a> timeout)=0</td></tr>
<tr class="memdesc:a1b0a8f1b88d47735c3b5bb7a51d8c4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a client network connection to a remote network listener.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a1b0a8f1b88d47735c3b5bb7a51d8c4c5">More...</a><br /></td></tr>
<tr class="separator:a1b0a8f1b88d47735c3b5bb7a51d8c4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad116ce06ec29f65ce4083b226d2d90c8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad116ce06ec29f65ce4083b226d2d90c8">CancelConnect</a> (<a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html">ConnectionHandle</a> handle)=0</td></tr>
<tr class="memdesc:ad116ce06ec29f65ce4083b226d2d90c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request cancellation of a connection attempt.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#ad116ce06ec29f65ce4083b226d2d90c8">More...</a><br /></td></tr>
<tr class="separator:ad116ce06ec29f65ce4083b226d2d90c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283885518525b71339f166e15932cd1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aa283885518525b71339f166e15932cd1">~EventEngine</a> ()=default</td></tr>
<tr class="memdesc:aa283885518525b71339f166e15932cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">At time of destruction, the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> must have no active responsibilities.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aa283885518525b71339f166e15932cd1">More...</a><br /></td></tr>
<tr class="separator:aa283885518525b71339f166e15932cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9dbb26c374daf51b6460da89a7d586"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#afb9dbb26c374daf51b6460da89a7d586">IsWorkerThread</a> ()=0</td></tr>
<tr class="separator:afb9dbb26c374daf51b6460da89a7d586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff36f88737f1ea6daf7e0f630935d37"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a2ff36f88737f1ea6daf7e0f630935d37">GetDNSResolver</a> (const <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver_1_1_resolver_options.html">DNSResolver::ResolverOptions</a> &amp;options)=0</td></tr>
<tr class="memdesc:a2ff36f88737f1ea6daf7e0f630935d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns an instance of a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html" title="Provides asynchronous resolution.">DNSResolver</a>, optionally configured by the <em>options</em> struct.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a2ff36f88737f1ea6daf7e0f630935d37">More...</a><br /></td></tr>
<tr class="separator:a2ff36f88737f1ea6daf7e0f630935d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589e091e9af842bcda00411996d9255f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a589e091e9af842bcda00411996d9255f">Run</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html">Closure</a> *closure)=0</td></tr>
<tr class="memdesc:a589e091e9af842bcda00411996d9255f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously executes a task as soon as possible.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a589e091e9af842bcda00411996d9255f">More...</a><br /></td></tr>
<tr class="separator:a589e091e9af842bcda00411996d9255f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b363a206399c2acde2d1681699b3ae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a51b363a206399c2acde2d1681699b3ae">Run</a> (absl::AnyInvocable&lt; void()&gt; closure)=0</td></tr>
<tr class="memdesc:a51b363a206399c2acde2d1681699b3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously executes a task as soon as possible.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a51b363a206399c2acde2d1681699b3ae">More...</a><br /></td></tr>
<tr class="separator:a51b363a206399c2acde2d1681699b3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854dfb6d39d5c6106eb98d499209529a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a854dfb6d39d5c6106eb98d499209529a">RunAfter</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3380997754430d27e6b9832174184327">Duration</a> when, <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html">Closure</a> *closure)=0</td></tr>
<tr class="memdesc:a854dfb6d39d5c6106eb98d499209529a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonymous with scheduling an alarm to run after duration <em>when</em>.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a854dfb6d39d5c6106eb98d499209529a">More...</a><br /></td></tr>
<tr class="separator:a854dfb6d39d5c6106eb98d499209529a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6ad8aa9c0eb3e6881e03f6ffc42e3b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a8f6ad8aa9c0eb3e6881e03f6ffc42e3b">RunAfter</a> (<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3380997754430d27e6b9832174184327">Duration</a> when, absl::AnyInvocable&lt; void()&gt; closure)=0</td></tr>
<tr class="memdesc:a8f6ad8aa9c0eb3e6881e03f6ffc42e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonymous with scheduling an alarm to run after duration <em>when</em>.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a8f6ad8aa9c0eb3e6881e03f6ffc42e3b">More...</a><br /></td></tr>
<tr class="separator:a8f6ad8aa9c0eb3e6881e03f6ffc42e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8a579f7dc8429c8d2aa2cd81da910b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aab8a579f7dc8429c8d2aa2cd81da910b">Cancel</a> (<a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> handle)=0</td></tr>
<tr class="memdesc:aab8a579f7dc8429c8d2aa2cd81da910b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request cancellation of a task.  <a href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#aab8a579f7dc8429c8d2aa2cd81da910b">More...</a><br /></td></tr>
<tr class="separator:aab8a579f7dc8429c8d2aa2cd81da910b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> Interface. </p>
<h2><a class="anchor" id="autotoc_md265"></a>
Overview</h2>
<p>The <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> encapsulates all platform-specific behaviors related to low level network I/O, timers, asynchronous execution, and DNS resolution.</p>
<p>This interface allows developers to provide their own event management and network stacks. Motivating uses cases for supporting custom EventEngines include the ability to hook into external event loops, and using different <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> instances for each channel to better insulate network I/O and callback processing from other channels.</p>
<p>A default cross-platform <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> instance is provided by gRPC.</p>
<h2><a class="anchor" id="autotoc_md266"></a>
Lifespan and Ownership</h2>
<p>gRPC takes shared ownership of EventEngines via std::shared_ptrs to ensure that the engines remain available until they are no longer needed. Depending on the use case, engines may live until gRPC is shut down.</p>
<p>EXAMPLE USAGE (Not yet implemented)</p>
<p>Custom EventEngines can be specified per channel, and allow configuration for both clients and servers. To set a custom <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> for a client channel, you can do something like the following:</p>
<p>ChannelArguments args; std::shared_ptr&lt;EventEngine&gt; engine = std::make_shared&lt;MyEngine&gt;(...); args.SetEventEngine(engine); MyAppClient client(<a class="el" href="namespacegrpc.html#a4a5c8a2c77389604feaa5d38cdd7b8d3" title="Create a new custom Channel pointing to target.">grpc::CreateCustomChannel</a>( "localhost:50051", <a class="el" href="namespacegrpc.html#a72a5e2e0be4aa041cb587bea339589d7" title="Credentials for an unencrypted, unauthenticated channel.">grpc::InsecureChannelCredentials()</a>, args));</p>
<p>A gRPC server can use a custom <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> by calling the ServerBuilder::SetEventEngine method:</p>
<p>ServerBuilder builder; std::shared_ptr&lt;EventEngine&gt; engine = std::make_shared&lt;MyEngine&gt;(...); builder.SetEventEngine(engine); std::unique_ptr&lt;Server&gt; server(builder.BuildAndStart()); server-&gt;Wait();</p>
<h2><a class="anchor" id="autotoc_md267"></a>
Blocking EventEngine Callbacks</h2>
<p>Doing blocking work in <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> callbacks is generally not advisable. While gRPC's default <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> implementations have some capacity to scale their thread pools to avoid starvation, this is not an instantaneous process. Further, user-provided EventEngines may not be optimized to handle excessive blocking work at all.</p>
<p><em>Best Practice</em> : Occasional blocking work may be fine, but we do not recommend running a mostly blocking workload in <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> threads. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3380997754430d27e6b9832174184327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3380997754430d27e6b9832174184327">&#9670;&nbsp;</a></span>Duration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3380997754430d27e6b9832174184327">grpc_event_engine::experimental::EventEngine::Duration</a> =  std::chrono::duration&lt;int64_t, std::nano&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A duration between two events. </p>
<p>Throughout the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> API durations are used to express how long until an action should be performed. </p>

</div>
</div>
<a id="a9d190fa0d2978cce36684d203830496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d190fa0d2978cce36684d203830496e">&#9670;&nbsp;</a></span>OnConnectCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a9d190fa0d2978cce36684d203830496e">grpc_event_engine::experimental::EventEngine::OnConnectCallback</a> =  absl::AnyInvocable&lt;void(absl::StatusOr&lt;std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html">Endpoint</a>&gt; &gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a new connection is established. </p>
<p>If the connection attempt was not successful, implementations should pass the appropriate statuses to this callback. For example, callbacks might expect to receive DEADLINE_EXCEEDED statuses when appropriate, or CANCELLED statuses on <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> shutdown. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa283885518525b71339f166e15932cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa283885518525b71339f166e15932cd1">&#9670;&nbsp;</a></span>~EventEngine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual grpc_event_engine::experimental::EventEngine::~EventEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>At time of destruction, the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> must have no active responsibilities. </p>
<p><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> users (applications) are responsible for cancelling all tasks and DNS lookups, shutting down listeners and endpoints, prior to <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> destruction. If there are any outstanding tasks, any running listeners, etc. at time of <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> destruction, that is an invalid use of the API, and it will result in undefined behavior. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aab8a579f7dc8429c8d2aa2cd81da910b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8a579f7dc8429c8d2aa2cd81da910b">&#9670;&nbsp;</a></span>Cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool grpc_event_engine::experimental::EventEngine::Cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request cancellation of a task. </p>
<p>If the associated closure has already been scheduled to run, it will not be cancelled, and this function will return false.</p>
<p>If the associated closure has not been scheduled to run, it will be cancelled, and the associated absl::AnyInvocable or <em>Closure*</em> will not be executed. In this case, Cancel will return true.</p>
<p>Implementation note: closures should be destroyed in a timely manner after execution or cancellation (milliseconds), since any state bound to the closure may need to be destroyed for things to progress (e.g., if a closure holds a ref to some ref-counted object). </p>

</div>
</div>
<a id="ad116ce06ec29f65ce4083b226d2d90c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad116ce06ec29f65ce4083b226d2d90c8">&#9670;&nbsp;</a></span>CancelConnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool grpc_event_engine::experimental::EventEngine::CancelConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html">ConnectionHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request cancellation of a connection attempt. </p>
<p>If the associated connection has already been completed, it will not be cancelled, and this method will return false.</p>
<p>If the associated connection has not been completed, it will be cancelled, and this method will return true. The <em>OnConnectCallback</em> will not be called. </p>

</div>
</div>
<a id="a1b0a8f1b88d47735c3b5bb7a51d8c4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0a8f1b88d47735c3b5bb7a51d8c4c5">&#9670;&nbsp;</a></span>Connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_connection_handle.html">ConnectionHandle</a> grpc_event_engine::experimental::EventEngine::Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a9d190fa0d2978cce36684d203830496e">OnConnectCallback</a>&#160;</td>
          <td class="paramname"><em>on_connect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_resolved_address.html">ResolvedAddress</a> &amp;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator.html">MemoryAllocator</a>&#160;</td>
          <td class="paramname"><em>memory_allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3380997754430d27e6b9832174184327">Duration</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a client network connection to a remote network listener. </p>
<p>Even in the event of an error, it is expected that the <em>on_connect</em> callback will be asynchronously executed exactly once by the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a>. A connection attempt can be cancelled using the <em>CancelConnect</em> method.</p>
<p>Implementation Note: it is important that the <em>memory_allocator</em> be used for all read/write buffer allocations in the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> implementation. This allows gRPC's <em>ResourceQuota</em> system to monitor and control memory usage with graceful degradation mechanisms. Please see the <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator.html">MemoryAllocator</a></em> API for more information. </p>

</div>
</div>
<a id="a42219352c1ecf679da50671e9a1b35fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42219352c1ecf679da50671e9a1b35fb">&#9670;&nbsp;</a></span>CreateListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual absl::StatusOr&lt;std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html">Listener</a>&gt; &gt; grpc_event_engine::experimental::EventEngine::CreateListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html#ab96fd5b221a41105db2be8b458f92a6c">Listener::AcceptCallback</a>&#160;</td>
          <td class="paramname"><em>on_accept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::AnyInvocable&lt; void(absl::Status)&gt;&#160;</td>
          <td class="paramname"><em>on_shutdown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_endpoint_config.html">EndpointConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator_factory.html">MemoryAllocatorFactory</a> &gt;&#160;</td>
          <td class="paramname"><em>memory_allocator_factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method to create a network listener / server. </p>
<p>Once a <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a></em> is created and started, the <em>on_accept</em> callback will be called once asynchronously for each established connection. This method may return a non-OK status immediately if an error was encountered in any synchronous steps required to create the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a>. In this case, <em>on_shutdown</em> will never be called.</p>
<p>If this method returns a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a>, then <em>on_shutdown</em> will be invoked exactly once, when the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_listener.html" title="Listens for incoming connection requests from gRPC clients and initiates request processing once conn...">Listener</a> is shut down. The status passed to it will indicate if there was a problem during shutdown.</p>
<p>The provided <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_memory_allocator_factory.html">MemoryAllocatorFactory</a></em> is used to create <em>MemoryAllocators</em> for <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_endpoint.html" title="One end of a connection between a gRPC client and server.">Endpoint</a> construction. </p>

</div>
</div>
<a id="a2ff36f88737f1ea6daf7e0f630935d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ff36f88737f1ea6daf7e0f630935d37">&#9670;&nbsp;</a></span>GetDNSResolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html">DNSResolver</a>&gt; grpc_event_engine::experimental::EventEngine::GetDNSResolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver_1_1_resolver_options.html">DNSResolver::ResolverOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns an instance of a <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_d_n_s_resolver.html" title="Provides asynchronous resolution.">DNSResolver</a>, optionally configured by the <em>options</em> struct. </p>

</div>
</div>
<a id="afb9dbb26c374daf51b6460da89a7d586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9dbb26c374daf51b6460da89a7d586">&#9670;&nbsp;</a></span>IsWorkerThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool grpc_event_engine::experimental::EventEngine::IsWorkerThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51b363a206399c2acde2d1681699b3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b363a206399c2acde2d1681699b3ae">&#9670;&nbsp;</a></span>Run() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc_event_engine::experimental::EventEngine::Run </td>
          <td>(</td>
          <td class="paramtype">absl::AnyInvocable&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>closure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously executes a task as soon as possible. </p>
<p><em>Closures</em> scheduled with <em>Run</em> cannot be cancelled. Unlike the overloaded <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html" title="A custom closure type for EventEngine task execution.">Closure</a></em> alternative, the absl::AnyInvocable version's <em>closure</em> will be deleted by the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> after the closure has been run.</p>
<p>This version of <em>Run</em> may be less performant than the <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html" title="A custom closure type for EventEngine task execution.">Closure</a></em> version in some scenarios. This overload is useful in situations where performance is not a critical concern.</p>
<p>Implementations must not execute the closure in the calling thread before <em>Run</em> returns. </p>

</div>
</div>
<a id="a589e091e9af842bcda00411996d9255f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589e091e9af842bcda00411996d9255f">&#9670;&nbsp;</a></span>Run() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc_event_engine::experimental::EventEngine::Run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html">Closure</a> *&#160;</td>
          <td class="paramname"><em>closure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously executes a task as soon as possible. </p>
<p><em>Closures</em> scheduled with <em>Run</em> cannot be cancelled. The <em>closure</em> will not be deleted after it has been run, ownership remains with the caller.</p>
<p>Implementations must not execute the closure in the calling thread before <em>Run</em> returns. For example, if the caller must release a lock before the closure can proceed, running the closure immediately would cause a deadlock. </p>

</div>
</div>
<a id="a8f6ad8aa9c0eb3e6881e03f6ffc42e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6ad8aa9c0eb3e6881e03f6ffc42e3b">&#9670;&nbsp;</a></span>RunAfter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> grpc_event_engine::experimental::EventEngine::RunAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3380997754430d27e6b9832174184327">Duration</a>&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">absl::AnyInvocable&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonymous with scheduling an alarm to run after duration <em>when</em>. </p>
<p>The <em>closure</em> will execute when time <em>when</em> arrives unless it has been cancelled via the <em>Cancel</em> method. If cancelled, the closure will not be run. Unlike the overloaded <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html" title="A custom closure type for EventEngine task execution.">Closure</a></em> alternative, the absl::AnyInvocable version's <em>closure</em> will be deleted by the <a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html" title="The EventEngine Interface.">EventEngine</a> after the closure has been run, or upon cancellation.</p>
<p>This version of <em>RunAfter</em> may be less performant than the <em><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html" title="A custom closure type for EventEngine task execution.">Closure</a></em> version in some scenarios. This overload is useful in situations where performance is not a critical concern.</p>
<p>Implementations must not execute the closure in the calling thread before <em>RunAfter</em> returns. </p>

</div>
</div>
<a id="a854dfb6d39d5c6106eb98d499209529a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854dfb6d39d5c6106eb98d499209529a">&#9670;&nbsp;</a></span>RunAfter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_task_handle.html">TaskHandle</a> grpc_event_engine::experimental::EventEngine::RunAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine.html#a3380997754430d27e6b9832174184327">Duration</a>&#160;</td>
          <td class="paramname"><em>when</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgrpc__event__engine_1_1experimental_1_1_event_engine_1_1_closure.html">Closure</a> *&#160;</td>
          <td class="paramname"><em>closure</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synonymous with scheduling an alarm to run after duration <em>when</em>. </p>
<p>The <em>closure</em> will execute when time <em>when</em> arrives unless it has been cancelled via the <em>Cancel</em> method. If cancelled, the closure will not be run, nor will it be deleted. Ownership remains with the caller.</p>
<p>Implementations must not execute the closure in the calling thread before <em>RunAfter</em> returns. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/grpc/event_engine/<a class="el" href="event__engine_8h_source.html">event_engine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 13 2023 06:50:48 for GRPC C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
