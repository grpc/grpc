<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC C++: Load Balancing in gRPC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC C++
   &#160;<span id="projectnumber">1.56.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Load Balancing in gRPC </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md172"></a>
Scope</h1>
<p>This document explains the design for load balancing within gRPC.</p>
<h1><a class="anchor" id="autotoc_md173"></a>
Background</h1>
<p>Load-balancing within gRPC happens on a per-call basis, not a per-connection basis. In other words, even if all requests come from a single client, we still want them to be load-balanced across all servers.</p>
<h1><a class="anchor" id="autotoc_md174"></a>
Architecture</h1>
<h2><a class="anchor" id="autotoc_md175"></a>
Overview</h2>
<p>The gRPC client supports an API that allows load balancing policies to be implemented and plugged into gRPC. An LB policy is responsible for:</p><ul>
<li>receiving updated configuration and list of server addresses from the resolver</li>
<li>creating subchannels for the server addresses and managing their connectivity behavior</li>
<li>setting the overall <a class="el" href="connectivity-semantics-and-api_8md.html">connectivity state</a> (usually computed by aggregating the connectivity states of its subchannels) of the channel</li>
<li>for each RPC sent on the channel, determining which subchannel to send the RPC on</li>
</ul>
<p>There are a number of LB policies provided with gRPC. The most notable ones are <code>pick_first</code> (the default), <code>round_robin</code>, and <code>grpclb</code>. There are also a number of additional LB policies to support <a class="el" href="grpc__xds__features_8md.html">xDS</a>, although they are not currently configurable directly.</p>
<h2><a class="anchor" id="autotoc_md176"></a>
Workflow</h2>
<p>Load-balancing policies fit into the gRPC client workflow in between name resolution and the connection to the server. Here's how it all works:</p>
<p><img src="images/load-balancing.png" alt="image" class="inline"/></p>
<ol type="1">
<li>On startup, the gRPC client issues a <a class="el" href="naming_8md.html">name resolution</a> request for the server name. The name will resolve to a list of IP addresses, a <a class="el" href="service__config_8md.html">service config</a> that indicates which client-side load-balancing policy to use (e.g., <code>round_robin</code> or <code>grpclb</code>) and provides a configuration for that policy, and a set of attributes (channel args in C-core).</li>
<li>The client instantiates the load balancing policy and passes it its configuration from the service config, the list of IP addresses, and the attributes.</li>
<li>The load balancing policy creates a set of subchannels for the IP addresses of the servers (which might be different from the IP addresses returned by the resolver; see below). It also watches the subchannels' connectivity states and decides when each subchannel should attempt to connect.</li>
<li>For each RPC sent, the load balancing policy decides which subchannel (i.e., which server) the RPC should be sent to.</li>
</ol>
<p>See below for more information on <code>grpclb</code>.</p>
<h2><a class="anchor" id="autotoc_md177"></a>
Load Balancing Policies</h2>
<h3><a class="anchor" id="autotoc_md178"></a>
&lt;tt&gt;pick_first&lt;/tt&gt;</h3>
<p>This is the default LB policy if the service config does not specify any LB policy. It does not require any configuration.</p>
<p>The <code>pick_first</code> policy takes a list of addresses from the resolver. It attempts to connect to those addresses one at a time, in order, until it finds one that is reachable. If none of the addresses are reachable, it sets the channel's state to TRANSIENT_FAILURE while it attempts to reconnect. Appropriate <a class="el" href="connection-backoff_8md.html">backoff</a> is applied for repeated connection attempts.</p>
<p>If it is able to connect to one of the addresses, it sets the channel's state to READY, and then all RPCs sent on the channel will be sent to that address. If the connection to that address is later broken, the <code>pick_first</code> policy will put the channel into state IDLE, and it will not attempt to reconnect until the application requests that it does so (either via the channel's connectivity state API or by sending an RPC).</p>
<h3><a class="anchor" id="autotoc_md179"></a>
&lt;tt&gt;round_robin&lt;/tt&gt;</h3>
<p>This LB policy is selected via the service config. It does not require any configuration.</p>
<p>This policy takes a list of addresses from the resolver. It creates a subchannel for each of those addresses and constantly monitors the connectivity state of the subchannels. Whenever a subchannel becomes disconnected, the <code>round_robin</code> policy will ask it to reconnect, with appropriate connection <a class="el" href="connection-backoff_8md.html">backoff</a>.</p>
<p>The policy sets the channel's connectivity state by aggregating the states of the subchannels:</p><ul>
<li>If any one subchannel is in READY state, the channel's state is READY.</li>
<li>Otherwise, if there is any subchannel in state CONNECTING, the channel's state is CONNECTING.</li>
<li>Otherwise, if there is any subchannel in state IDLE, the channel's state is IDLE.</li>
<li>Otherwise, if all subchannels are in state TRANSIENT_FAILURE, the channel's state is TRANSIENT_FAILURE.</li>
</ul>
<p>Note that when a given subchannel reports TRANSIENT_FAILURE, it is considered to still be in TRANSIENT_FAILURE until it successfully reconnects and reports READY. In particular, we ignore the transition from TRANSIENT_FAILURE to CONNECTING.</p>
<p>When an RPC is sent on the channel, the <code>round_robin</code> policy will iterate over all subchannels that are currently in READY state, sending each successive RPC to the next successive subchannel in the list, wrapping around to the start of the list when needed.</p>
<h3><a class="anchor" id="autotoc_md180"></a>
&lt;tt&gt;grpclb&lt;/tt&gt;</h3>
<p>(This policy is deprecated. We recommend using <a class="el" href="grpc__xds__features_8md.html">xDS</a> instead.)</p>
<p>This LB policy was originally intended as gRPC's primary extensibility mechanism for load balancing. The intent was that instead of adding new LB policies directly in the client, the client could implement only simple algorithms like <code>round_robin</code>, and any more complex algorithms would be provided by a look-aside load balancer.</p>
<p>The client relies on the load balancer to provide <em>load balancing configuration</em> and <em>the list of server addresses</em> to which the client should send requests. The balancer updates the server list as needed to balance the load as well as handle server unavailability or health issues. The load balancer will make any necessary complex decisions and inform the client. The load balancer may communicate with the backend servers to collect load and health information.</p>
<p>The <code>grpclb</code> policy uses the addresses returned by the resolver (if any) as fallback addresses, which are used when it loses contact with the balancers.</p>
<p>The <code>grpclb</code> policy gets the list of addresses of the balancers to talk to via an attribute returned by the resolver. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 27 2023 17:50:38 for GRPC C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
