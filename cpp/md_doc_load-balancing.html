<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC C++: Load Balancing in gRPC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC C++
   &#160;<span id="projectnumber">1.41.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Load Balancing in gRPC </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md170"></a>
Scope</h1>
<p>This document explains the design for load balancing within gRPC.</p>
<h1><a class="anchor" id="autotoc_md171"></a>
Background</h1>
<h2><a class="anchor" id="autotoc_md172"></a>
Per-Call Load Balancing</h2>
<p>It is worth noting that load-balancing within gRPC happens on a per-call basis, not a per-connection basis. In other words, even if all requests come from a single client, we still want them to be load-balanced across all servers.</p>
<h2><a class="anchor" id="autotoc_md173"></a>
Approaches to Load Balancing</h2>
<p>Prior to any gRPC specifics, we explore some usual ways to approach load balancing.</p>
<h3><a class="anchor" id="autotoc_md174"></a>
Proxy Model</h3>
<p>Using a proxy provides a solid trustable client that can report load to the load balancing system. Proxies typically require more resources to operate since they have temporary copies of the RPC request and response. This model also increases latency to the RPCs.</p>
<p>The proxy model was deemed inefficient when considering request heavy services like storage.</p>
<h3><a class="anchor" id="autotoc_md175"></a>
Balancing-aware Client</h3>
<p>This thicker client places more of the load balancing logic in the client. For example, the client could contain many load balancing policies (Round Robin, Random, etc) used to select servers from a list. In this model, a list of servers would be either statically configured in the client, provided by the name resolution system, an external load balancer, etc. In any case, the client is responsible for choosing the preferred server from the list.</p>
<p>One of the drawbacks of this approach is writing and maintaining the load balancing policies in multiple languages and/or versions of the clients. These policies can be fairly complicated. Some of the algorithms also require client to server communication so the client would need to get thicker to support additional RPCs to get health or load information in addition to sending RPCs for user requests.</p>
<p>It would also significantly complicate the client's code: the new design hides the load balancing complexity of multiple layers and presents it as a simple list of servers to the client.</p>
<h3><a class="anchor" id="autotoc_md176"></a>
External Load Balancing Service</h3>
<p>The client load balancing code is kept simple and portable, implementing well-known algorithms (e.g., Round Robin) for server selection. Complex load balancing algorithms are instead provided by the load balancer. The client relies on the load balancer to provide <em>load balancing configuration</em> and <em>the list of servers</em> to which the client should send requests. The balancer updates the server list as needed to balance the load as well as handle server unavailability or health issues. The load balancer will make any necessary complex decisions and inform the client. The load balancer may communicate with the backend servers to collect load and health information.</p>
<h1><a class="anchor" id="autotoc_md177"></a>
Requirements</h1>
<h2><a class="anchor" id="autotoc_md178"></a>
Simple API and client</h2>
<p>The gRPC client load balancing code must be simple and portable. The client should only contain simple algorithms (e.g., Round Robin) for server selection. For complex algorithms, the client should rely on a load balancer to provide load balancing configuration and the list of servers to which the client should send requests. The balancer will update the server list as needed to balance the load as well as handle server unavailability or health issues. The load balancer will make any necessary complex decisions and inform the client. The load balancer may communicate with the backend servers to collect load and health information.</p>
<h2><a class="anchor" id="autotoc_md179"></a>
Security</h2>
<p>The load balancer may be separate from the actual server backends and a compromise of the load balancer should only lead to a compromise of the loadbalancing functionality. In other words, a compromised load balancer should not be able to cause a client to trust a (potentially malicious) backend server any more than in a comparable situation without loadbalancing.</p>
<h1><a class="anchor" id="autotoc_md180"></a>
Architecture</h1>
<h2><a class="anchor" id="autotoc_md181"></a>
Overview</h2>
<p>The primary mechanism for load-balancing in gRPC is external load-balancing, where an external load balancer provides simple clients with an up-to-date list of servers.</p>
<p>The gRPC client does support an API for built-in load balancing policies. However, there are only a small number of these (one of which is the <code>grpclb</code> policy, which implements external load balancing), and users are discouraged from trying to extend gRPC by adding more. Instead, new load balancing policies should be implemented in external load balancers.</p>
<h2><a class="anchor" id="autotoc_md182"></a>
Workflow</h2>
<p>Load-balancing policies fit into the gRPC client workflow in between name resolution and the connection to the server. Here's how it all works:</p>
<p><img src="images/load-balancing.png" alt="image" class="inline"/></p>
<ol type="1">
<li>On startup, the gRPC client issues a <a class="el" href="naming_8md.html">name resolution</a> request for the server name. The name will resolve to one or more IP addresses, each of which will indicate whether it is a server address or a load balancer address, and a <a class="el" href="service__config_8md.html">service config</a> that indicates which client-side load-balancing policy to use (e.g., <code>round_robin</code> or <code>grpclb</code>).</li>
<li>The client instantiates the load balancing policy.<ul>
<li>Note: If any one of the addresses returned by the resolver is a balancer address, then the client will use the <code>grpclb</code> policy, regardless of what load-balancing policy was requested by the service config. Otherwise, the client will use the load-balancing policy requested by the service config. If no load-balancing policy is requested by the service config, then the client will default to a policy that picks the first available server address.</li>
</ul>
</li>
<li>The load balancing policy creates a subchannel to each server address.<ul>
<li>For all policies <em>except</em> <code>grpclb</code>, this means one subchannel for each address returned by the resolver. Note that these policies ignore any balancer addresses returned by the resolver.</li>
<li>In the case of the <code>grpclb</code> policy, the workflow is as follows:<ol type="a">
<li>The policy opens a stream to one of the balancer addresses returned by the resolver. It asks the balancer for the server addresses to use for the server name originally requested by the client (i.e., the same one originally passed to the name resolver).<ul>
<li>Note: In the <code>grpclb</code> policy, the non-balancer addresses returned by the resolver are used as a fallback in case no balancers can be contacted when the LB policy is started.</li>
</ul>
</li>
<li>The gRPC servers to which the load balancer is directing the client may report load to the load balancers, if that information is needed by the load balancer's configuration.</li>
<li>The load balancer returns a server list to the gRPC client's <code>grpclb</code> policy. The <code>grpclb</code> policy will then create a subchannel to each of server in the list.</li>
</ol>
</li>
</ul>
</li>
<li>For each RPC sent, the load balancing policy decides which subchannel (i.e., which server) the RPC should be sent to.<ul>
<li>In the case of the <code>grpclb</code> policy, the client will send requests to the servers in the order in which they were returned by the load balancer. If the server list is empty, the call will block until a non-empty one is received. </li>
</ul>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 5 2021 22:54:13 for GRPC C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
