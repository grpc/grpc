<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC C++: grpc::experimental::InterceptorBatchMethods Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC C++
   &#160;<span id="projectnumber">1.60.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegrpc.html">grpc</a></li><li class="navelem"><a class="el" href="namespacegrpc_1_1experimental.html">experimental</a></li><li class="navelem"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html">InterceptorBatchMethods</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">grpc::experimental::InterceptorBatchMethods Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that is passed as an argument to the <em>Intercept</em> method of the application's <em><a class="el" href="classgrpc_1_1experimental_1_1_interceptor.html" title="Interface for an interceptor.">Interceptor</a></em> interface implementation.  
 <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="support_2interceptor_8h_source.html">interceptor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a55f28c464881763e44c003ad945395a5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a55f28c464881763e44c003ad945395a5">~InterceptorBatchMethods</a> ()</td></tr>
<tr class="separator:a55f28c464881763e44c003ad945395a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68758f2d57120220e53bcc6ad1bc8c71"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a68758f2d57120220e53bcc6ad1bc8c71">QueryInterceptionHookPoint</a> (<a class="el" href="namespacegrpc_1_1experimental.html#a03d3481b2c4146f53e90966d4a0fd8a1">InterceptionHookPoints</a> type)=0</td></tr>
<tr class="memdesc:a68758f2d57120220e53bcc6ad1bc8c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the current batch has an interception hook point of type <em>type</em>.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a68758f2d57120220e53bcc6ad1bc8c71">More...</a><br /></td></tr>
<tr class="separator:a68758f2d57120220e53bcc6ad1bc8c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640e84ae950a57b875b38de6ef9d87fe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a640e84ae950a57b875b38de6ef9d87fe">Proceed</a> ()=0</td></tr>
<tr class="memdesc:a640e84ae950a57b875b38de6ef9d87fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal that the interceptor is done intercepting the current batch of the RPC.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a640e84ae950a57b875b38de6ef9d87fe">More...</a><br /></td></tr>
<tr class="separator:a640e84ae950a57b875b38de6ef9d87fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0a9629eb5c5aa8760d5a02fd2ef37f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#aea0a9629eb5c5aa8760d5a02fd2ef37f">Hijack</a> ()=0</td></tr>
<tr class="memdesc:aea0a9629eb5c5aa8760d5a02fd2ef37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate that the interceptor has hijacked the RPC (only valid if the batch contains send_initial_metadata on the client side).  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#aea0a9629eb5c5aa8760d5a02fd2ef37f">More...</a><br /></td></tr>
<tr class="separator:aea0a9629eb5c5aa8760d5a02fd2ef37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa1f2c7437b6d49ef68af8e772625e4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgrpc_1_1_byte_buffer.html">ByteBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a1fa1f2c7437b6d49ef68af8e772625e4">GetSerializedSendMessage</a> ()=0</td></tr>
<tr class="memdesc:a1fa1f2c7437b6d49ef68af8e772625e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send Message Methods GetSerializedSendMessage and GetSendMessage/ModifySendMessage are the available methods to view and modify the request payload.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a1fa1f2c7437b6d49ef68af8e772625e4">More...</a><br /></td></tr>
<tr class="separator:a1fa1f2c7437b6d49ef68af8e772625e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416033d4bab32f333d54f3da9a21b68b"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a416033d4bab32f333d54f3da9a21b68b">GetSendMessage</a> ()=0</td></tr>
<tr class="memdesc:a416033d4bab32f333d54f3da9a21b68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-modifiable pointer to the non-serialized form of the message to be sent.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a416033d4bab32f333d54f3da9a21b68b">More...</a><br /></td></tr>
<tr class="separator:a416033d4bab32f333d54f3da9a21b68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be8b4eecdd2ddf3913369dd3b275d43"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a6be8b4eecdd2ddf3913369dd3b275d43">ModifySendMessage</a> (const void *message)=0</td></tr>
<tr class="memdesc:a6be8b4eecdd2ddf3913369dd3b275d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the message to be sent with <em>message</em>.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a6be8b4eecdd2ddf3913369dd3b275d43">More...</a><br /></td></tr>
<tr class="separator:a6be8b4eecdd2ddf3913369dd3b275d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9381ac548c5ac6ae17af025f9261f9ef"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a9381ac548c5ac6ae17af025f9261f9ef">GetSendMessageStatus</a> ()=0</td></tr>
<tr class="memdesc:a9381ac548c5ac6ae17af025f9261f9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the SEND MESSAGE op succeeded.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a9381ac548c5ac6ae17af025f9261f9ef">More...</a><br /></td></tr>
<tr class="separator:a9381ac548c5ac6ae17af025f9261f9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e59b73b516366438ee6c01d4198d4b"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; std::string, std::string &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a82e59b73b516366438ee6c01d4198d4b">GetSendInitialMetadata</a> ()=0</td></tr>
<tr class="memdesc:a82e59b73b516366438ee6c01d4198d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifiable multimap of the initial metadata to be sent.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a82e59b73b516366438ee6c01d4198d4b">More...</a><br /></td></tr>
<tr class="separator:a82e59b73b516366438ee6c01d4198d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2792ab543f8b46262ee6e69289b436ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgrpc_1_1_status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a2792ab543f8b46262ee6e69289b436ab">GetSendStatus</a> ()=0</td></tr>
<tr class="memdesc:a2792ab543f8b46262ee6e69289b436ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status to be sent. Valid for PRE_SEND_STATUS interceptions.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a2792ab543f8b46262ee6e69289b436ab">More...</a><br /></td></tr>
<tr class="separator:a2792ab543f8b46262ee6e69289b436ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541b5d8a424e703d562a32c27488ccf2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a541b5d8a424e703d562a32c27488ccf2">ModifySendStatus</a> (const <a class="el" href="classgrpc_1_1_status.html">Status</a> &amp;status)=0</td></tr>
<tr class="memdesc:a541b5d8a424e703d562a32c27488ccf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites the status with <em>status</em>.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a541b5d8a424e703d562a32c27488ccf2">More...</a><br /></td></tr>
<tr class="separator:a541b5d8a424e703d562a32c27488ccf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22943cffc568734c939df8157b10f4f9"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; std::string, std::string &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a22943cffc568734c939df8157b10f4f9">GetSendTrailingMetadata</a> ()=0</td></tr>
<tr class="memdesc:a22943cffc568734c939df8157b10f4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifiable multimap of the trailing metadata to be sent.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a22943cffc568734c939df8157b10f4f9">More...</a><br /></td></tr>
<tr class="separator:a22943cffc568734c939df8157b10f4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b267515d6afd29afadba454aa913505"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a3b267515d6afd29afadba454aa913505">GetRecvMessage</a> ()=0</td></tr>
<tr class="memdesc:a3b267515d6afd29afadba454aa913505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the modifiable received message.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a3b267515d6afd29afadba454aa913505">More...</a><br /></td></tr>
<tr class="separator:a3b267515d6afd29afadba454aa913505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f123307653591e63ded55d8cea9ad8b"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>, <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a8f123307653591e63ded55d8cea9ad8b">GetRecvInitialMetadata</a> ()=0</td></tr>
<tr class="memdesc:a8f123307653591e63ded55d8cea9ad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifiable multimap of the received initial metadata.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a8f123307653591e63ded55d8cea9ad8b">More...</a><br /></td></tr>
<tr class="separator:a8f123307653591e63ded55d8cea9ad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60304da4f2c2737bcc259bac19e858d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgrpc_1_1_status.html">Status</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#ac60304da4f2c2737bcc259bac19e858d">GetRecvStatus</a> ()=0</td></tr>
<tr class="memdesc:ac60304da4f2c2737bcc259bac19e858d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifiable view of the received status on PRE_RECV_STATUS and POST_RECV_STATUS interceptions; nullptr if not valid.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#ac60304da4f2c2737bcc259bac19e858d">More...</a><br /></td></tr>
<tr class="separator:ac60304da4f2c2737bcc259bac19e858d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661e6372647f1639783b046d728599fa"><td class="memItemLeft" align="right" valign="top">virtual std::multimap&lt; <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>, <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a661e6372647f1639783b046d728599fa">GetRecvTrailingMetadata</a> ()=0</td></tr>
<tr class="memdesc:a661e6372647f1639783b046d728599fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a modifiable multimap of the received trailing metadata on PRE_RECV_STATUS and POST_RECV_STATUS interceptions; nullptr if not valid.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a661e6372647f1639783b046d728599fa">More...</a><br /></td></tr>
<tr class="separator:a661e6372647f1639783b046d728599fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993f12c0d1a9e5dce038b66c58728e82"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classgrpc_1_1_channel_interface.html">ChannelInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a993f12c0d1a9e5dce038b66c58728e82">GetInterceptedChannel</a> ()=0</td></tr>
<tr class="memdesc:a993f12c0d1a9e5dce038b66c58728e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an intercepted channel.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a993f12c0d1a9e5dce038b66c58728e82">More...</a><br /></td></tr>
<tr class="separator:a993f12c0d1a9e5dce038b66c58728e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d26f52897117e3ea5b6c609a3d4bf91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a4d26f52897117e3ea5b6c609a3d4bf91">FailHijackedRecvMessage</a> ()=0</td></tr>
<tr class="memdesc:a4d26f52897117e3ea5b6c609a3d4bf91"><td class="mdescLeft">&#160;</td><td class="mdescRight">On a hijacked RPC, an interceptor can decide to fail a PRE_RECV_MESSAGE op.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a4d26f52897117e3ea5b6c609a3d4bf91">More...</a><br /></td></tr>
<tr class="separator:a4d26f52897117e3ea5b6c609a3d4bf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c129ea7ec110d1c9f5e1c7b8f274fe7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a7c129ea7ec110d1c9f5e1c7b8f274fe7">FailHijackedSendMessage</a> ()=0</td></tr>
<tr class="memdesc:a7c129ea7ec110d1c9f5e1c7b8f274fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">On a hijacked RPC/ to-be hijacked RPC, this can be called to fail a SEND MESSAGE op.  <a href="classgrpc_1_1experimental_1_1_interceptor_batch_methods.html#a7c129ea7ec110d1c9f5e1c7b8f274fe7">More...</a><br /></td></tr>
<tr class="separator:a7c129ea7ec110d1c9f5e1c7b8f274fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that is passed as an argument to the <em>Intercept</em> method of the application's <em><a class="el" href="classgrpc_1_1experimental_1_1_interceptor.html" title="Interface for an interceptor.">Interceptor</a></em> interface implementation. </p>
<p>It has five purposes:</p><ol type="1">
<li>Indicate which hook points are present at a specific interception</li>
<li>Allow an interceptor to inform the library that an RPC should continue to the next stage of its processing (which may be another interceptor or the main path of the library)</li>
<li>Allow an interceptor to hijack the processing of the RPC (only for client-side RPCs with PRE_SEND_INITIAL_METADATA) so that it does not proceed with normal processing beyond that stage</li>
<li>Access the relevant fields of an RPC at each interception point</li>
<li>Set some fields of an RPC at each interception point, when possible </li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a55f28c464881763e44c003ad945395a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f28c464881763e44c003ad945395a5">&#9670;&nbsp;</a></span>~InterceptorBatchMethods()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual grpc::experimental::InterceptorBatchMethods::~InterceptorBatchMethods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d26f52897117e3ea5b6c609a3d4bf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d26f52897117e3ea5b6c609a3d4bf91">&#9670;&nbsp;</a></span>FailHijackedRecvMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc::experimental::InterceptorBatchMethods::FailHijackedRecvMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On a hijacked RPC, an interceptor can decide to fail a PRE_RECV_MESSAGE op. </p>
<p>This would be a signal to the reader that there will be no more messages, or the stream has failed or been cancelled. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a52b92d9e8e32f32ce97b4a8f235f595d">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a858b697d346ec52019f43b4beaa64f5b">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a7c129ea7ec110d1c9f5e1c7b8f274fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c129ea7ec110d1c9f5e1c7b8f274fe7">&#9670;&nbsp;</a></span>FailHijackedSendMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc::experimental::InterceptorBatchMethods::FailHijackedSendMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On a hijacked RPC/ to-be hijacked RPC, this can be called to fail a SEND MESSAGE op. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a08cd8fac7808b9a392a5382a13e8e01e">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#aba5ce9ff94d19be8152dfca04dfd8c9c">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a993f12c0d1a9e5dce038b66c58728e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a993f12c0d1a9e5dce038b66c58728e82">&#9670;&nbsp;</a></span>GetInterceptedChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classgrpc_1_1_channel_interface.html">ChannelInterface</a>&gt; grpc::experimental::InterceptorBatchMethods::GetInterceptedChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an intercepted channel. </p>
<p>When a call is started on this interceptor, only interceptors after the current interceptor are created from the factory objects registered with the channel. This allows calls to be started from interceptors without infinite regress through the interceptor list. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a5103bca2f3826d43182436e3e736bd7b">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a1e23ff14548292c4ae13e383d0232800">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a8f123307653591e63ded55d8cea9ad8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f123307653591e63ded55d8cea9ad8b">&#9670;&nbsp;</a></span>GetRecvInitialMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::multimap&lt;<a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>, <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>&gt;* grpc::experimental::InterceptorBatchMethods::GetRecvInitialMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifiable multimap of the received initial metadata. </p>
<p>Valid for PRE_RECV_INITIAL_METADATA and POST_RECV_INITIAL_METADATA interceptions; nullptr if not valid </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a1f7cb8407197de0a0d179ed94d1d5b25">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a74068ad08786cda92a3c53d8561c6646">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a3b267515d6afd29afadba454aa913505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b267515d6afd29afadba454aa913505">&#9670;&nbsp;</a></span>GetRecvMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* grpc::experimental::InterceptorBatchMethods::GetRecvMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the modifiable received message. </p>
<p>Note that the message is already deserialized but the type is not set; the interceptor should static_cast to the appropriate type before using it. This is valid for PRE_RECV_MESSAGE and POST_RECV_MESSAGE interceptions; nullptr for not valid </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a12909a13d7cecdceeffc794c06ff6896">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a4f8a66ad270d639eec1228205c4bc812">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="ac60304da4f2c2737bcc259bac19e858d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60304da4f2c2737bcc259bac19e858d">&#9670;&nbsp;</a></span>GetRecvStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgrpc_1_1_status.html">Status</a>* grpc::experimental::InterceptorBatchMethods::GetRecvStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifiable view of the received status on PRE_RECV_STATUS and POST_RECV_STATUS interceptions; nullptr if not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a3ce51320fa84af6b2a00815305257b4e">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a37e9cdd09aa90c5c54eb5ba3387d179d">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a661e6372647f1639783b046d728599fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661e6372647f1639783b046d728599fa">&#9670;&nbsp;</a></span>GetRecvTrailingMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::multimap&lt;<a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>, <a class="el" href="classgrpc_1_1string__ref.html">grpc::string_ref</a>&gt;* grpc::experimental::InterceptorBatchMethods::GetRecvTrailingMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifiable multimap of the received trailing metadata on PRE_RECV_STATUS and POST_RECV_STATUS interceptions; nullptr if not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a4dc85e0f1a3cdb0c95f04994d443f81f">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#afe82d67dfd4604d3e97c5fa12392058d">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a82e59b73b516366438ee6c01d4198d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e59b73b516366438ee6c01d4198d4b">&#9670;&nbsp;</a></span>GetSendInitialMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::multimap&lt;std::string, std::string&gt;* grpc::experimental::InterceptorBatchMethods::GetSendInitialMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifiable multimap of the initial metadata to be sent. </p>
<p>Valid for PRE_SEND_INITIAL_METADATA interceptions. A value of nullptr indicates that this field is not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a60e36e8c2f163923c1a355ce79b37cda">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a80f87ee0eb65086c6e7afd350ec2e1b6">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a416033d4bab32f333d54f3da9a21b68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416033d4bab32f333d54f3da9a21b68b">&#9670;&nbsp;</a></span>GetSendMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* grpc::experimental::InterceptorBatchMethods::GetSendMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-modifiable pointer to the non-serialized form of the message to be sent. </p>
<p>Valid for PRE_SEND_MESSAGE interceptions. A return value of nullptr indicates that this field is not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a82b2071f39325cee162a7e98cf384c7f">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a7953731b656ad92ebbf7ec89d087038a">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a9381ac548c5ac6ae17af025f9261f9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9381ac548c5ac6ae17af025f9261f9ef">&#9670;&nbsp;</a></span>GetSendMessageStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool grpc::experimental::InterceptorBatchMethods::GetSendMessageStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the SEND MESSAGE op succeeded. </p>
<p>Valid for POST_SEND_MESSAGE interceptions. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a683bb3299153d8f662c0ac8ebfce8024">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a89834fc2a165c9b2231382dc986c66ae">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a2792ab543f8b46262ee6e69289b436ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2792ab543f8b46262ee6e69289b436ab">&#9670;&nbsp;</a></span>GetSendStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgrpc_1_1_status.html">Status</a> grpc::experimental::InterceptorBatchMethods::GetSendStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the status to be sent. Valid for PRE_SEND_STATUS interceptions. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a847d3514928d17070c30430fcbf9630c">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a2973701f908f54161019ab84451a08b5">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a22943cffc568734c939df8157b10f4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22943cffc568734c939df8157b10f4f9">&#9670;&nbsp;</a></span>GetSendTrailingMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::multimap&lt;std::string, std::string&gt;* grpc::experimental::InterceptorBatchMethods::GetSendTrailingMetadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a modifiable multimap of the trailing metadata to be sent. </p>
<p>Valid for PRE_SEND_STATUS interceptions. A value of nullptr indicates that this field is not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a6e366de05bac82cccbd0de4edb5ca436">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a48dc217bce0e86049925189c6b2f5d9e">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a1fa1f2c7437b6d49ef68af8e772625e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa1f2c7437b6d49ef68af8e772625e4">&#9670;&nbsp;</a></span>GetSerializedSendMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgrpc_1_1_byte_buffer.html">ByteBuffer</a>* grpc::experimental::InterceptorBatchMethods::GetSerializedSendMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send Message Methods GetSerializedSendMessage and GetSendMessage/ModifySendMessage are the available methods to view and modify the request payload. </p>
<p>An interceptor can access the payload in either serialized form or non-serialized form but not both at the same time. gRPC performs serialization in a lazy manner, which means that a call to GetSerializedSendMessage will result in a serialization operation if the payload stored is not in the serialized form already; the non-serialized form will be lost and GetSendMessage will no longer return a valid pointer, and this will remain true for later interceptors too. This can change however if ModifySendMessage is used to replace the current payload. Note that ModifySendMessage requires a new payload message in the non-serialized form. This will overwrite the existing payload irrespective of whether it had been serialized earlier. Also note that gRPC Async API requires early serialization of the payload which means that the payload would be available in the serialized form only unless an interceptor replaces the payload with ModifySendMessage. Returns a modifable <a class="el" href="classgrpc_1_1_byte_buffer.html" title="A sequence of bytes.">ByteBuffer</a> holding the serialized form of the message that is going to be sent. Valid for PRE_SEND_MESSAGE interceptions. A return value of nullptr indicates that this <a class="el" href="classgrpc_1_1_byte_buffer.html" title="A sequence of bytes.">ByteBuffer</a> is not valid. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a3368ae4a100d210716414bf1dc57f5cd">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#ad1a9c7433ed82c01413a6cd6b0a5ac60">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="aea0a9629eb5c5aa8760d5a02fd2ef37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0a9629eb5c5aa8760d5a02fd2ef37f">&#9670;&nbsp;</a></span>Hijack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc::experimental::InterceptorBatchMethods::Hijack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate that the interceptor has hijacked the RPC (only valid if the batch contains send_initial_metadata on the client side). </p>
<p>Later interceptors in the interceptor list will not be called. Later batches on the same RPC will go through interception, but only up to the point of the hijacking interceptor. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a4ffe4ff4ddbecd1f3b735d25fc99b028">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#ae8fab5a87b44a734e6c627bfaebfde95">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a6be8b4eecdd2ddf3913369dd3b275d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be8b4eecdd2ddf3913369dd3b275d43">&#9670;&nbsp;</a></span>ModifySendMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc::experimental::InterceptorBatchMethods::ModifySendMessage </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrites the message to be sent with <em>message</em>. </p>
<p><em>message</em> should be in the non-serialized form expected by the method. Valid for PRE_SEND_MESSAGE interceptions. Note that the interceptor is responsible for maintaining the life of the message till it is serialized or it receives the POST_SEND_MESSAGE interception point, whichever happens earlier. The modifying interceptor may itself force early serialization by calling GetSerializedSendMessage. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#ac34992ed34f75aae9b64cd62ae94f249">grpc::internal::InterceptorBatchMethodsImpl</a>, and <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#a3cde40872d7f653148cd34c29219b0c5">grpc::internal::CancelInterceptorBatchMethods</a>.</p>

</div>
</div>
<a id="a541b5d8a424e703d562a32c27488ccf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541b5d8a424e703d562a32c27488ccf2">&#9670;&nbsp;</a></span>ModifySendStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc::experimental::InterceptorBatchMethods::ModifySendStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgrpc_1_1_status.html">Status</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrites the status with <em>status</em>. </p>
<p>Valid for PRE_SEND_STATUS interceptions. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a5a559be4bbe86452fbb1ecd77141b0f8">grpc::internal::InterceptorBatchMethodsImpl</a>, and <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#aebd80df936f4275f01c03945354f11ab">grpc::internal::CancelInterceptorBatchMethods</a>.</p>

</div>
</div>
<a id="a640e84ae950a57b875b38de6ef9d87fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640e84ae950a57b875b38de6ef9d87fe">&#9670;&nbsp;</a></span>Proceed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void grpc::experimental::InterceptorBatchMethods::Proceed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signal that the interceptor is done intercepting the current batch of the RPC. </p>
<p>Every interceptor must either call Proceed or Hijack on each interception. In most cases, only Proceed will be used. Explicit use of Proceed is what enables interceptors to delay the processing of RPCs while they perform other work. Proceed is a no-op if the batch contains PRE_SEND_CANCEL. Simply returning from the Intercept method does the job of continuing the RPC in this case. This is because PRE_SEND_CANCEL is always in a separate batch and is not allowed to be delayed. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#ae54b9b17705512879fd05fa7c6ca57db">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a37bf16655256d3f296a6ca04eafed0bd">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<a id="a68758f2d57120220e53bcc6ad1bc8c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68758f2d57120220e53bcc6ad1bc8c71">&#9670;&nbsp;</a></span>QueryInterceptionHookPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool grpc::experimental::InterceptorBatchMethods::QueryInterceptionHookPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegrpc_1_1experimental.html#a03d3481b2c4146f53e90966d4a0fd8a1">InterceptionHookPoints</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the current batch has an interception hook point of type <em>type</em>. </p>

<p>Implemented in <a class="el" href="classgrpc_1_1internal_1_1_cancel_interceptor_batch_methods.html#ab5efa6c1ab93ca3a5ee46cff63f87b76">grpc::internal::CancelInterceptorBatchMethods</a>, and <a class="el" href="classgrpc_1_1internal_1_1_interceptor_batch_methods_impl.html#a0093ac4ad56f3d8e96c87545f29329a1">grpc::internal::InterceptorBatchMethodsImpl</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/grpcpp/support/<a class="el" href="support_2interceptor_8h_source.html">interceptor.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 9 2023 01:03:05 for GRPC C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
