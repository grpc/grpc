# Grpc.Tools MSBuild integration overview

This is an overview for maintainers of Grpc.Tools.

The Grpc.Tools NuGet package provides custom build targets to make it easier to specify ._proto_ files
in a project and for those files to be compiled and their generated files to be included in the project.

# Files in the NuGet package

## .props and .target files

MSBuild properties and targets included from the Grpc.Tools NuGet package are in:

* _build\Grpc.Tools.props_, which imports
    * _build\_grpc\_Grpc.Tools.props_
    * _build\_protobuf\Google.Protobuf.Tools.props_
* _build\Grpc.Tools.targets_, which imports
    * _build\_grpc\_Grpc.Tools.targets_
    * _build\_protobuf\Google.Protobuf.Tools.targets_

Details of how NuGet packages can add custom build targets and properties to a project is documented
here: [MSBuild .props and .targets in a package](https://learn.microsoft.com/en-us/nuget/concepts/msbuild-props-and-targets)

Basically the ._props_ and ._target_ files are automatically included in the projects - the ._props_ at the top
of the project and the ._targets_ are added to the bottom of the project.

## Visual Studio property pages

For Visual Studio integration - these files provide the properties pages:

* _build\_protobuf\Protobuf.CSharp.xml_ (included from _Google.Protobuf.Tools.targets_)
* _build\_grpc\Grpc.CSharp.xml_ (included from __Grpc.Tools.targets_)

## Custom tasks DLLs

DLLs containing the custom tasks are in:

* _build\_protobuf\netstandard1.3_
* _Build\_protobuf\net45_

## Protobuf compiler and C# gRPC plugin binaries

Native binary executables for the protobuf compiler (_protoc_) and C# gRPC plugin (_grpc_csharp_plugin_) are
included in the NuGet package. Included are binaries for various OSes (Windows, Linux, macOS) and
CPU architectures (x86, x64, arm64).

The custom targets will workout which ones to use for the particular machine that the build is being run on.
These can be overridden by specifying MSBuild properties or environment variables to give the paths to custom tools:

* _Protobuf_ProtocFullPath_ property or _PROTOBUF_PROTOC_ environment variable \
Full path of protoc executable
* _gRPC_PluginFullPath_ or _GRPC_PROTOC_PLUGIN_ environment variable \
Full path of gRPC C# plugin

# Grpc.Tools custom build targets

## Hooking the custom targets into the project build

The custom targets hook into various places in a normal MSBuild build by specifying
before/after targets at the relevant places. See
[msbuild-targets](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-targets)
for predefined targets.

* Before _PrepareForBuild_
    * we add Protobuf_SanityCheck that checks this is a supported project type, e.g. a C# project.
* Before _BeforeCompile_
    * we add all the targets that compile the ._proto_ files and generate the expected ._cs_ files. These files are added to those that get compiled by the C# compiler.
* After _CoreClean_
    * we add Protobuf_Clean that cleans the files generated by the protobuf compiler.

## Custom tasks

There are a few custom tasks needed by the targets. These are implemented in C# in the Grpc.Tools project
and packaged in the file _Protobuf.MSBuild.dll_ in the NuGet package.

* ProtoToolsPlatform
    * Works out the operating system and CPU architecture
* ProtoCompilerOutputs
    * Tries to work out the names and paths of the files that would be generated by the protobuf compiler and returns these as a list of _items_
    * Also returns list of _items _that is the same as the _Protobuf_ items passed in with the output directory metadata updated
* ProtoReadDependencies
    * Read generated files from previously written dependencies file and return as items.
* ProtoCompile
    * Runs the protobuf compiler for a proto file. The executable to run is specified by the property _Protobuf_ProtocFullPath_
    * To do this it:
        * first writes out a response file containing the parameters for protobuf compiler 
        * runs the executable, which generates the ._cs_ files and a ._protodep_ dependencies file
        * reads the dependencies file to find the files that were generated and these are returned as a list of _items_ that can then be used in the MSBuild targets

## Build steps

The names of these items and properties are correct at the time of writing this document.

High level builds steps:

* Prepare list of _.proto_ files to compile
    * Making sure metadata set
    * Removing items that no longer exist or are marked as don’t compile
* Handling incremental builds
    * Work out files that need to be created or have changed
* Compile the _.proto_ files
* Add generated files to the list of files for the C# compiler


### Prepare the list of .proto files to compile

At various stages of the build copies of the original _&lt;Protobuf>_ items are created
and/or updated to set metadata and to prune out unwanted items.

Make sure _ProtoRoot_ metadata is set for all _Protobuf_ items.
A new list of items - _Protobuf_Rooted_ - is created from the _Protobuf_ items with _ProtoRoot_ metadata set

* Either already explicitly set in the item
* Or “.” if in project directory
* Or relative path to project directory

Now prune out from _Protobuf_Rooted_ the items that the user doesn’t want to compile - those don’t have
_ProtoCompile_ metadata as _‘true’_.  The pruned list is now called _Protobuf_Compile_.

Set the _Source_ metadata on _Protobuf_Compile_ items to be the name of the ._proto_ file.
The _Source_ metadata is used later as a key to map generated files to ._proto_ files.

### Handling incremental builds


#### Gathering files to check for incremental builds

The target _Protobuf_PrepareCompile _tries to work out which files the protobuf compiler will generate without actually calling the protobuf compiler. This is a best-effort guess. The custom task _ProtoCompilerOutputs _is called to do this. The results are stored in the item list _Protobuf_ExpectedOutputs_.

The target _Protobuf_PrepareCompile _also reads previously written ._protodep_ files to get any  actual files previously generated. The custom task _ProtoReadDependencies _is called to do this. The results are stored in the item list _Protobuf_Dependencies_.  This is in case the list of actual files is different from the previous best-effort guess from _ProtoCompilerOutputs_.

The expected outputs and previous outputs are needed so that the timestamps of those files can be checked later when handling an incremental build.


#### Understanding incremental builds

To avoid unnecessarily recompiling the ._proto_ files during an incremental build the target __Protobuf_GatherStaleBatched_ tries to work out if any files have changed.

It checks for out of date files using MSBuilds incremental build feature that compares the timestamps on a target’s _Input _files to its _Output _files. See [How to: Build incrementally](https://learn.microsoft.com/en-us/visualstudio/msbuild/how-to-build-incrementally)

The _Inputs _that are checked are:



* Timestamps of the ._proto_ files
* Timestamps of previously generated files (list of these files read from ._protodep_ files)
* Timestamps of MSBuild project files

These are checked against the _Outputs_:



* Timestamps of the expected generated files

[MSBuild target batching](https://learn.microsoft.com/en-us/visualstudio/msbuild/item-metadata-in-target-batching) is used to check each ._proto_ file against its expected outputs. The batching is done by specifying the _Source _metadata in the _Input_. Items where _Source_ metadata matches in both input and output are in each batch.

 The target __Protobuf_GatherStaleBatched_ sets the metadata __Exec=true_ on __Protobuf_OutOfDateProto _items that are out of date.

Later in the target __Protobuf_GatherStaleFiles_,_ _the items in __Protobuf_OutOfDateProto_ that don’t have metadata __Exec==true_ are removed from the list of items, leaving only those that need compiling.


### <span style="text-decoration:underline;">Compile the .proto files</span>

The target __Protobuf_CoreCompile _is run for each .proto file that needs compiling. These are in the item list __Protobuf_OutOfDateProto_. The custom task _ProtoCompile _is called to run the protobuf compiler. The files that were generated are returned in the item list __Protobuf_GeneratedFiles_.

If there are expected files that were not actually generated then the behaviour depends on whether the generated files should have been within the project (e.g. in the intermediate directories) or were specified to be outside of the project.



* If within the project - empty files are created to prevent incremental builds doing unnecessary recompiles
* If outside the project - by default empty files are not created and a warning is output (this behaviour is configurable)


### <span style="text-decoration:underline;">Add generated .cs files to the list of files for the C# compiler</span>

The target __Protobuf_AugmentLanguageCompile _adds to the _Compile_ item list (the list of files that CSC compiles) the expected generated files.

**Note **- this is the _expected _files not the _actual _generated files and this is done before the protobuf compiler is called. (why?)


## Handling design time builds

Design-time builds are special builds that Visual Studio uses to gather information about the project. They are not user-initiated but may be triggered whenever files are added, removed or saved. See [Design-Time Builds](https://github.com/dotnet/project-system/blob/main/docs/design-time-builds.md).

The Grpc.Tools build targets used to try and optimise design time builds by disabling calling the protobuf compiler during a design time build.  However this optimisation can lead to errors in Visual Studio because the generated files may not exist or be out of date and any code that relies on them will then have errors.

Now design time builds behave exactly the same as a normal build. The old behaviour can be enabled by setting the setting _DisableProtobufDesignTimeBuild_ property to _true_ in the project file **_if _**it is a design time build, e.g. by adding


```
<PropertyGroup Condition="'$(DesignTimeBuild)' == 'true' ">
    <DisableProtobufDesignTimeBuild>true</DisableProtobufDesignTimeBuild>
</PropertyGroup>
```



## Automatically including .proto files

For SDK projects it is possible to automatically include ._proto_ files found in the project directory or sub-directories, without having to specify them with a_ &lt;Protobuf>_ item. To do this the property _EnableDefaultProtobufItems _has be set to _‘true’_ in the project file.

By default it is not set and _&lt;Protobuf>_ items must be included in the project for the ._proto_ files to be compiled.
