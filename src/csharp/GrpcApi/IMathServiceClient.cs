using System;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Reactive.Linq;

namespace Google.GRPC.Examples.Math
{

	/// <summary>
	/// Hand-written stub for MathService defined in math.proto.
	/// This code will be generated by gRPC codegen in the future.
	/// </summary>
	public interface IMathServiceClient
	{

		// possibly use Thread.interrupt to trigger cancellation?
		DivReply Div(DivArgs args);


		// statuses different from OK are thrown as an exception....
		Task<DivReply> DivAsync(DivArgs args);

		// token is here to support cancellation
		Task<DivReply> DivAsync(DivArgs args, CancellationToken token);        

		IObservable<Number> Fib(FibArgs args);

		IObservable<Number> Fib(FibArgs args, CancellationToken token);        


		// Cancellation is can be done through inputs.OnError
		Task<Number> Sum(out IObserver<Number> inputs);

		Task<Number> Sum(out IObserver<Number> inputs, CancellationToken token);


		// Cancellation is can be done through inputs.OnError
		IObservable<DivReply> DivMany(out IObserver<DivArgs> inputs);

		IObservable<DivReply> DivMany(out IObserver<DivArgs> inputs, CancellationToken token);
	}

	public class DummyMathServiceClient : IMathServiceClient
	{
	
		// possibly use Thread.interrupt to trigger cancellation?
		public DivReply Div(DivArgs args)
		{
			return DivInternal (args);
		}

		// statuses different from OK are thrown as an exception....
		public Task<DivReply> DivAsync(DivArgs args)
		{
			return Task.Factory.StartNew (() => DivInternal(args));
		}

		// token is here to support cancellation
		public Task<DivReply> DivAsync(DivArgs args, CancellationToken token)
		{
			return Task.Factory.StartNew (() => DivInternal(args), token);
		}

		public IObservable<Number> Fib(FibArgs args)
		{
			if (args.Limit > 0) {
				return FibInternal(args.Limit).ToObservable();
			}

			throw new NotImplementedException ("Not implemented yet");
		}

		public IObservable<Number> Fib(FibArgs args, CancellationToken token)
		{
			if (args.Limit > 0) {
				// TODO: cancellation
				return FibInternal(args.Limit).ToObservable();
			}
			throw new NotImplementedException ("Not implemented yet");
		}
		

		// Cancellation is can be done through inputs.OnError
		public Task<Number> Sum(out IObserver<Number> inputs)
		{
			// TODO: implement
			inputs = null;
			return Task.Factory.StartNew (() => new Number());
		}

		public Task<Number> Sum(out IObserver<Number> inputs, CancellationToken token)
		{
			// TODO: implement
			inputs = null;
			return Task.Factory.StartNew (() => new Number());
		}


		// Cancellation is can be done through inputs.OnError
		public IObservable<DivReply> DivMany(out IObserver<DivArgs> inputs)
		{
			// TODO: implement
			inputs = null;
			return new List<DivReply> { }.ToObservable ();
		}

		public IObservable<DivReply> DivMany(out IObserver<DivArgs> inputs, CancellationToken token) {
			// TODO: implement
			inputs = null;
			return new List<DivReply> { }.ToObservable ();
		}


		DivReply DivInternal(DivArgs args)
		{
			long quotient = args.Dividend / args.Divisor;
			long remainder = args.Dividend % args.Divisor;
			return new DivReply { Quotient = quotient, Remainder = remainder };
		}

		IEnumerable<Number> FibInternal(long n) {
			long a = 0;
			yield return new Number{Num=a};

			long b = 1;
			for (long i = 0; i < n - 1; i++)
			{
				long temp = a;
				a = b;
				b = temp + b;
				yield return new Number{Num=a};
			}
		}
	}
}