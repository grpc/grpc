/*
*
* Copyright 2015 gRPC authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/

// Generates cpp gRPC service interface out of Protobuf IDL.
//

#include "src/compiler/config.h"
#include "src/compiler/generator_helpers.h"
#include "src/compiler/protobuf_plugin.h"






static void GenerateService(const std::string &module , CodedOutputStream &cos,const ServiceDescriptor *service)
{
	/// client
	cos.WriteString("class " + service->name() + "Client\n");
	cos.WriteString("{\n");
	cos.WriteString("\tthis(Channel channel)\n");
	cos.WriteString("\t{\n");
	cos.WriteString("\t\t_channel = channel;\n");
	cos.WriteString("\t}\n");
	cos.WriteString("\n");


	/// client's methods
	for (size_t i = 0; i < service->method_count(); i++)
	{
		auto m = service->method(i);
		auto res = m->output_type()->name();
		auto req = m->input_type()->name();
		auto func = m->name();

		cos.WriteString("\t" + res + " " + func + "( " + req + " request)\n");
		cos.WriteString("\t{\n");
		cos.WriteString("\t\tmixin(CM!(HelloReply , GreeterBase.SERVICE));\n");
		cos.WriteString("\t}\n");

		cos.WriteString("\n");

		cos.WriteString("\tvoid " + func + "( " + req + " request , void delegate(Result!" + res + " reply) dele)\n");
		cos.WriteString("\t{\n");
		cos.WriteString("\t\tmixin(CMA!(HelloReply , GreeterBase.SERVICE));\n");
		cos.WriteString("\t}\n");

		cos.WriteString("\n");

	}
	cos.WriteString("\n");
	cos.WriteString("\tprivate:\n");
	cos.WriteString("\tChannel _channel;\n");

	cos.WriteString("}\n");
	cos.WriteString("\n");


	/// service
	cos.WriteString("class " + service->name() + "Base: GrpcService\n");
	cos.WriteString("{\n");
	cos.WriteString("\tenum SERVICE  = \"" + module + "." + service->name() + "\";");
	cos.WriteString("\n");
	cos.WriteString("\tstring getModule()\n");
	cos.WriteString("\t{\n");
	cos.WriteString("\t\treturn SERVICE;\n");
	cos.WriteString("\t}\n");
	cos.WriteString("\n");

	/// service's methods
	for(size_t i = 0 ; i < service->method_count() ; i++)
	{
		auto m = service->method(i);
		auto res = m->output_type()->name();
		auto req = m->input_type()->name();
		auto func = m->name();
		cos.WriteString("\t" + res + " " + func + "(" + req + " ){ return new " + res + "(); }\n");
	}

	cos.WriteString("\n");
	
	/// service's process
	cos.WriteString("\tubyte[] process(string method , ubyte[] data)\n");
	cos.WriteString("\t{\n");
	cos.WriteString("\t\tswitch(method)\n");
	cos.WriteString("\t\t{\n");
	for (size_t i = 0; i < service->method_count(); i++)
	{
		auto m = service->method(i);
		auto res = m->output_type()->name();
		auto req = m->input_type()->name();
		auto func = m->name();
		cos.WriteString("\t\t\tmixin(SM!(" + req + " , \"" + func + "\"));\n");
		cos.WriteString("\n");
	}				
	
	cos.WriteString("\t\t\tdefault:\n");
	cos.WriteString("\t\t\tlogWarning(\"none method \", method);\n");
	cos.WriteString("\t\t\t\treturn null;\n");
	cos.WriteString("\t\t}\n");
	cos.WriteString("\t\}\n");
	
	cos.WriteString("}\n");
}


class DlangGrpcGenerator : public grpc::protobuf::compiler::CodeGenerator {
public:
	DlangGrpcGenerator() {}
	virtual ~DlangGrpcGenerator() {}

	virtual bool Generate(const grpc::protobuf::FileDescriptor* file,
		const grpc::string& parameter,
		grpc::protobuf::compiler::GeneratorContext* context,
		grpc::string* error) const {
		
		if (file->syntax() != grpc::protobuf::FileDescriptor::Syntax::SYNTAX_PROTO3)
		{
			*error = "dlang_plugin only support proto3";
			return false;
		}

		/// filename
		grpc::string filename = grpc_generator::StripProto(file->name());
		CodedOutputStream cos(context->Open(filename + "rpc.d"));
		/// module
		{	
			grpc::string module = "module " + file->package() + "." + filename + "rpc;\n";
			cos.WriteString(module);
		}

		cos.WriteString("\n\n");

		/// 
		{
			cos.WriteString("// Generated by the gRPC dlang plugin.\n");
			cos.WriteString("// If you make any local change, they will be lost.\n");
		}

		cos.WriteString("\n\n");

		/// import fixed file
		{
			cos.WriteString("import " + file->package() + "." + filename + ";\n");
			cos.WriteString("import std.array;\n");
			cos.WriteString("public import hunt.net.Result;\n");
			cos.WriteString("import grpc;\n");
			cos.WriteString("import google.protobuf;\n");
			cos.WriteString("import kiss.logger;\n");
		}

		cos.WriteString("\n\n");

		/// import dep next
		for(size_t i = 0 ; i < file->dependency_count() ; i++ )
		{
			auto dep = file->dependency(i);
			cos.WriteString("import " + dep->package() + "." + grpc_generator::StripProto(dep->name()) + ";\n");
		}

		cos.WriteString("\n\n");

		/// import public dep next
		{
			for (size_t i = 0; i < file->public_dependency_count(); i++)
			{
				auto dep = file->public_dependency(i);
				cos.WriteString("public import " + dep->package() + "." + grpc_generator::StripProto(dep->name()) + ";\n");
			}
		}

		/// service
		for(size_t i = 0 ; i < file->service_count() ; i++)
		{
			GenerateService(file->package() , cos , file->service(i));
			cos.WriteString("\n\n");
		}


		return true;
	}

};

int main(int argc, char* argv[]) {
	DlangGrpcGenerator generator;
	return grpc::protobuf::compiler::PluginMain(argc, argv, &generator);
}
