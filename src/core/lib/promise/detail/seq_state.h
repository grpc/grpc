// Copyright 2023 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef GRPC_SRC_CORE_LIB_PROMISE_DETAIL_SEQ_STATE_H
#define GRPC_SRC_CORE_LIB_PROMISE_DETAIL_SEQ_STATE_H

// This file is generated by tools/codegen/core/gen_seq_state.py

#include "src/core/lib/promise/detail/promise_factory.h"
#include "src/core/lib/promise/detail/promise_like.h"

namespace grpc_core {
namespace promise_detail {
template <template <typename> class Traits, typename P, typename... Fs>
struct SeqState;

template <template <typename> class Traits, typename P, typename F0>
struct SeqState<Traits, P, F0> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;
  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using Result = typename PromiseResultTraits1::WrappedType;
  struct Running0 {
    Promise0 current_promise;
    NextFactory0 next_factory;
  };
  union {
    Running0 prior;
    Promise1 current_promise;
  };
  enum class State : uint8_t { kState0, kState1 };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;

  SeqState(P&& p, F0&& f0) noexcept {
    Construct(&prior.current_promise, std::forward<P>(p));
    Construct(&prior.next_factory, std::forward<F0>(f0));
  }
  ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.next_factory);
  }
  SeqState(const SeqState& other) = delete;
  SeqState& operator=(const SeqState& other) = delete;
  SeqState(SeqState&& other) noexcept : state(other.state) {
    switch (state) {
      case State::kState0:
        Construct(&prior.current_promise,
                  std::move(other.prior.current_promise));
        goto tail0;
      case State::kState1:
        Construct(&current_promise, std::move(other.current_promise));
        return;
    }
  tail0:
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  SeqState& operator=(SeqState&& other) = delete;
  Poll<Result> PollOnce() {
    switch (state) {
      case State::kState0: {
        auto result = prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState0;
          return Pending{};
        }
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
      }
        state = State::kState1;
      case State::kState1: {
        auto result = current_promise();
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1>
struct SeqState<Traits, P, F0, F1> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;
  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;
  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using Result = typename PromiseResultTraits2::WrappedType;
  struct Running0 {
    Promise0 current_promise;
    NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      Running0 prior;
      Promise1 current_promise;
    };
    NextFactory1 next_factory;
  };
  union {
    Running1 prior;
    Promise2 current_promise;
  };
  enum class State : uint8_t { kState0, kState1, kState2 };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;

  SeqState(P&& p, F0&& f0, F1&& f1) noexcept {
    Construct(&prior.prior.current_promise, std::forward<P>(p));
    Construct(&prior.prior.next_factory, std::forward<F0>(f0));
    Construct(&prior.next_factory, std::forward<F1>(f1));
  }
  ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.next_factory);
  tail1:
    Destruct(&prior.next_factory);
  }
  SeqState(const SeqState& other) = delete;
  SeqState& operator=(const SeqState& other) = delete;
  SeqState(SeqState&& other) noexcept : state(other.state) {
    switch (state) {
      case State::kState0:
        Construct(&prior.prior.current_promise,
                  std::move(other.prior.prior.current_promise));
        goto tail0;
      case State::kState1:
        Construct(&prior.current_promise,
                  std::move(other.prior.current_promise));
        goto tail1;
      case State::kState2:
        Construct(&current_promise, std::move(other.current_promise));
        return;
    }
  tail0:
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
  tail1:
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  SeqState& operator=(SeqState&& other) = delete;
  Poll<Result> PollOnce() {
    switch (state) {
      case State::kState0: {
        auto result = prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState0;
          return Pending{};
        }
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
      }
      case State::kState1: {
        auto result = prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState1;
          return Pending{};
        }
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
      }
        state = State::kState2;
      case State::kState2: {
        auto result = current_promise();
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2>
struct SeqState<Traits, P, F0, F1, F2> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;
  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;
  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;
  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using Result = typename PromiseResultTraits3::WrappedType;
  struct Running0 {
    Promise0 current_promise;
    NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      Running0 prior;
      Promise1 current_promise;
    };
    NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      Running1 prior;
      Promise2 current_promise;
    };
    NextFactory2 next_factory;
  };
  union {
    Running2 prior;
    Promise3 current_promise;
  };
  enum class State : uint8_t { kState0, kState1, kState2, kState3 };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;

  SeqState(P&& p, F0&& f0, F1&& f1, F2&& f2) noexcept {
    Construct(&prior.prior.prior.current_promise, std::forward<P>(p));
    Construct(&prior.prior.prior.next_factory, std::forward<F0>(f0));
    Construct(&prior.prior.next_factory, std::forward<F1>(f1));
    Construct(&prior.next_factory, std::forward<F2>(f2));
  }
  ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.next_factory);
  tail2:
    Destruct(&prior.next_factory);
  }
  SeqState(const SeqState& other) = delete;
  SeqState& operator=(const SeqState& other) = delete;
  SeqState(SeqState&& other) noexcept : state(other.state) {
    switch (state) {
      case State::kState0:
        Construct(&prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.current_promise));
        goto tail0;
      case State::kState1:
        Construct(&prior.prior.current_promise,
                  std::move(other.prior.prior.current_promise));
        goto tail1;
      case State::kState2:
        Construct(&prior.current_promise,
                  std::move(other.prior.current_promise));
        goto tail2;
      case State::kState3:
        Construct(&current_promise, std::move(other.current_promise));
        return;
    }
  tail0:
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
  tail1:
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
  tail2:
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  SeqState& operator=(SeqState&& other) = delete;
  Poll<Result> PollOnce() {
    switch (state) {
      case State::kState0: {
        auto result = prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState0;
          return Pending{};
        }
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState1: {
        auto result = prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState1;
          return Pending{};
        }
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
      }
      case State::kState2: {
        auto result = prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState2;
          return Pending{};
        }
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
      }
        state = State::kState3;
      case State::kState3: {
        auto result = current_promise();
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3>
struct SeqState<Traits, P, F0, F1, F2, F3> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;
  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;
  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;
  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;
  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using Result = typename PromiseResultTraits4::WrappedType;
  struct Running0 {
    Promise0 current_promise;
    NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      Running0 prior;
      Promise1 current_promise;
    };
    NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      Running1 prior;
      Promise2 current_promise;
    };
    NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      Running2 prior;
      Promise3 current_promise;
    };
    NextFactory3 next_factory;
  };
  union {
    Running3 prior;
    Promise4 current_promise;
  };
  enum class State : uint8_t { kState0, kState1, kState2, kState3, kState4 };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;

  SeqState(P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3) noexcept {
    Construct(&prior.prior.prior.prior.current_promise, std::forward<P>(p));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F0>(f0));
    Construct(&prior.prior.prior.next_factory, std::forward<F1>(f1));
    Construct(&prior.prior.next_factory, std::forward<F2>(f2));
    Construct(&prior.next_factory, std::forward<F3>(f3));
  }
  ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.next_factory);
  tail3:
    Destruct(&prior.next_factory);
  }
  SeqState(const SeqState& other) = delete;
  SeqState& operator=(const SeqState& other) = delete;
  SeqState(SeqState&& other) noexcept : state(other.state) {
    switch (state) {
      case State::kState0:
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.prior.current_promise));
        goto tail0;
      case State::kState1:
        Construct(&prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.current_promise));
        goto tail1;
      case State::kState2:
        Construct(&prior.prior.current_promise,
                  std::move(other.prior.prior.current_promise));
        goto tail2;
      case State::kState3:
        Construct(&prior.current_promise,
                  std::move(other.prior.current_promise));
        goto tail3;
      case State::kState4:
        Construct(&current_promise, std::move(other.current_promise));
        return;
    }
  tail0:
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
  tail1:
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
  tail2:
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
  tail3:
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  SeqState& operator=(SeqState&& other) = delete;
  Poll<Result> PollOnce() {
    switch (state) {
      case State::kState0: {
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState0;
          return Pending{};
        }
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState1: {
        auto result = prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState1;
          return Pending{};
        }
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState2: {
        auto result = prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState2;
          return Pending{};
        }
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
      }
      case State::kState3: {
        auto result = prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState3;
          return Pending{};
        }
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
      }
        state = State::kState4;
      case State::kState4: {
        auto result = current_promise();
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4>
struct SeqState<Traits, P, F0, F1, F2, F3, F4> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;
  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;
  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;
  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;
  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;
  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using Result = typename PromiseResultTraits5::WrappedType;
  struct Running0 {
    Promise0 current_promise;
    NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      Running0 prior;
      Promise1 current_promise;
    };
    NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      Running1 prior;
      Promise2 current_promise;
    };
    NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      Running2 prior;
      Promise3 current_promise;
    };
    NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      Running3 prior;
      Promise4 current_promise;
    };
    NextFactory4 next_factory;
  };
  union {
    Running4 prior;
    Promise5 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;

  SeqState(P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4) noexcept {
    Construct(&prior.prior.prior.prior.prior.current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F1>(f1));
    Construct(&prior.prior.prior.next_factory, std::forward<F2>(f2));
    Construct(&prior.prior.next_factory, std::forward<F3>(f3));
    Construct(&prior.next_factory, std::forward<F4>(f4));
  }
  ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.next_factory);
  tail4:
    Destruct(&prior.next_factory);
  }
  SeqState(const SeqState& other) = delete;
  SeqState& operator=(const SeqState& other) = delete;
  SeqState(SeqState&& other) noexcept : state(other.state) {
    switch (state) {
      case State::kState0:
        Construct(
            &prior.prior.prior.prior.prior.current_promise,
            std::move(other.prior.prior.prior.prior.prior.current_promise));
        goto tail0;
      case State::kState1:
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.prior.current_promise));
        goto tail1;
      case State::kState2:
        Construct(&prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.current_promise));
        goto tail2;
      case State::kState3:
        Construct(&prior.prior.current_promise,
                  std::move(other.prior.prior.current_promise));
        goto tail3;
      case State::kState4:
        Construct(&prior.current_promise,
                  std::move(other.prior.current_promise));
        goto tail4;
      case State::kState5:
        Construct(&current_promise, std::move(other.current_promise));
        return;
    }
  tail0:
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
  tail1:
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
  tail2:
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
  tail3:
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
  tail4:
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  SeqState& operator=(SeqState&& other) = delete;
  Poll<Result> PollOnce() {
    switch (state) {
      case State::kState0: {
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState0;
          return Pending{};
        }
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
      }
      case State::kState1: {
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState1;
          return Pending{};
        }
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState2: {
        auto result = prior.prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState2;
          return Pending{};
        }
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState3: {
        auto result = prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState3;
          return Pending{};
        }
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
      }
      case State::kState4: {
        auto result = prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState4;
          return Pending{};
        }
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
      }
        state = State::kState5;
      case State::kState5: {
        auto result = current_promise();
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5>
struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;
  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;
  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;
  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;
  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;
  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using NextFactory5 =
      OncePromiseFactory<typename PromiseResultTraits5::UnwrappedType, F5>;
  using Promise6 = typename NextFactory5::Promise;
  using PromiseResult6 = typename Promise6::Result;
  using PromiseResultTraits6 = Traits<PromiseResult6>;
  using Result = typename PromiseResultTraits6::WrappedType;
  struct Running0 {
    Promise0 current_promise;
    NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      Running0 prior;
      Promise1 current_promise;
    };
    NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      Running1 prior;
      Promise2 current_promise;
    };
    NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      Running2 prior;
      Promise3 current_promise;
    };
    NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      Running3 prior;
      Promise4 current_promise;
    };
    NextFactory4 next_factory;
  };
  struct Running5 {
    union {
      Running4 prior;
      Promise5 current_promise;
    };
    NextFactory5 next_factory;
  };
  union {
    Running5 prior;
    Promise6 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5,
    kState6
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;

  SeqState(P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4,
           F5&& f5) noexcept {
    Construct(&prior.prior.prior.prior.prior.prior.current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F1>(f1));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F2>(f2));
    Construct(&prior.prior.prior.next_factory, std::forward<F3>(f3));
    Construct(&prior.prior.next_factory, std::forward<F4>(f4));
    Construct(&prior.next_factory, std::forward<F5>(f5));
  }
  ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&prior.current_promise);
        goto tail5;
      case State::kState6:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.prior.next_factory);
  tail4:
    Destruct(&prior.prior.next_factory);
  tail5:
    Destruct(&prior.next_factory);
  }
  SeqState(const SeqState& other) = delete;
  SeqState& operator=(const SeqState& other) = delete;
  SeqState(SeqState&& other) noexcept : state(other.state) {
    switch (state) {
      case State::kState0:
        Construct(
            &prior.prior.prior.prior.prior.prior.current_promise,
            std::move(
                other.prior.prior.prior.prior.prior.prior.current_promise));
        goto tail0;
      case State::kState1:
        Construct(
            &prior.prior.prior.prior.prior.current_promise,
            std::move(other.prior.prior.prior.prior.prior.current_promise));
        goto tail1;
      case State::kState2:
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.prior.current_promise));
        goto tail2;
      case State::kState3:
        Construct(&prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.current_promise));
        goto tail3;
      case State::kState4:
        Construct(&prior.prior.current_promise,
                  std::move(other.prior.prior.current_promise));
        goto tail4;
      case State::kState5:
        Construct(&prior.current_promise,
                  std::move(other.prior.current_promise));
        goto tail5;
      case State::kState6:
        Construct(&current_promise, std::move(other.current_promise));
        return;
    }
  tail0:
    Construct(
        &prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.next_factory));
  tail1:
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
  tail2:
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
  tail3:
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
  tail4:
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
  tail5:
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  SeqState& operator=(SeqState&& other) = delete;
  Poll<Result> PollOnce() {
    switch (state) {
      case State::kState0: {
        auto result = prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState0;
          return Pending{};
        }
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
      }
      case State::kState1: {
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState1;
          return Pending{};
        }
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
      }
      case State::kState2: {
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState2;
          return Pending{};
        }
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState3: {
        auto result = prior.prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState3;
          return Pending{};
        }
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState4: {
        auto result = prior.prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState4;
          return Pending{};
        }
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
      }
      case State::kState5: {
        auto result = prior.current_promise();
        PromiseResult5* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState5;
          return Pending{};
        }
        if (!PromiseResultTraits5::IsOk(*p)) {
          return PromiseResultTraits5::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits5::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
      }
        state = State::kState6;
      case State::kState6: {
        auto result = current_promise();
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6>
struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;
  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;
  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;
  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;
  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;
  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using NextFactory5 =
      OncePromiseFactory<typename PromiseResultTraits5::UnwrappedType, F5>;
  using Promise6 = typename NextFactory5::Promise;
  using PromiseResult6 = typename Promise6::Result;
  using PromiseResultTraits6 = Traits<PromiseResult6>;
  using NextFactory6 =
      OncePromiseFactory<typename PromiseResultTraits6::UnwrappedType, F6>;
  using Promise7 = typename NextFactory6::Promise;
  using PromiseResult7 = typename Promise7::Result;
  using PromiseResultTraits7 = Traits<PromiseResult7>;
  using Result = typename PromiseResultTraits7::WrappedType;
  struct Running0 {
    Promise0 current_promise;
    NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      Running0 prior;
      Promise1 current_promise;
    };
    NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      Running1 prior;
      Promise2 current_promise;
    };
    NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      Running2 prior;
      Promise3 current_promise;
    };
    NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      Running3 prior;
      Promise4 current_promise;
    };
    NextFactory4 next_factory;
  };
  struct Running5 {
    union {
      Running4 prior;
      Promise5 current_promise;
    };
    NextFactory5 next_factory;
  };
  struct Running6 {
    union {
      Running5 prior;
      Promise6 current_promise;
    };
    NextFactory6 next_factory;
  };
  union {
    Running6 prior;
    Promise7 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5,
    kState6,
    kState7
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;

  SeqState(P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5,
           F6&& f6) noexcept {
    Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F1>(f1));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F2>(f2));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F3>(f3));
    Construct(&prior.prior.prior.next_factory, std::forward<F4>(f4));
    Construct(&prior.prior.next_factory, std::forward<F5>(f5));
    Construct(&prior.next_factory, std::forward<F6>(f6));
  }
  ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.prior.prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&prior.prior.current_promise);
        goto tail5;
      case State::kState6:
        Destruct(&prior.current_promise);
        goto tail6;
      case State::kState7:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail4:
    Destruct(&prior.prior.prior.next_factory);
  tail5:
    Destruct(&prior.prior.next_factory);
  tail6:
    Destruct(&prior.next_factory);
  }
  SeqState(const SeqState& other) = delete;
  SeqState& operator=(const SeqState& other) = delete;
  SeqState(SeqState&& other) noexcept : state(other.state) {
    switch (state) {
      case State::kState0:
        Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.prior.prior.prior.prior
                                .current_promise));
        goto tail0;
      case State::kState1:
        Construct(
            &prior.prior.prior.prior.prior.prior.current_promise,
            std::move(
                other.prior.prior.prior.prior.prior.prior.current_promise));
        goto tail1;
      case State::kState2:
        Construct(
            &prior.prior.prior.prior.prior.current_promise,
            std::move(other.prior.prior.prior.prior.prior.current_promise));
        goto tail2;
      case State::kState3:
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.prior.current_promise));
        goto tail3;
      case State::kState4:
        Construct(&prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.current_promise));
        goto tail4;
      case State::kState5:
        Construct(&prior.prior.current_promise,
                  std::move(other.prior.prior.current_promise));
        goto tail5;
      case State::kState6:
        Construct(&prior.current_promise,
                  std::move(other.prior.current_promise));
        goto tail6;
      case State::kState7:
        Construct(&current_promise, std::move(other.current_promise));
        return;
    }
  tail0:
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(
            other.prior.prior.prior.prior.prior.prior.prior.next_factory));
  tail1:
    Construct(
        &prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.next_factory));
  tail2:
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
  tail3:
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
  tail4:
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
  tail5:
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
  tail6:
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  SeqState& operator=(SeqState&& other) = delete;
  Poll<Result> PollOnce() {
    switch (state) {
      case State::kState0: {
        auto result =
            prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState0;
          return Pending{};
        }
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
      }
      case State::kState1: {
        auto result = prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState1;
          return Pending{};
        }
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
      }
      case State::kState2: {
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState2;
          return Pending{};
        }
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
      }
      case State::kState3: {
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState3;
          return Pending{};
        }
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState4: {
        auto result = prior.prior.prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState4;
          return Pending{};
        }
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState5: {
        auto result = prior.prior.current_promise();
        PromiseResult5* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState5;
          return Pending{};
        }
        if (!PromiseResultTraits5::IsOk(*p)) {
          return PromiseResultTraits5::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits5::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
      }
      case State::kState6: {
        auto result = prior.current_promise();
        PromiseResult6* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState6;
          return Pending{};
        }
        if (!PromiseResultTraits6::IsOk(*p)) {
          return PromiseResultTraits6::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits6::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
      }
        state = State::kState7;
      case State::kState7: {
        auto result = current_promise();
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

template <template <typename> class Traits, typename P, typename F0,
          typename F1, typename F2, typename F3, typename F4, typename F5,
          typename F6, typename F7>
struct SeqState<Traits, P, F0, F1, F2, F3, F4, F5, F6, F7> {
  using Promise0 = PromiseLike<P>;
  using PromiseResult0 = typename Promise0::Result;
  using PromiseResultTraits0 = Traits<PromiseResult0>;
  using NextFactory0 =
      OncePromiseFactory<typename PromiseResultTraits0::UnwrappedType, F0>;
  using Promise1 = typename NextFactory0::Promise;
  using PromiseResult1 = typename Promise1::Result;
  using PromiseResultTraits1 = Traits<PromiseResult1>;
  using NextFactory1 =
      OncePromiseFactory<typename PromiseResultTraits1::UnwrappedType, F1>;
  using Promise2 = typename NextFactory1::Promise;
  using PromiseResult2 = typename Promise2::Result;
  using PromiseResultTraits2 = Traits<PromiseResult2>;
  using NextFactory2 =
      OncePromiseFactory<typename PromiseResultTraits2::UnwrappedType, F2>;
  using Promise3 = typename NextFactory2::Promise;
  using PromiseResult3 = typename Promise3::Result;
  using PromiseResultTraits3 = Traits<PromiseResult3>;
  using NextFactory3 =
      OncePromiseFactory<typename PromiseResultTraits3::UnwrappedType, F3>;
  using Promise4 = typename NextFactory3::Promise;
  using PromiseResult4 = typename Promise4::Result;
  using PromiseResultTraits4 = Traits<PromiseResult4>;
  using NextFactory4 =
      OncePromiseFactory<typename PromiseResultTraits4::UnwrappedType, F4>;
  using Promise5 = typename NextFactory4::Promise;
  using PromiseResult5 = typename Promise5::Result;
  using PromiseResultTraits5 = Traits<PromiseResult5>;
  using NextFactory5 =
      OncePromiseFactory<typename PromiseResultTraits5::UnwrappedType, F5>;
  using Promise6 = typename NextFactory5::Promise;
  using PromiseResult6 = typename Promise6::Result;
  using PromiseResultTraits6 = Traits<PromiseResult6>;
  using NextFactory6 =
      OncePromiseFactory<typename PromiseResultTraits6::UnwrappedType, F6>;
  using Promise7 = typename NextFactory6::Promise;
  using PromiseResult7 = typename Promise7::Result;
  using PromiseResultTraits7 = Traits<PromiseResult7>;
  using NextFactory7 =
      OncePromiseFactory<typename PromiseResultTraits7::UnwrappedType, F7>;
  using Promise8 = typename NextFactory7::Promise;
  using PromiseResult8 = typename Promise8::Result;
  using PromiseResultTraits8 = Traits<PromiseResult8>;
  using Result = typename PromiseResultTraits8::WrappedType;
  struct Running0 {
    Promise0 current_promise;
    NextFactory0 next_factory;
  };
  struct Running1 {
    union {
      Running0 prior;
      Promise1 current_promise;
    };
    NextFactory1 next_factory;
  };
  struct Running2 {
    union {
      Running1 prior;
      Promise2 current_promise;
    };
    NextFactory2 next_factory;
  };
  struct Running3 {
    union {
      Running2 prior;
      Promise3 current_promise;
    };
    NextFactory3 next_factory;
  };
  struct Running4 {
    union {
      Running3 prior;
      Promise4 current_promise;
    };
    NextFactory4 next_factory;
  };
  struct Running5 {
    union {
      Running4 prior;
      Promise5 current_promise;
    };
    NextFactory5 next_factory;
  };
  struct Running6 {
    union {
      Running5 prior;
      Promise6 current_promise;
    };
    NextFactory6 next_factory;
  };
  struct Running7 {
    union {
      Running6 prior;
      Promise7 current_promise;
    };
    NextFactory7 next_factory;
  };
  union {
    Running7 prior;
    Promise8 current_promise;
  };
  enum class State : uint8_t {
    kState0,
    kState1,
    kState2,
    kState3,
    kState4,
    kState5,
    kState6,
    kState7,
    kState8
  };
  GPR_NO_UNIQUE_ADDRESS State state = State::kState0;

  SeqState(P&& p, F0&& f0, F1&& f1, F2&& f2, F3&& f3, F4&& f4, F5&& f5, F6&& f6,
           F7&& f7) noexcept {
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
              std::forward<P>(p));
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F0>(f0));
    Construct(&prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F1>(f1));
    Construct(&prior.prior.prior.prior.prior.prior.next_factory,
              std::forward<F2>(f2));
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::forward<F3>(f3));
    Construct(&prior.prior.prior.prior.next_factory, std::forward<F4>(f4));
    Construct(&prior.prior.prior.next_factory, std::forward<F5>(f5));
    Construct(&prior.prior.next_factory, std::forward<F6>(f6));
    Construct(&prior.next_factory, std::forward<F7>(f7));
  }
  ~SeqState() {
    switch (state) {
      case State::kState0:
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail0;
      case State::kState1:
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        goto tail1;
      case State::kState2:
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        goto tail2;
      case State::kState3:
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        goto tail3;
      case State::kState4:
        Destruct(&prior.prior.prior.prior.current_promise);
        goto tail4;
      case State::kState5:
        Destruct(&prior.prior.prior.current_promise);
        goto tail5;
      case State::kState6:
        Destruct(&prior.prior.current_promise);
        goto tail6;
      case State::kState7:
        Destruct(&prior.current_promise);
        goto tail7;
      case State::kState8:
        Destruct(&current_promise);
        return;
    }
  tail0:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail1:
    Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
  tail2:
    Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
  tail3:
    Destruct(&prior.prior.prior.prior.prior.next_factory);
  tail4:
    Destruct(&prior.prior.prior.prior.next_factory);
  tail5:
    Destruct(&prior.prior.prior.next_factory);
  tail6:
    Destruct(&prior.prior.next_factory);
  tail7:
    Destruct(&prior.next_factory);
  }
  SeqState(const SeqState& other) = delete;
  SeqState& operator=(const SeqState& other) = delete;
  SeqState(SeqState&& other) noexcept : state(other.state) {
    switch (state) {
      case State::kState0:
        Construct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise,
            std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                          .current_promise));
        goto tail0;
      case State::kState1:
        Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.prior.prior.prior.prior
                                .current_promise));
        goto tail1;
      case State::kState2:
        Construct(
            &prior.prior.prior.prior.prior.prior.current_promise,
            std::move(
                other.prior.prior.prior.prior.prior.prior.current_promise));
        goto tail2;
      case State::kState3:
        Construct(
            &prior.prior.prior.prior.prior.current_promise,
            std::move(other.prior.prior.prior.prior.prior.current_promise));
        goto tail3;
      case State::kState4:
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.prior.current_promise));
        goto tail4;
      case State::kState5:
        Construct(&prior.prior.prior.current_promise,
                  std::move(other.prior.prior.prior.current_promise));
        goto tail5;
      case State::kState6:
        Construct(&prior.prior.current_promise,
                  std::move(other.prior.prior.current_promise));
        goto tail6;
      case State::kState7:
        Construct(&prior.current_promise,
                  std::move(other.prior.current_promise));
        goto tail7;
      case State::kState8:
        Construct(&current_promise, std::move(other.current_promise));
        return;
    }
  tail0:
    Construct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.prior.prior.prior
                            .next_factory));
  tail1:
    Construct(
        &prior.prior.prior.prior.prior.prior.prior.next_factory,
        std::move(
            other.prior.prior.prior.prior.prior.prior.prior.next_factory));
  tail2:
    Construct(
        &prior.prior.prior.prior.prior.prior.next_factory,
        std::move(other.prior.prior.prior.prior.prior.prior.next_factory));
  tail3:
    Construct(&prior.prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.prior.next_factory));
  tail4:
    Construct(&prior.prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.prior.next_factory));
  tail5:
    Construct(&prior.prior.prior.next_factory,
              std::move(other.prior.prior.prior.next_factory));
  tail6:
    Construct(&prior.prior.next_factory,
              std::move(other.prior.prior.next_factory));
  tail7:
    Construct(&prior.next_factory, std::move(other.prior.next_factory));
  }
  SeqState& operator=(SeqState&& other) = delete;
  Poll<Result> PollOnce() {
    switch (state) {
      case State::kState0: {
        auto result =
            prior.prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult0* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState0;
          return Pending{};
        }
        if (!PromiseResultTraits0::IsOk(*p)) {
          return PromiseResultTraits0::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(
            &prior.prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits0::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
      }
      case State::kState1: {
        auto result =
            prior.prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult1* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState1;
          return Pending{};
        }
        if (!PromiseResultTraits1::IsOk(*p)) {
          return PromiseResultTraits1::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits1::CallFactory(
            &prior.prior.prior.prior.prior.prior.prior.next_factory,
            std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
      }
      case State::kState2: {
        auto result = prior.prior.prior.prior.prior.prior.current_promise();
        PromiseResult2* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState2;
          return Pending{};
        }
        if (!PromiseResultTraits2::IsOk(*p)) {
          return PromiseResultTraits2::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits2::CallFactory(
            &prior.prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
      }
      case State::kState3: {
        auto result = prior.prior.prior.prior.prior.current_promise();
        PromiseResult3* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState3;
          return Pending{};
        }
        if (!PromiseResultTraits3::IsOk(*p)) {
          return PromiseResultTraits3::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits3::CallFactory(
            &prior.prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.prior.current_promise,
                  std::move(next_promise));
      }
      case State::kState4: {
        auto result = prior.prior.prior.prior.current_promise();
        PromiseResult4* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState4;
          return Pending{};
        }
        if (!PromiseResultTraits4::IsOk(*p)) {
          return PromiseResultTraits4::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits4::CallFactory(
            &prior.prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.prior.next_factory);
        Construct(&prior.prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState5: {
        auto result = prior.prior.prior.current_promise();
        PromiseResult5* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState5;
          return Pending{};
        }
        if (!PromiseResultTraits5::IsOk(*p)) {
          return PromiseResultTraits5::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.prior.current_promise);
        auto next_promise = PromiseResultTraits5::CallFactory(
            &prior.prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.prior.next_factory);
        Construct(&prior.prior.current_promise, std::move(next_promise));
      }
      case State::kState6: {
        auto result = prior.prior.current_promise();
        PromiseResult6* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState6;
          return Pending{};
        }
        if (!PromiseResultTraits6::IsOk(*p)) {
          return PromiseResultTraits6::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.prior.current_promise);
        auto next_promise = PromiseResultTraits6::CallFactory(
            &prior.prior.next_factory, std::move(*p));
        Destruct(&prior.prior.next_factory);
        Construct(&prior.current_promise, std::move(next_promise));
      }
      case State::kState7: {
        auto result = prior.current_promise();
        PromiseResult7* p = result.value_if_ready();
        if (p == nullptr) {
          state = State::kState7;
          return Pending{};
        }
        if (!PromiseResultTraits7::IsOk(*p)) {
          return PromiseResultTraits7::template ReturnValue<Result>(
              std::move(*p));
        }
        Destruct(&prior.current_promise);
        auto next_promise = PromiseResultTraits7::CallFactory(
            &prior.next_factory, std::move(*p));
        Destruct(&prior.next_factory);
        Construct(&current_promise, std::move(next_promise));
      }
        state = State::kState8;
      case State::kState8: {
        auto result = current_promise();
        auto* p = result.value_if_ready();
        if (p == nullptr) return Pending{};
        return Result(std::move(*p));
      }
    }
  }
};

}  // namespace promise_detail
}  // namespace grpc_core

#endif  // GRPC_SRC_CORE_LIB_PROMISE_DETAIL_SEQ_STATE_H
