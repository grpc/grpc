// Copyright 2026 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef GRPC_TEST_CORE_TRANSPORT_CHTTP2_HPACK_ENCODER_TEST_HELPER_H
#define GRPC_TEST_CORE_TRANSPORT_CHTTP2_HPACK_ENCODER_TEST_HELPER_H

#include <grpc/slice_buffer.h>

#include <cstddef>
#include <cstdint>
#include <utility>

#include "src/core/ext/transport/chttp2/transport/hpack_encoder.h"
#include "src/core/ext/transport/chttp2/transport/hpack_parser.h"
#include "src/core/ext/transport/chttp2/transport/legacy_frame.h"
#include "src/core/util/shared_bit_gen.h"
#include "gtest/gtest.h"
#include "absl/log/log.h"
#include "absl/strings/string_view.h"

constexpr absl::string_view kMetadataValue = "value";
constexpr absl::string_view kMetadatakey = "key";
constexpr absl::string_view kMetadatabinarykey = "key-bin";

namespace grpc_core {

class HpackEncoderTestHelper {
 public:
  // verify that the output frames that are generated by encoding the stream
  // have sensible type and flags values
  static void verify_frames(grpc_slice_buffer& output, bool header_is_eof) {
    // per the HTTP/2 spec:
    //   All frames begin with a fixed 9-octet header followed by a
    //   variable-length payload.

    //   +-----------------------------------------------+
    //   |                 Length (24)                   |
    //   +---------------+---------------+---------------+
    //   |   Type (8)    |   Flags (8)   |
    //   +-+-------------+---------------+-------------------------------+
    //   |R|                 Stream Identifier (31)                      |
    //   +=+=============================================================+
    //   |                   Frame Payload (0...)                      ...
    //   +---------------------------------------------------------------+
    //
    uint8_t type = 0xff, flags = 0xff;
    size_t i, merged_length, frame_size;
    bool first_frame = false;
    bool in_header = false;
    bool end_header = false;
    bool is_closed = false;
    for (i = 0; i < output.count;) {
      first_frame = i == 0;
      grpc_slice* slice = &output.slices[i++];

      // Read gRPC frame header
      uint8_t* p = GRPC_SLICE_START_PTR(*slice);
      frame_size = 0;
      frame_size |= static_cast<uint32_t>(p[0]) << 16;
      frame_size |= static_cast<uint32_t>(p[1]) << 8;
      frame_size |= static_cast<uint32_t>(p[2]);
      type = p[3];
      flags = p[4];

      // Read remainder of the gRPC frame
      merged_length = GRPC_SLICE_LENGTH(*slice);
      while (merged_length < frame_size + 9) {  // including 9 byte frame header
        grpc_slice* slice = &output.slices[i++];
        merged_length += GRPC_SLICE_LENGTH(*slice);
      }

      // Verifications
      if (first_frame && type != GRPC_CHTTP2_FRAME_HEADER) {
        LOG(ERROR) << "expected first frame to be of type header";
        LOG(ERROR) << "EXPECT: " << GRPC_CHTTP2_FRAME_HEADER;
        LOG(ERROR) << "GOT:    " << type;
        EXPECT_TRUE(false);
      } else if (first_frame && header_is_eof &&
                 !(flags & GRPC_CHTTP2_DATA_FLAG_END_STREAM)) {
        LOG(ERROR) << "missing END_STREAM flag in HEADER frame";
        EXPECT_TRUE(false);
      }
      if (is_closed && (type == GRPC_CHTTP2_FRAME_DATA ||
                        type == GRPC_CHTTP2_FRAME_HEADER)) {
        LOG(ERROR)
            << "stream is closed; new frame headers and data are not allowed";
        EXPECT_TRUE(false);
      }
      if (end_header && (type == GRPC_CHTTP2_FRAME_HEADER ||
                         type == GRPC_CHTTP2_FRAME_CONTINUATION)) {
        LOG(ERROR)
            << "frame header is ended; new headers and continuations are not "
               "allowed";
        EXPECT_TRUE(false);
      }
      if (in_header && (type == GRPC_CHTTP2_FRAME_DATA ||
                        type == GRPC_CHTTP2_FRAME_HEADER)) {
        LOG(ERROR)
            << "parsing frame header; new headers and data are not allowed";
        EXPECT_TRUE(false);
      }
      if (flags & ~(GRPC_CHTTP2_DATA_FLAG_END_STREAM |
                    GRPC_CHTTP2_DATA_FLAG_END_HEADERS)) {
        LOG(ERROR) << "unexpected frame flags: " << flags;
        EXPECT_TRUE(false);
      }

      // Update state
      if (flags & GRPC_CHTTP2_DATA_FLAG_END_HEADERS) {
        in_header = false;
        end_header = true;
      } else if (type == GRPC_CHTTP2_DATA_FLAG_END_HEADERS) {
        in_header = true;
      }
      if (flags & GRPC_CHTTP2_DATA_FLAG_END_STREAM) {
        is_closed = true;
        if (type == GRPC_CHTTP2_FRAME_CONTINUATION) {
          LOG(ERROR) << "unexpected END_STREAM flag in CONTINUATION frame";
          EXPECT_TRUE(false);
        }
      }
    }
  }

  static void CreateHeaderFrame(RawEncoder encoder, grpc_slice_buffer* output) {
    uint32_t len = encoder.Length();
    grpc_slice_buffer body;
    grpc_slice_buffer_init(&body);
    std::move(encoder).Flush(&body);

    grpc_slice hdr = GRPC_SLICE_MALLOC(9);
    uint8_t* p = GRPC_SLICE_START_PTR(hdr);
    *p++ = static_cast<uint8_t>(len >> 16);
    *p++ = static_cast<uint8_t>(len >> 8);
    *p++ = static_cast<uint8_t>(len);
    *p++ = GRPC_CHTTP2_FRAME_HEADER;
    *p++ = GRPC_CHTTP2_DATA_FLAG_END_STREAM | GRPC_CHTTP2_DATA_FLAG_END_HEADERS;
    *p++ = 0;
    *p++ = 0;
    *p++ = 0;
    *p++ = 1;  // Stream ID 1

    grpc_slice_buffer_add(output, hdr);
    grpc_slice_buffer_move_into(&body, output);
    grpc_slice_buffer_destroy(&body);
    verify_frames(*output, /*header_is_eof=*/true);
  }

  static void EncodeAndParse(RawEncoder&& encoder, grpc_metadata_batch* b) {
    grpc_slice_buffer frame;
    grpc_slice_buffer_init(&frame);
    CreateHeaderFrame(std::move(encoder), &frame);
    ParseHeaderFrame(&frame, b);
    grpc_slice_buffer_destroy(&frame);
  }

 private:
  static void ParseHeaderFrame(grpc_slice_buffer* frame,
                               grpc_metadata_batch* batch,
                               const bool is_client = true) {
    HPackParser parser;
    HPackParser::LogInfo log_info{/*stream_id=*/1,
                                  HPackParser::LogInfo::kHeaders, is_client};
    parser.BeginFrame(batch, /*metadata_size_soft_limit=*/1024u * 1024u,
                      /*metadata_size_hard_limit=*/1024u * 1024u,
                      HPackParser::Boundary::EndOfStream,
                      HPackParser::Priority::None, log_info);

    grpc_slice_buffer header_trash;
    grpc_slice_buffer_init(&header_trash);
    if (frame->length >= 9) {
      grpc_slice_buffer_move_first(frame, 9, &header_trash);
    } else {
      // Should fail
      FAIL() << "Frame too short";
    }
    grpc_slice_buffer_destroy(&header_trash);

    for (size_t i = 0; i < frame->count; i++) {
      grpc_error_handle err = parser.Parse(
          frame->slices[i], i == frame->count - 1, SharedBitGen(), nullptr);
      EXPECT_TRUE(err.ok()) << StatusToString(err);
    }
    parser.FinishFrame();
  }
};
}  // namespace grpc_core

#endif  // GRPC_TEST_CORE_TRANSPORT_CHTTP2_HPACK_ENCODER_TEST_HELPER_H
