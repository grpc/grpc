 Handling of null reference types in C# code generation
----
* Author(s): Tony Newell
* Approver: 
* Status: Draft
* Last updated: June 2023

## Abstract

The protocol buffers compiler (`protoc`) and the gRPC C# compiler plugin 
(`grpc_csharp_plugin`) generate C# code that does not use the nullable reference
 types language features introduced in C# 8.0.

This proposal discusses why there are no plans to explicitly handle nullable 
reference types in the generated code.

## Background

A note on the terminology used in this document for the various *.NET* versions:
- *.NET Framework* - the implementation of *.NET* that runs only on Windows, such 
  as *.NET Framework 4.8.1*
- *.NET Core* - within this document, references to *.NET Core* are intended to include
 *.NET Core 3.1*, *.NET 5*, and later. Strictly Microsoft refers to all versions
 from *.NET 5* and later as just *.NET*. 

*Nullable reference types* refers to a group of optional features introduced 
in C# 8.0 to enable the compiler to do static flow analysis to determine if a
variable might be null before it is dereferenced. They are compile time features
that do not affect the runtime.

Various issues have been raised asking for the code generated by the protocol
buffers compiler (`protoc`) and the gRPC C# compiler plugin 
(`grpc_csharp_plugin`) to support nullable reference types, including:

- [Investigate support for nullable reference types in generated code](https://github.com/grpc/grpc-dotnet/issues/606)
- [Add option to generate C# nullable annotations](https://github.com/protocolbuffers/protobuf/issues/6632)
- [C#: Consider exposing protobuf optional fields as nullable properties](https://github.com/protocolbuffers/protobuf/issues/9083)
- [Support C# 8 nullable type references in Grpc.Tools](https://github.com/grpc/grpc/issues/20729)

## Proposal

The proposal is to maintain the status quo and to keep code generation 
unchanged. Reasons are given below.

## Rationale

The reasons for currently maintaining the status quo are summarised here:
1. The generated code is not in a nullable context
2. *.NET Framework* projects default to using C# 7.3
3. Building gRPC projects with nullable enabled works today
4. Breaking backwards compatibility with gRPC service classes
5. Keeping the generated code simple and consistent

There are very few disadvantages to not supporting nullable reference types in
the generated code. These are given later.

The above reasons are explained in more detail:

### 1. The generated code is not in a nullable context

The generated code is not in a nullable context. The `// <auto-generated>` 
comment in the code disables it. No nullable checks are made and no compiler 
warnings are generated for this code, even if the code is compiled in a project 
with nullable checks enabled.

### 2. .NET Framework projects default to using C# 7.3

*.NET Framework* projects default to using compiler version C# 7.3 which does
not support nullable reference type features.

*Visual Studio 2022* does not let you change to a later compiler version for
*.NET Framework* projects:
- In *Advanced Build Settings | Language version* the drop down to select the 
language version is greyed out and says “*Automatically selected based on 
framework version*”

See https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/configure-language-version 

Note: It is possible to edit the project file and explicitly set the language 
version to a later version, but other language features that require runtime 
changes in the CLR will not work. C# 7.3 is the latest language version that is 
fully supported with *.NET Framework* projects.

### 3. Building gRPC projects with nullable enabled works today

There does not appear to be a problem building *.NET Core* projects that have
nullable enabled and are using the generated code. All the `grpc/dotnet-grpc`
examples already have nullable context enabled and they build without errors 
or warnings.

### 4. Breaking backwards compatibility with gRPC service classes

The generated code for gRPC services could have attributes added to specify that 
a non-null message or stream must be passed to a service, and a non-null value 
is returned.

However this can break existing user code. Adding these attributes to the base 
class may cause errors (not warnings) in user code that has already been derived 
from the base class:

> *error CS8765: Nullability of type of parameter 'request' doesn't match 
overridden member (possibly because of nullability attributes).*

Note: the advantages of adding these attributes to the service methods is 
questionable as the only caller of these methods is the server hosting the 
services, not user code. Therefore this may not be an issue if it is not needed 
to be done.

### 5. Keeping the generated code simple and consistent

It would be possible to generate different code for nullable and non-nullable contexts
depending on some configuration, or to generate conditional code containing `#if` 
everywhere.

Generating different code depending on configuration could lead to confusion or errors
if code generated in one project with nullable enabled was consumed in another project 
that did not have nullable enabled. It would also have an impact on the level of 
testing that would need to be done.

Generating conditional code would produce messy and potentially convoluted code, again
having an impact on testing.

## Disadvantages of this propsal

There are a few places where adding annotations or attributes to the generated
code to help with the static flow analysis could be useful. These are:
- Checking non-null setters for certain fields in a message at compile time,
 such as fields that are strings. Runtime checks are still done in the
 generated code.
- Checking a non-null message or stream is passed to a gRPC service call.
- Specifying a non-null message or stream is returned from a gRPC service call.

By not supporting nullable reference types in the generated code these compile
time checks cannot be done.

## Outside the scope of this proposal

### Changes to related packages

Changes to `Google.Protobuf` library and other libraries 
(such as `Google.Api.CommonProtos`) are outside the scope of this proposal.

There is a separate long-standing effort to enable null reference types for 
`Google.Protobuf`.

### Exposing protocol buffers optional fields as nullable properties

See https://github.com/protocolbuffers/protobuf/issues/9083

This has been rejected by the protocol buffers team.

> "We get requests in some other languages that have null support to allow 
optional fields to have nullable properties. The main problem is that we like to 
keep languages consistent and other languages don't have those same options. 
Additionally, it's not clear with some primitive fields what a null value would 
be (is it the default? What if users meant to set it to that option?). For those 
reasons, we will not support this in the near future.”

## Alternative options to this proposal

If in the future we want to support nullable reference types in the generated 
code then this should be an *opt-in* feature so as to not break existing 
projects.

We need to consider:
- Options for enabling this feature
- What code changes need to be made in the generated code

Options for enabling this feature:

- Generate conditional code and the user has to define a constant in the project files to enable it
  - The generated conditional code might be messy
  - Could change `Grpc.Tools` to define the constant if it detects project has nullable enabled

- Generate code that relies on definitions of nullable attributes for older framework versions
  - Like those in https://github.com/grpc/grpc-dotnet/blob/master/src/Shared/NullableAttributes.cs
  - Where would these definitions of nullable attributes be defined?
  Don’t want to define them in every generated C# file. Is there a single 
  library where they could live? Putting the annotations in any shared library would mean
  they would have to be public rather than internal, which then may cause issues with
  potential collisions.

- Add command line options to `protoc` and `grpc_csharp_plugin` 
  - Option would have to be passed to both `protoc` and `grpc_csharp_plugin`
  - Could change `Grpc.Tools` to pass the option if it detects project has nullable enabled
  - Cannot generate the code once and use it in different projects (e.g. a *.NET Framework* client and a *.NET Core* server project)
  - Additional testing needed for variants of generated code

- Add file option in proto files
  - Cannot generate code for older projects using the same proto file.

The minimum code changes needed would be:
- Adding `[NotNull]` on setters for certain fields in a message such as fields that are strings. 
- Adding `[NotNull]` on parameters on gRPC client methods.
- Adding `[return: NotNull]` on gRPC client methods.

Other code changes may be discovered to be necessary.
