<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC PHP: Interoperability Test Case Descriptions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC PHP
   &#160;<span id="projectnumber">1.58.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Interoperability Test Case Descriptions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Client and server use <a href="../src/proto/grpc/testing/test.proto">test.proto</a> and the <a class="el" href="_p_r_o_t_o_c_o_l-_h_t_t_p2_8md.html">gRPC over HTTP/2 v2 protocol</a>.</p>
<h1><a class="anchor" id="autotoc_md110"></a>
Client</h1>
<p>Clients implement test cases that test certain functionally. Each client is provided the test case it is expected to run as a command-line parameter. Names should be lowercase and without spaces.</p>
<p>Clients should accept these arguments:</p><ul>
<li>&ndash;server_host=HOSTNAME<ul>
<li>The server host to connect to. For example, "localhost" or "127.0.0.1"</li>
</ul>
</li>
<li>&ndash;server_host_override=HOSTNAME<ul>
<li>The server host to claim to be connecting to, for use in TLS and HTTP/2 :authority header. If unspecified, the value of &ndash;server_host will be used</li>
</ul>
</li>
<li>&ndash;server_port=PORT<ul>
<li>The server port to connect to. For example, "8080"</li>
</ul>
</li>
<li>&ndash;test_case=TESTCASE<ul>
<li>The name of the test case to execute. For example, "empty_unary"</li>
</ul>
</li>
<li>&ndash;use_tls=BOOLEAN<ul>
<li>Whether to use a plaintext or encrypted connection</li>
</ul>
</li>
<li>&ndash;use_test_ca=BOOLEAN<ul>
<li>Whether to replace platform root CAs with <a href="https://github.com/grpc/grpc/blob/master/src/core/tsi/test_creds/ca.pem">ca.pem</a> as the CA root</li>
</ul>
</li>
<li>&ndash;default_service_account=ACCOUNT_EMAIL<ul>
<li>Email of the GCE default service account.</li>
</ul>
</li>
<li>&ndash;oauth_scope=SCOPE<ul>
<li>OAuth scope. For example, "https://www.googleapis.com/auth/xapi.zoo"</li>
</ul>
</li>
<li>&ndash;service_account_key_file=PATH<ul>
<li>The path to the service account JSON key file generated from GCE developer console.</li>
</ul>
</li>
<li>&ndash;service_config_json=SERVICE_CONFIG_JSON<ul>
<li>Disables service config lookups and sets the provided string as the default service config.</li>
</ul>
</li>
<li>&ndash;additional_metadata=ADDITIONAL_METADATA<ul>
<li><p class="startli">Additional metadata to send in each request, as a semicolon-separated list of key:value pairs. The first key/value pair is separated by the first colon. The second key/value pair is separated by the next colon <em>following</em> the next semi-colon thereafter, and so on. For example:</p><ul>
<li><code>abc-key:abc-value;foo-key:foo-value</code><ul>
<li>Key/value pairs: <code>abc-key</code>/<code>abc-value</code>, <code>foo-key</code>/<code>foo-value</code>.</li>
</ul>
</li>
<li><code>abc-key:abc:value;foo-key:foo:value</code><ul>
<li>Key/value pairs: <code>abc-key</code>/<code>abc:value</code>, <code>foo-key</code>/<code>foo:value</code>.</li>
</ul>
</li>
</ul>
<p class="startli">Keys must be ASCII only (no <code>-bin</code> headers allowed). Values may contain any character except semi-colons.</p>
</li>
</ul>
</li>
</ul>
<p>Clients must support TLS with ALPN. Clients must not disable certificate checking.</p>
<h2><a class="anchor" id="autotoc_md111"></a>
empty_unary</h2>
<p>This test verifies that implementations support zero-size messages. Ideally, client implementations would verify that the request and response were zero bytes serialized, but this is generally prohibitive to perform, so is not required.</p>
<p>Server features:</p><ul>
<li><a href="#emptycall">EmptyCall</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client calls EmptyCall with the default Empty message</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>response is non-null</li>
</ul>
<p><em>It may be possible to use UnaryCall instead of EmptyCall, but it is harder to ensure that the proto serialized to zero bytes.</em></p>
<h2><a class="anchor" id="autotoc_md112"></a>
cacheable_unary</h2>
<p>This test verifies that gRPC requests marked as cacheable use GET verb instead of POST, and that server sets appropriate cache control headers for the response to be cached by a proxy. This test requires that the server is behind a caching proxy. Use of current timestamp in the request prevents accidental cache matches left over from previous tests.</p>
<p>Server features:</p><ul>
<li><a href="#cacheableunarycall">CacheableUnaryCall</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client calls CacheableUnaryCall with <code>SimpleRequest</code> request with payload set to current timestamp. Timestamp format is irrelevant, and resolution is in nanoseconds. Client adds a <code>x-user-ip</code> header with value <code>1.2.3.4</code> to the request. This is done since some proxys such as GFE will not cache requests from localhost. Client marks the request as cacheable by setting the cacheable flag in the request context. Longer term this should be driven by the method option specified in the proto file itself.</li>
<li>Client calls CacheableUnaryCall again immediately with the same request and configuration as the previous call.</li>
</ol>
<p>Client asserts:</p><ul>
<li>Both calls were successful</li>
<li>The payload body of both responses is the same.</li>
</ul>
<h2><a class="anchor" id="autotoc_md113"></a>
large_unary</h2>
<p>This test verifies unary calls succeed in sending messages, and touches on flow control (even if compression is enabled on the channel).</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li><p class="startli">Client calls UnaryCall with:</p>
<p class="startli">``` { response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>response payload body is 314159 bytes in size</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response message against a golden response</li>
</ul>
<h2><a class="anchor" id="autotoc_md114"></a>
client_compressed_unary</h2>
<p>This test verifies the client can compress unary messages by sending two unary calls, for compressed and uncompressed payloads. It also sends an initial probing request to verify whether the server supports the <a href="#compressedrequest">CompressedRequest</a> feature by checking if the probing call fails with an <code>INVALID_ARGUMENT</code> status.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#compressedrequest">CompressedRequest</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client calls UnaryCall with the feature probe, an <em>uncompressed</em> message: ``` { expect_compressed:{ value: true } response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</li>
</ol>
<ol type="1">
<li><p class="startli">Client calls UnaryCall with the <em>compressed</em> message:</p>
<p class="startli">``` { expect_compressed:{ value: true } response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</p>
</li>
</ol>
<ol type="1">
<li><p class="startli">Client calls UnaryCall with the <em>uncompressed</em> message:</p>
<p class="startli">``` { expect_compressed:{ value: false } response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</p>
<p class="startli">Client asserts:</p><ul>
<li>First call failed with <code>INVALID_ARGUMENT</code> status.</li>
<li>Subsequent calls were successful.</li>
<li>Response payload body is 314159 bytes in size.</li>
<li>Clients are free to assert that the response payload body contents are zeros and comparing the entire response message against a golden response.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md115"></a>
server_compressed_unary</h2>
<p>This test verifies the server can compress unary messages. It sends two unary requests, expecting the server's response to be compressed or not according to the <code>response_compressed</code> boolean.</p>
<p>Whether compression was actually performed is determined by the compression bit in the response's message flags. <em>Note that some languages may not have access to the message flags, in which case the client will be unable to verify that the <code>response_compressed</code> boolean is obeyed by the server</em>.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#compressedresponse">CompressedResponse</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li><p class="startli">Client calls UnaryCall with <code>SimpleRequest</code>:</p>
<p class="startli">``` { response_compressed:{ value: true } response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</p>
<p class="startli">``` { response_compressed:{ value: false } response_size: 314159 payload:{ body: 271828 bytes of zeros } } ``` Client asserts:</p><ul>
<li>call was successful</li>
<li>if supported by the implementation, when <code>response_compressed</code> is true, the response MUST have the compressed message flag set.</li>
<li>if supported by the implementation, when <code>response_compressed</code> is false, the response MUST NOT have the compressed message flag set.</li>
<li>response payload body is 314159 bytes in size in both cases.</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response message against a golden response</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md116"></a>
client_streaming</h2>
<p>This test verifies that client-only streaming succeeds.</p>
<p>Server features:</p><ul>
<li><a href="#streaminginputcall">StreamingInputCall</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client calls StreamingInputCall</li>
<li><p class="startli">Client sends:</p>
<p class="startli">``` { payload:{ body: 27182 bytes of zeros } } ```</p>
</li>
<li><p class="startli">Client then sends:</p>
<p class="startli">``` { payload:{ body: 8 bytes of zeros } } ```</p>
</li>
<li><p class="startli">Client then sends:</p>
<p class="startli">``` { payload:{ body: 1828 bytes of zeros } } ```</p>
</li>
<li><p class="startli">Client then sends:</p>
<p class="startli">``` { payload:{ body: 45904 bytes of zeros } } ```</p>
</li>
<li>Client half-closes</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>response aggregated_payload_size is 74922</li>
</ul>
<h2><a class="anchor" id="autotoc_md117"></a>
client_compressed_streaming</h2>
<p>This test verifies the client can compress requests on per-message basis by performing a two-request streaming call. It also sends an initial probing request to verify whether the server supports the <a href="#compressedrequest">CompressedRequest</a> feature by checking if the probing call fails with an <code>INVALID_ARGUMENT</code> status.</p>
<p>Procedure:</p><ol type="1">
<li><p class="startli">Client calls <code>StreamingInputCall</code> and sends the following feature-probing <em>uncompressed</em> <code>StreamingInputCallRequest</code> message</p>
<p class="startli">``` { expect_compressed:{ value: true } payload:{ body: 27182 bytes of zeros } } ``<code> If the call does not fail with</code>INVALID_ARGUMENT`, the test fails. Otherwise, we continue.</p>
</li>
</ol>
<ol type="1">
<li><p class="startli">Client calls <code>StreamingInputCall</code> again, sending the <em>compressed</em> message</p>
<p class="startli">``` { expect_compressed:{ value: true } payload:{ body: 27182 bytes of zeros } } ```</p>
</li>
</ol>
<ol type="1">
<li>And finally, the <em>uncompressed</em> message ``` { expect_compressed:{ value: false } payload:{ body: 45904 bytes of zeros } } ```</li>
</ol>
<ol type="1">
<li>Client half-closes</li>
</ol>
<p>Client asserts:</p><ul>
<li>First call fails with <code>INVALID_ARGUMENT</code>.</li>
<li>Next calls succeeds.</li>
<li>Response aggregated payload size is 73086.</li>
</ul>
<h2><a class="anchor" id="autotoc_md118"></a>
server_streaming</h2>
<p>This test verifies that server-only streaming succeeds.</p>
<p>Server features:</p><ul>
<li><a href="#streamingoutputcall">StreamingOutputCall</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li><p class="startli">Client calls StreamingOutputCall with <code>StreamingOutputCallRequest</code>:</p>
<p class="startli">``` { response_parameters:{ size: 31415 } response_parameters:{ size: 9 } response_parameters:{ size: 2653 } response_parameters:{ size: 58979 } } ```</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>exactly four responses</li>
<li>response payload bodies are sized (in order): 31415, 9, 2653, 58979</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response messages against golden responses</li>
</ul>
<h2><a class="anchor" id="autotoc_md119"></a>
server_compressed_streaming</h2>
<p>This test verifies that the server can compress streaming messages and disable compression on individual messages, expecting the server's response to be compressed or not according to the <code>response_compressed</code> boolean.</p>
<p>Whether compression was actually performed is determined by the compression bit in the response's message flags. <em>Note that some languages may not have access to the message flags, in which case the client will be unable to verify that the <code>response_compressed</code> boolean is obeyed by the server</em>.</p>
<p>Server features:</p><ul>
<li><a href="#streamingoutputcall">StreamingOutputCall</a></li>
<li><a href="#compressedresponse">CompressedResponse</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li><p class="startli">Client calls StreamingOutputCall with <code>StreamingOutputCallRequest</code>:</p>
<p class="startli">``` { response_parameters:{ compressed: { value: true } size: 31415 } response_parameters:{ compressed: { value: false } size: 92653 } } ```</p>
<p class="startli">Client asserts:</p><ul>
<li>call was successful</li>
<li>exactly two responses</li>
<li>if supported by the implementation, when <code>response_compressed</code> is false, the response's messages MUST NOT have the compressed message flag set.</li>
<li>if supported by the implementation, when <code>response_compressed</code> is true, the response's messages MUST have the compressed message flag set.</li>
<li>response payload bodies are sized (in order): 31415, 92653</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response messages against golden responses</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md120"></a>
ping_pong</h2>
<p>This test verifies that full duplex bidi is supported.</p>
<p>Server features:</p><ul>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li><p class="startli">Client calls FullDuplexCall with:</p>
<p class="startli">``` { response_parameters:{ size: 31415 } payload:{ body: 27182 bytes of zeros } } ```</p>
</li>
<li><p class="startli">After getting a reply, it sends:</p>
<p class="startli">``` { response_parameters:{ size: 9 } payload:{ body: 8 bytes of zeros } } ```</p>
</li>
<li><p class="startli">After getting a reply, it sends:</p>
<p class="startli">``` { response_parameters:{ size: 2653 } payload:{ body: 1828 bytes of zeros } } ```</p>
</li>
<li><p class="startli">After getting a reply, it sends:</p>
<p class="startli">``` { response_parameters:{ size: 58979 } payload:{ body: 45904 bytes of zeros } } ```</p>
</li>
<li>After getting a reply, client half-closes</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>exactly four responses</li>
<li>response payload bodies are sized (in order): 31415, 9, 2653, 58979</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response messages against golden responses</li>
</ul>
<h2><a class="anchor" id="autotoc_md121"></a>
empty_stream</h2>
<p>This test verifies that streams support having zero-messages in both directions.</p>
<p>Server features:</p><ul>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client calls FullDuplexCall and then half-closes</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>exactly zero responses</li>
</ul>
<h2><a class="anchor" id="autotoc_md122"></a>
compute_engine_creds</h2>
<p>This test is only for cloud-to-prod path.</p>
<p>This test verifies unary calls succeed in sending messages while using Service Credentials from GCE metadata server. The client instance needs to be created with desired oauth scope.</p>
<p>The test uses <code>--default_service_account</code> with GCE service account email and <code>--oauth_scope</code> with the OAuth scope to use. For testing against grpc-test.sandbox.googleapis.com, "https://www.googleapis.com/auth/xapi.zoo" should be passed in as <code>--oauth_scope</code>.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-authenticated-username">Echo Authenticated Username</a></li>
<li><a href="#echo-oauth-scope">Echo OAuth Scope</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client configures channel to use GCECredentials</li>
<li><p class="startli">Client calls UnaryCall on the channel with:</p>
<p class="startli">``` { response_size: 314159 payload:{ body: 271828 bytes of zeros } fill_username: true fill_oauth_scope: true } ```</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>received SimpleResponse.username equals the value of <code>--default_service_account</code> flag</li>
<li>received SimpleResponse.oauth_scope is in <code>--oauth_scope</code></li>
<li>response payload body is 314159 bytes in size</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response message against a golden response</li>
</ul>
<h2><a class="anchor" id="autotoc_md123"></a>
jwt_token_creds</h2>
<p>This test is only for cloud-to-prod path.</p>
<p>This test verifies unary calls succeed in sending messages while using JWT token (created by the project's key file)</p>
<p>Test caller should set flag <code>--service_account_key_file</code> with the path to json key file downloaded from <a href="https://console.developers.google.com">https://console.developers.google.com</a>. Alternately, if using a usable auth implementation, she may specify the file location in the environment variable GOOGLE_APPLICATION_CREDENTIALS.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-authenticated-username">Echo Authenticated Username</a></li>
<li><a href="#echo-oauth-scope">Echo OAuth Scope</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client configures the channel to use JWTTokenCredentials</li>
<li><p class="startli">Client calls UnaryCall with:</p>
<p class="startli">``` { response_size: 314159 payload:{ body: 271828 bytes of zeros } fill_username: true } ```</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>received SimpleResponse.username is not empty and is in the json key file used by the auth library. The client can optionally check the username matches the email address in the key file or equals the value of <code>--default_service_account</code> flag.</li>
<li>response payload body is 314159 bytes in size</li>
<li>clients are free to assert that the response payload body contents are zero and comparing the entire response message against a golden response</li>
</ul>
<h2><a class="anchor" id="autotoc_md124"></a>
oauth2_auth_token</h2>
<p>This test is only for cloud-to-prod path and some implementations may run in GCE only.</p>
<p>This test verifies unary calls succeed in sending messages using an OAuth2 token that is obtained out of band. For the purpose of the test, the OAuth2 token is actually obtained from a service account credentials or GCE credentials via the language-specific authorization library.</p>
<p>The difference between this test and the other auth tests is that it first uses the authorization library to obtain an authorization token.</p>
<p>The test</p><ul>
<li>uses the flag <code>--service_account_key_file</code> with the path to a json key file downloaded from <a href="https://console.developers.google.com">https://console.developers.google.com</a>. Alternately, if using a usable auth implementation, it may specify the file location in the environment variable GOOGLE_APPLICATION_CREDENTIALS, <em>OR</em> if GCE credentials is used to fetch the token, <code>--default_service_account</code> can be used to pass in GCE service account email.</li>
<li>uses the flag <code>--oauth_scope</code> for the oauth scope. For testing against grpc-test.sandbox.googleapis.com, "https://www.googleapis.com/auth/xapi.zoo" should be passed as the <code>--oauth_scope</code>.</li>
</ul>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-authenticated-username">Echo Authenticated Username</a></li>
<li><a href="#echo-oauth-scope">Echo OAuth Scope</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client uses the auth library to obtain an authorization token</li>
<li>Client configures the channel to use AccessTokenCredentials with the access token obtained in step 1</li>
<li><p class="startli">Client calls UnaryCall with the following message</p>
<p class="startli">``` { fill_username: true fill_oauth_scope: true } ```</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>received SimpleResponse.username is valid. Depending on whether a service account key file or GCE credentials was used, client should check against the json key file or GCE default service account email.</li>
<li>received SimpleResponse.oauth_scope is in <code>--oauth_scope</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md125"></a>
per_rpc_creds</h2>
<p>Similar to the other auth tests, this test is only for cloud-to-prod path.</p>
<p>This test verifies unary calls succeed in sending messages using a JWT or a service account credentials set on the RPC.</p>
<p>The test</p><ul>
<li>uses the flag <code>--service_account_key_file</code> with the path to a json key file downloaded from <a href="https://console.developers.google.com">https://console.developers.google.com</a>. Alternately, if using a usable auth implementation, it may specify the file location in the environment variable GOOGLE_APPLICATION_CREDENTIALS</li>
<li>optionally uses the flag <code>--oauth_scope</code> for the oauth scope if implementer wishes to use service account credential instead of JWT credential. For testing against grpc-test.sandbox.googleapis.com, oauth scope "https://www.googleapis.com/auth/xapi.zoo" should be used.</li>
</ul>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-authenticated-username">Echo Authenticated Username</a></li>
<li><a href="#echo-oauth-scope">Echo OAuth Scope</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client configures the channel with just SSL credentials</li>
<li><p class="startli">Client calls UnaryCall, setting per-call credentials to JWTTokenCredentials. The request is the following message</p>
<p class="startli">``` { fill_username: true } ```</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>received SimpleResponse.username is not empty and is in the json key file used by the auth library. The client can optionally check the username matches the email address in the key file.</li>
</ul>
<h2><a class="anchor" id="autotoc_md126"></a>
google_default_credentials</h2>
<p>Similar to the other auth tests, this test should only be run against prod servers. Different from some of the other auth tests however, this test may be also run from outside of GCP.</p>
<p>This test verifies unary calls succeed when the client uses GoogleDefaultCredentials. The path to a service account key file in the GOOGLE_APPLICATION_CREDENTIALS environment variable may or may not be provided by the test runner. For example, the test runner might set this environment when outside of GCP but keep it unset when on GCP.</p>
<p>The test uses <code>--default_service_account</code> with GCE service account email.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-authenticated-username">Echo Authenticated Username</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client configures the channel to use GoogleDefaultCredentials<ul>
<li>Note: the term <code>GoogleDefaultCredentials</code> within the context of this test description refers to an API which encapsulates both "transport credentials" and "call credentials" and which is capable of transport creds auto-selection (including ALTS). Similar APIs involving only auto-selection of OAuth mechanisms might work for this test but aren't the intended subjects.</li>
</ul>
</li>
<li><p class="startli">Client calls UnaryCall with:</p>
<p class="startli">``` { fill_username: true } ```</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>received SimpleResponse.username matches the value of <code>--default_service_account</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md127"></a>
compute_engine_channel_credentials</h2>
<p>Similar to the other auth tests, this test should only be run against prod servers. Note that this test may only be ran on GCP.</p>
<p>This test verifies unary calls succeed when the client uses ComputeEngineChannelCredentials. All that is needed by the test environment is for the client to be running on GCP.</p>
<p>The test uses <code>--default_service_account</code> with GCE service account email. This email must identify the default service account of the GCP VM that the test is running on.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-authenticated-username">Echo Authenticated Username</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client configures the channel to use ComputeEngineChannelCredentials<ul>
<li>Note: the term <code>ComputeEngineChannelCredentials</code> within the context of this test description refers to an API which encapsulates both "transport credentials" and "call credentials" and which is capable of transport creds auto-selection (including ALTS). The exact name of the API may vary per language.</li>
</ul>
</li>
<li><p class="startli">Client calls UnaryCall with:</p>
<p class="startli">``` { fill_username: true } ```</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>received SimpleResponse.username matches the value of <code>--default_service_account</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md128"></a>
custom_metadata</h2>
<p>This test verifies that custom metadata in either binary or ascii format can be sent as initial-metadata by the client and as both initial- and trailing-metadata by the server.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
<li><a href="#echo-metadata">Echo Metadata</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li><p class="startli">The client attaches custom metadata with the following keys and values:</p>
<p class="startli">``` key: "x-grpc-test-echo-initial", value: "test_initial_metadata_value" key: "x-grpc-test-echo-trailing-bin", value: 0xababab ```</p>
<p class="startli">to a UnaryCall with request:</p>
<p class="startli">``` { response_size: 314159 payload:{ body: 271828 bytes of zeros } } ```</p>
</li>
<li><p class="startli">The client attaches custom metadata with the following keys and values:</p>
<p class="startli">``` key: "x-grpc-test-echo-initial", value: "test_initial_metadata_value" key: "x-grpc-test-echo-trailing-bin", value: 0xababab ```</p>
<p class="startli">to a FullDuplexCall with request:</p>
<p class="startli">``` { response_parameters:{ size: 314159 } payload:{ body: 271828 bytes of zeros } } ```</p>
<p class="startli">and then half-closes</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>call was successful</li>
<li>metadata with key <code>"x-grpc-test-echo-initial"</code> and value <code>"test_initial_metadata_value"</code>is received in the initial metadata for calls in Procedure steps 1 and 2.</li>
<li>metadata with key <code>"x-grpc-test-echo-trailing-bin"</code> and value <code>0xababab</code> is received in the trailing metadata for calls in Procedure steps 1 and 2.</li>
</ul>
<h2><a class="anchor" id="autotoc_md129"></a>
status_code_and_message</h2>
<p>This test verifies unary calls succeed in sending messages, and propagate back status code and message sent along with the messages.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
<li><a href="#echo-status">Echo Status</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li><p class="startli">Client calls UnaryCall with:</p>
<p class="startli">``` { response_status:{ code: 2 message: "test status message" } } ```</p>
</li>
<li><p class="startli">Client calls FullDuplexCall with:</p>
<p class="startli">``` { response_status:{ code: 2 message: "test status message" } } ```</p>
<p class="startli">and then half-closes</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>received status code is the same as the sent code for both Procedure steps 1 and 2</li>
<li>received status message is the same as the sent message for both Procedure steps 1 and 2</li>
</ul>
<h2><a class="anchor" id="autotoc_md130"></a>
special_status_message</h2>
<p>This test verifies Unicode and whitespace is correctly processed in status message. "\t" is horizontal tab. "\r" is carriage return. "\n" is line feed.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#echo-status">Echo Status</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li><p class="startli">Client calls UnaryCall with:</p>
<p class="startli">``` { response_status:{ code: 2 message: "\t\ntest with whitespace\r\nand Unicode BMP â˜º and non-BMP ðŸ˜ˆ\t\n" } } ```</p>
</li>
</ol>
<p>Client asserts:</p><ul>
<li>received status code is the same as the sent code for Procedure step 1</li>
<li>received status message is the same as the sent message for Procedure step 1, including all whitespace characters</li>
</ul>
<h2><a class="anchor" id="autotoc_md131"></a>
unimplemented_method</h2>
<p>This test verifies that calling an unimplemented RPC method returns the UNIMPLEMENTED status code.</p>
<p>Server features: N/A</p>
<p>Procedure:</p><ul>
<li><p class="startli">Client calls <code>grpc.testing.TestService/UnimplementedCall</code> with an empty request (defined as <code>grpc.testing.Empty</code>):</p>
<p class="startli">``` { } ```</p>
</li>
</ul>
<p>Client asserts:</p><ul>
<li>received status code is 12 (UNIMPLEMENTED)</li>
</ul>
<h2><a class="anchor" id="autotoc_md132"></a>
unimplemented_service</h2>
<p>This test verifies calling an unimplemented server returns the UNIMPLEMENTED status code.</p>
<p>Server features: N/A</p>
<p>Procedure:</p><ul>
<li>Client calls <code>grpc.testing.UnimplementedService/UnimplementedCall</code> with an empty request (defined as <code>grpc.testing.Empty</code>)</li>
</ul>
<p>Client asserts:</p><ul>
<li>received status code is 12 (UNIMPLEMENTED)</li>
</ul>
<h2><a class="anchor" id="autotoc_md133"></a>
cancel_after_begin</h2>
<p>This test verifies that a request can be cancelled after metadata has been sent but before payloads are sent.</p>
<p>Server features:</p><ul>
<li><a href="#streaminginputcall">StreamingInputCall</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li>Client starts StreamingInputCall</li>
<li>Client immediately cancels request</li>
</ol>
<p>Client asserts:</p><ul>
<li>Call completed with status CANCELLED</li>
</ul>
<h2><a class="anchor" id="autotoc_md134"></a>
cancel_after_first_response</h2>
<p>This test verifies that a request can be cancelled after receiving a message from the server.</p>
<p>Server features:</p><ul>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li><p class="startli">Client starts FullDuplexCall with</p>
<p class="startli">``` { response_parameters:{ size: 31415 } payload:{ body: 27182 bytes of zeros } } ```</p>
</li>
<li>After receiving a response, client cancels request</li>
</ol>
<p>Client asserts:</p><ul>
<li>Call completed with status CANCELLED</li>
</ul>
<h2><a class="anchor" id="autotoc_md135"></a>
timeout_on_sleeping_server</h2>
<p>This test verifies that an RPC request whose lifetime exceeds its configured timeout value will end with the DeadlineExceeded status.</p>
<p>Server features:</p><ul>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
</ul>
<p>Procedure:</p><ol type="1">
<li><p class="startli">Client calls FullDuplexCall with the following request and sets its timeout to 1ms</p>
<p class="startli">``` { payload:{ body: 27182 bytes of zeros } } ```</p>
</li>
<li>Client waits</li>
</ol>
<p>Client asserts:</p><ul>
<li>Call completed with status DEADLINE_EXCEEDED.</li>
</ul>
<h2><a class="anchor" id="autotoc_md136"></a>
rpc_soak</h2>
<p>The client performs many large_unary RPCs in sequence over the same channel. The client records the latency and status of each RPC in some data structure. If the test ever consumes <code>soak_overall_timeout_seconds</code> seconds and still hasn't completed <code>soak_iterations</code> RPCs, then the test should discontinue sending RPCs as soon as possible. After performing all RPCs, the test should examine previously recorded RPC latency and status results in a second pass and fail if either:</p>
<p>a) not all <code>soak_iterations</code> RPCs were completed</p>
<p>b) the sum of RPCs that either completed with a non-OK status or exceeded <code>max_acceptable_per_rpc_latency_ms</code> exceeds <code>soak_max_failures</code></p>
<p>Implementations should use a timer with sub-millisecond precision to measure latency. Also, implementations should avoid setting RPC deadlines and should instead wait for each RPC to complete. Doing so provides more data for debugging in case of failure. For example, if RPC deadlines are set to <code>soak_per_iteration_max_acceptable_latency_ms</code> and one of the RPCs hits that deadline, it's not clear if the RPC was late by a millisecond or a minute.</p>
<p>In order to make it easy to analyze results, implementations should log the results of each iteration (i.e. RPC) in a format the matches the following regexes:</p>
<ul>
<li>Upon success:<ul>
<li><code>soak iteration: \d+ elapsed_ms: \d+ peer: \S+ succeeded</code></li>
</ul>
</li>
<li>Upon failure:<ul>
<li><code>soak iteration: \d+ elapsed_ms: \d+ peer: \S+ failed:</code></li>
</ul>
</li>
</ul>
<p>This test must be configurable via a few different command line flags:</p>
<ul>
<li><code>soak_iterations</code>: Controls the number of RPCs to perform. This should default to 10.</li>
<li><code>soak_max_failures</code>: An inclusive upper limit on the number of RPC failures that should be tolerated (i.e. after which the test process should still exit 0). A failure is considered to be either a non-OK status or an RPC whose latency exceeds <code>soak_per_iteration_max_acceptable_latency_ms</code>. This should default to 0.</li>
<li><code>soak_per_iteration_max_acceptable_latency_ms</code>: An upper limit on the latency of a single RPC in order for that RPC to be considered successful. This should default to 1000.</li>
<li><code>soak_overall_timeout_seconds</code>: The overall number of seconds after which the test should stop and fail if <code>soak_iterations</code> have not yet been completed. This should default to <code>soak_per_iteration_max_acceptable_latency_ms</code> * <code>soak_iterations</code>.</li>
<li><code>soak_min_time_ms_between_rpcs</code>: The minimum time in milliseconds between consecutive RPCs. Useful for limiting QPS.</li>
</ul>
<p>The following is optional but encouraged to improve debuggability:</p>
<ul>
<li>Implementations should log the number of milliseconds that each RPC takes. Additionally, implementations should use a histogram of RPC latencies to log interesting latency percentiles at the end of the test (e.g. median, 90th, and max latency percentiles).</li>
</ul>
<h2><a class="anchor" id="autotoc_md137"></a>
channel_soak</h2>
<p>Similar to rpc_soak, but this time each RPC is performed on a new channel. The channel is created just before each RPC and is destroyed just after.</p>
<p>This test is configured with the same command line flags that the rpc_soak test is configured with, with only one semantic difference: when measuring an RPCs latency to see if it exceeds <code>soak_per_iteration_max_acceptable_latency_ms</code> or not, the creation of the channel should be included in that latency measurement, but the teardown of that channel should <b>not</b> be included in that latency measurement (channel teardown semantics differ widely between languages). This latency measurement should also be the value that is logged and recorded in the latency histogram.</p>
<h2><a class="anchor" id="autotoc_md138"></a>
orca_per_rpc</h2>
<p>The client verifies that a custom LB policy, which is integrated with ORCA APIs, will receive per-query metric reports from the backend.</p>
<p>The client will register the custom LB policy named <code>test_backend_metrics_load_balancer</code>, which using ORCA APIs already installed a per-query report listener. The interop-testing client will run with a service config to select the load balancing config (using argument <code>--service_config_json</code>), so that it effectively uses this newly registered custom LB policy. A load report reference can be passed from the call to the LB policy through, e.g. CallOptions, to receive metric reports. The LB policy will fill in the reference with the latest load report from the report listener. This way, together with server behaviors we can verify the expected metric reports are received.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#backend-metrics-report">Backend Metrics Report</a></li>
</ul>
<p>Procedures:</p><ul>
<li>The client sends a unary request: ``` { orca_per_rpc_report:{ cpu_utilization: 0.8210 memory_utilization: 0.5847 request_cost: { cost: 3456.32 } utilization: { util: 0.30499 } } } ```</li>
</ul>
<p>The call carries a reference to receive the load report, e.g. using CallOptions. The reference is passed to the custom LB policy as part of the <code>OrcaPerRequestReportListener</code> API.</p>
<p>Client asserts:</p><ul>
<li>The call is successful.</li>
<li>The per-query load report reference contains a metrics report that is identical to the metrics data sent in the request shown above.</li>
</ul>
<h2><a class="anchor" id="autotoc_md139"></a>
orca_oob</h2>
<p>The client verifies that a custom LB policy, which is integrated with ORCA APIs, will receive out-of-band metric reports from the backend.</p>
<p>The client will register the custom LB policy named <code>test_backend_metrics_load_balancer</code>. It has similar and additional functions as described in the <a href="#orca_per_rpc">orca_per_rpc</a> test. We use ORCA APIs to install an out-of-band report listener (configure load report interval to be 1s) in the LB policy. The interop-testing client will run with a service config to select the load balancing config(using argument <code>--service_config_json</code>), so that it effectively uses this newly registered custom LB policy. A load report reference can be passed from the call to the LB policy through, e.g. CallOptions, to receive metric reports. The test framework will fill in the reference with the latest load report from the report listener. This way, together with server behaviors we can verify the expected metric reports are received.</p>
<p>Server features:</p><ul>
<li><a href="#unarycall">UnaryCall</a></li>
<li><a href="#fullduplexcall">FullDuplexCall</a></li>
<li><a href="#backend-metrics-report">Backend Metrics Report</a></li>
</ul>
<p>Procedures:</p><ol type="1">
<li>Client starts a full duplex call and sends: ``` { orca_oob_report:{ cpu_utilization: 0.8210 memory_utilization: 0.5847 utilization: { util: 0.30499 } } response_parameters:{ size: 1 } } ```</li>
<li>After getting a response, client waits up to 10 seconds (or a total of 30s for the entire test case) to receive an OOB load report that matches the requested load report in step 1. To wait for load report, client may inject a callback to the custom LB policy, or poll the result by doing empty unary call that carries a reference, e.g. using CallOptions, that will be filled in by the custom LB policy as part of the <code>OrcaOobReportListener</code> API.</li>
<li>Then client sends: ``` { orca_oob_report:{ cpu_utilization: 0.29309 memory_utilization: 0.2 utilization: { util: 0.2039 } } response_parameters:{ size: 1 } } ```</li>
<li>After getting a response, client waits up to 10 seconds (or a total of 30s for the entire test case) to receive an OOB load report that matches the requested load report in step 3. Similar to step 2.</li>
<li>Client half closes the stream, and asserts the streaming call is successful.</li>
</ol>
<h2><a class="anchor" id="autotoc_md140"></a>
Experimental Tests</h2>
<p>These tests are not yet standardized, and are not yet implemented in all languages. Therefore they are not part of our interop matrix.</p>
<h3><a class="anchor" id="autotoc_md141"></a>
long_lived_channel</h3>
<p>The client performs a number of large_unary RPCs over a single long-lived channel with a fixed but configurable interval between each RPC.</p>
<h3><a class="anchor" id="autotoc_md142"></a>
concurrent_large_unary</h3>
<p>Status: TODO</p>
<p>Client performs 1000 large_unary tests in parallel on the same channel.</p>
<h3><a class="anchor" id="autotoc_md143"></a>
Flow control. Pushback at client for large messages (TODO: fix name)</h3>
<p>Status: TODO</p>
<p>This test verifies that a client sending faster than a server can drain sees pushback (i.e., attempts to send succeed only after appropriate delays).</p>
<h2><a class="anchor" id="autotoc_md144"></a>
TODO Tests</h2>
<h3><a class="anchor" id="autotoc_md145"></a>
High priority:</h3>
<p>Propagation of status code and message (yangg)</p>
<p>Multiple thousand simultaneous calls on same Channel (ctiller)</p>
<p>Metadata: client headers, server headers + trailers, binary+ascii</p>
<h3><a class="anchor" id="autotoc_md146"></a>
Normal priority:</h3>
<p>Cancel before start (ctiller)</p>
<p>Cancel after sent first message (ctiller)</p>
<p>Cancel after received headers (ctiller)</p>
<p>Timeout but completed before expire (zhaoq)</p>
<p>Multiple thousand simultaneous calls timeout on same Channel (ctiller)</p>
<h3><a class="anchor" id="autotoc_md147"></a>
Lower priority:</h3>
<p>Flow control. Pushback at client for large messages (abhishek)</p>
<p>Flow control. Pushback at server for large messages (abhishek)</p>
<p>Going over max concurrent streams doesn't fail (client controls itself) (abhishek)</p>
<p>RPC method not implemented (yangg)</p>
<p>Multiple thousand simultaneous calls on different Channels (ctiller)</p>
<p>Failed TLS hostname verification (ejona?)</p>
<p>Large amount of headers to cause CONTINUATIONs; 63K of 'X's, all in one header.</p>
<h3><a class="anchor" id="autotoc_md148"></a>
To priorize:</h3>
<p>Start streaming RPC but don't send any requests, server responds</p>
<h2><a class="anchor" id="autotoc_md149"></a>
Postponed Tests</h2>
<p>Resilience to buggy servers: These tests would verify that a client application isn't affected negatively by the responses put on the wire by a buggy server (e.g. the client library won't make the application crash).</p>
<p>Reconnect after transport failure</p>
<p>Reconnect backoff</p>
<p>Fuzz testing</p>
<h1><a class="anchor" id="autotoc_md150"></a>
Server</h1>
<p>Servers implement various named features for clients to test with. Server features are orthogonal. If a server implements a feature, it is always available for clients. Names are simple descriptions for developer communication and tracking.</p>
<p>Servers should accept these arguments:</p>
<ul>
<li>&ndash;port=PORT<ul>
<li>The port to listen on. For example, "8080"</li>
</ul>
</li>
<li>&ndash;use_tls=BOOLEAN<ul>
<li>Whether to use a plaintext or encrypted connection</li>
</ul>
</li>
</ul>
<p>Servers must support TLS with ALPN. They should use <a href="https://github.com/grpc/grpc/blob/master/src/core/tsi/test_creds/server1.pem">server1.pem</a> for their certificate.</p>
<h2><a class="anchor" id="autotoc_md151"></a>
EmptyCall</h2>
<p>Server implements EmptyCall which immediately returns the empty message.</p>
<h2><a class="anchor" id="autotoc_md152"></a>
UnaryCall</h2>
<p>Server implements UnaryCall which immediately returns a SimpleResponse with a payload body of size <code>SimpleRequest.response_size</code> bytes and type as appropriate for the <code>SimpleRequest.response_type</code>. If the server does not support the <code>response_type</code>, then it should fail the RPC with <code>INVALID_ARGUMENT</code>.</p>
<h2><a class="anchor" id="autotoc_md153"></a>
CacheableUnaryCall</h2>
<p>Server gets the default SimpleRequest proto as the request. The content of the request is ignored. It returns the SimpleResponse proto with the payload set to current timestamp. The timestamp is an integer representing current time with nanosecond resolution. This integer is formatted as ASCII decimal in the response. The format is not really important as long as the response payload is different for each request. In addition it adds</p><ol type="1">
<li>cache control headers such that the response can be cached by proxies in the response path. Server should be behind a caching proxy for this test to pass. Currently we set the max-age to 60 seconds.</li>
</ol>
<h2><a class="anchor" id="autotoc_md154"></a>
CompressedResponse</h2>
<p>When the client sets <code>response_compressed</code> to true, the server's response is sent back compressed. Note that <code>response_compressed</code> is present on both <code>SimpleRequest</code> (unary) and <code>StreamingOutputCallRequest</code> (streaming).</p>
<h2><a class="anchor" id="autotoc_md155"></a>
CompressedRequest</h2>
<p>When the client sets <code>expect_compressed</code> to true, the server expects the client request to be compressed. If it's not, it fails the RPC with <code>INVALID_ARGUMENT</code>. Note that <code>response_compressed</code> is present on both <code>SimpleRequest</code> (unary) and <code>StreamingOutputCallRequest</code> (streaming).</p>
<h2><a class="anchor" id="autotoc_md156"></a>
StreamingInputCall</h2>
<p>Server implements StreamingInputCall which upon half close immediately returns a StreamingInputCallResponse where aggregated_payload_size is the sum of all request payload bodies received.</p>
<h2><a class="anchor" id="autotoc_md157"></a>
StreamingOutputCall</h2>
<p>Server implements StreamingOutputCall by replying, in order, with one StreamingOutputCallResponse for each ResponseParameters in StreamingOutputCallRequest. Each StreamingOutputCallResponse should have a payload body of size ResponseParameters.size bytes, as specified by its respective ResponseParameters. After sending all responses, it closes with OK.</p>
<h2><a class="anchor" id="autotoc_md158"></a>
FullDuplexCall</h2>
<p>Server implements FullDuplexCall by replying, in order, with one StreamingOutputCallResponse for each ResponseParameters in each StreamingOutputCallRequest. Each StreamingOutputCallResponse should have a payload body of size ResponseParameters.size bytes, as specified by its respective ResponseParameters. After receiving half close and sending all responses, it closes with OK.</p>
<h2><a class="anchor" id="autotoc_md159"></a>
Echo Status</h2>
<p>When the client sends a response_status in the request payload, the server closes the stream with the status code and message contained within said response_status. The server will not process any further messages on the stream sent by the client. This can be used by clients to verify correct handling of different status codes and associated status messages end-to-end.</p>
<h2><a class="anchor" id="autotoc_md160"></a>
Echo Metadata</h2>
<p>When the client sends metadata with the key <code>"x-grpc-test-echo-initial"</code> with its request, the server sends back exactly this key and the corresponding value back to the client as part of initial metadata. When the client sends metadata with the key <code>"x-grpc-test-echo-trailing-bin"</code> with its request, the server sends back exactly this key and the corresponding value back to the client as trailing metadata.</p>
<h2><a class="anchor" id="autotoc_md161"></a>
Observe ResponseParameters.interval_us</h2>
<p>In StreamingOutputCall and FullDuplexCall, server delays sending a StreamingOutputCallResponse by the ResponseParameters' <code>interval_us</code> for that particular response, relative to the last response sent. That is, <code>interval_us</code> acts like a sleep <em>before</em> sending the response and accumulates from one response to the next.</p>
<p>Interaction with flow control is unspecified.</p>
<h2><a class="anchor" id="autotoc_md162"></a>
Echo Auth Information</h2>
<p>Status: Pending</p>
<h3><a class="anchor" id="autotoc_md163"></a>
Echo Authenticated Username</h3>
<p>If a SimpleRequest has fill_username=true and that request was successfully authenticated, then the SimpleResponse should have username filled with the canonical form of the authenticated source. The canonical form is dependent on the authentication method, but is likely to be a base 10 integer identifier or an email address.</p>
<h3><a class="anchor" id="autotoc_md164"></a>
Echo OAuth scope</h3>
<p>If a SimpleRequest has <code>fill_oauth_scope=true</code> and that request was successfully authenticated via OAuth, then the SimpleResponse should have oauth_scope filled with the scope of the method being invoked.</p>
<p>Although a general server-side feature, most test servers won't implement this feature. The TLS server <code>grpc-test.sandbox.googleapis.com:443</code> supports this feature. It requires at least the OAuth scope <code><a href="https://www.googleapis.com/auth/xapi.zoo">https://www.googleapis.com/auth/xapi.zoo</a></code> for authentication to succeed.</p>
<p>Discussion:</p>
<p>Ideally, this would be communicated via metadata and not in the request/response, but we want to use this test in code paths that don't yet fully communicate metadata.</p>
<h2><a class="anchor" id="autotoc_md165"></a>
Backend metrics report</h2>
<p>Server reports backend metrics data in both per-query and out-of-band cases, echoing metrics data from the unary or fullDuplex call.</p>
<p>Using ORCA APIs we install the per-query metrics reporting server interceptor, so that it can attach metrics per RPC. We also register the <code>OpenRCAService</code> implementation to the server, so that it can report metrics periodically. The minimum report interval in the ORCA service is set to 1 sec.</p>
<p>If <code>SimpleRequest.orca_per_rpc_report</code> is set in unary call, the server will add the metric data from <code>orca_per_rpc_report</code> to the RPC using the language's CallMetricRecorder.</p>
<p>If <code>SimpleRequest.orca_oob_report</code> is set in fullDuplexCall call, the server will first clear all the previous metrics data, and then add utilization metrics from <code>orca_oob_report</code> to the <code>OpenRCAService</code>. The server implementation should use a lock or similar mechanism to allow only one client to control the server's out-of-band reports until the end of the RPC. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 6 2023 16:09:47 for GRPC PHP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
