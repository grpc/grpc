<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GRPC PHP: gRPC Connectivity Semantics and API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GRPC PHP
   &#160;<span id="projectnumber">1.58.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">gRPC Connectivity Semantics and API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes the connectivity semantics for gRPC channels and the corresponding impact on RPCs. We then discuss an API.</p>
<h1><a class="anchor" id="autotoc_md82"></a>
States of Connectivity</h1>
<p>gRPC Channels provide the abstraction over which clients can communicate with servers.The client-side channel object can be constructed using little more than a DNS name. Channels encapsulate a range of functionality including name resolution, establishing a TCP connection (with retries and backoff) and TLS handshakes. Channels can also handle errors on established connections and reconnect, or in the case of HTTP/2 GO_AWAY, re-resolve the name and reconnect.</p>
<p>To hide the details of all this activity from the user of the gRPC API (i.e., application code) while exposing meaningful information about the state of a channel, we use a state machine with five states, defined below:</p>
<p>CONNECTING: The channel is trying to establish a connection and is waiting to make progress on one of the steps involved in name resolution, TCP connection establishment or TLS handshake. This may be used as the initial state for channels upon creation.</p>
<p>READY: The channel has successfully established a connection all the way through TLS handshake (or equivalent) and protocol-level (HTTP/2, etc) handshaking, and all subsequent attempt to communicate have succeeded (or are pending without any known failure).</p>
<p>TRANSIENT_FAILURE: There has been some transient failure (such as a TCP 3-way handshake timing out or a socket error). Channels in this state will eventually switch to the CONNECTING state and try to establish a connection again. Since retries are done with exponential backoff, channels that fail to connect will start out spending very little time in this state but as the attempts fail repeatedly, the channel will spend increasingly large amounts of time in this state. For many non-fatal failures (e.g., TCP connection attempts timing out because the server is not yet available), the channel may spend increasingly large amounts of time in this state.</p>
<p>IDLE: This is the state where the channel is not even trying to create a connection because of a lack of new or pending RPCs. New RPCs MAY be created in this state. Any attempt to start an RPC on the channel will push the channel out of this state to connecting. When there has been no RPC activity on a channel for a specified IDLE_TIMEOUT, i.e., no new or pending (active) RPCs for this period, channels that are READY or CONNECTING switch to IDLE. Additionally, channels that receive a GOAWAY when there are no active or pending RPCs should also switch to IDLE to avoid connection overload at servers that are attempting to shed connections. We will use a default IDLE_TIMEOUT of 300 seconds (5 minutes).</p>
<p>SHUTDOWN: This channel has started shutting down. Any new RPCs should fail immediately. Pending RPCs may continue running till the application cancels them. Channels may enter this state either because the application explicitly requested a shutdown or if a non-recoverable error has happened during attempts to connect communicate . (As of 6/12/2015, there are no known errors (while connecting or communicating) that are classified as non-recoverable.) Channels that enter this state never leave this state.</p>
<p>The following table lists the legal transitions from one state to another and corresponding reasons. Empty cells denote disallowed transitions.</p>
<table style="border: 1px solid black">
<tr>
<th>From/To </th><th>CONNECTING </th><th>READY </th><th>TRANSIENT_FAILURE </th><th>IDLE </th><th>SHUTDOWN  </th></tr>
<tr>
<th>CONNECTING </th><td>Incremental progress during connection establishment </td><td>All steps needed to establish a connection succeeded </td><td>Any failure in any of the steps needed to establish connection </td><td>No RPC activity on channel for IDLE_TIMEOUT </td><td>Shutdown triggered by application.  </td></tr>
<tr>
<th>READY </th><td></td><td>Incremental successful communication on established channel. </td><td>Any failure encountered while expecting successful communication on established channel. </td><td>No RPC activity on channel for IDLE_TIMEOUT <br  />
OR<br  />
upon receiving a GOAWAY while there are no pending RPCs. </td><td>Shutdown triggered by application.  </td></tr>
<tr>
<th>TRANSIENT_FAILURE </th><td>Wait time required to implement (exponential) backoff is over. </td><td></td><td></td><td></td><td>Shutdown triggered by application.  </td></tr>
<tr>
<th>IDLE </th><td>Any new RPC activity on the channel </td><td></td><td></td><td></td><td>Shutdown triggered by application.  </td></tr>
<tr>
<th>SHUTDOWN </th><td></td><td></td><td></td><td></td><td></td></tr>
</table>
<h1><a class="anchor" id="autotoc_md83"></a>
Channel State API</h1>
<p>All gRPC libraries will expose a channel-level API method to poll the current state of a channel. In C++, this method is called GetState and returns an enum for one of the five legal states. It also accepts a boolean <code>try_to_connect</code> to transition to CONNECTING if the channel is currently IDLE. The boolean should act as if an RPC occurred, so it should also reset IDLE_TIMEOUT.</p>
<div class="fragment"><div class="line">grpc_connectivity_state GetState(<span class="keywordtype">bool</span> try_to_connect);</div>
</div><!-- fragment --><p>All libraries should also expose an API that enables the application (user of the gRPC API) to be notified when the channel state changes. Since state changes can be rapid and race with any such notification, the notification should just inform the user that some state change has happened, leaving it to the user to poll the channel for the current state.</p>
<p>The synchronous version of this API is:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> WaitForStateChange(grpc_connectivity_state source_state, gpr_timespec deadline);</div>
</div><!-- fragment --><p>which returns <code>true</code> when the state is something other than the <code>source_state</code> and <code>false</code> if the deadline expires. Asynchronous- and futures-based APIs should have a corresponding method that allows the application to be notified when the state of a channel changes.</p>
<p>Note that a notification is delivered every time there is a transition from any state to any <em>other</em> state. On the other hand the rules for legal state transition, require a transition from CONNECTING to TRANSIENT_FAILURE and back to CONNECTING for every recoverable failure, even if the corresponding exponential backoff requires no wait before retry. The combined effect is that the application may receive state change notifications that appear spurious. e.g., an application waiting for state changes on a channel that is CONNECTING may receive a state change notification but find the channel in the same CONNECTING state on polling for current state because the channel may have spent infinitesimally small amount of time in the TRANSIENT_FAILURE state. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 6 2023 16:09:47 for GRPC PHP by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
