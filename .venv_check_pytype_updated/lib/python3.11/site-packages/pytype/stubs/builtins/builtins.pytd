# This file should eventually track typeshed a lot more closely, to
# minimise the diffs we have to maintain here.

from typing import (
    AbstractSet, Any, AsyncGenerator, AsyncIterable, AsyncIterator, Awaitable,
    BinaryIO, Callable, Concatenate, Coroutine, Dict, FrozenSet, Generator,
    Generic, Hashable, IO, ItemsView, Iterable, Iterator, KeysView, List,
    Literal, Mapping, MutableSequence, NoReturn, Optional, overload, ParamSpec,
    Protocol, Reversible, Self, Sequence, Set, Sized, SupportsAbs,
    SupportsBytes, SupportsComplex, SupportsFloat, SupportsIndex, SupportsInt,
    TextIO, Tuple, Type, Union, ValuesView)

_T = TypeVar('_T')
_T2 = TypeVar('_T2')
_T3 = TypeVar('_T3')
_T4 = TypeVar('_T4')
_T5 = TypeVar('_T5')
_S = TypeVar('_S')
_K = TypeVar('_K')
_V = TypeVar('_V')
_K2 = TypeVar('_K2')
_V2 = TypeVar('_V2')

_P = ParamSpec('_P')

class _Summable(Protocol[_T]):
  def __add__(self, __y: _T) -> _T: ...
_SummableT = TypeVar('_SummableT', bound=_Summable)

class _SupportsKeysAndGetItem(Protocol[_K, _V]):
  def keys(self) -> Iterable[_K]: ...
  def __getitem__(self, __key: _K) -> _V: ...

# See b/142884093. We redefine AnyStr rather than importing it to avoid pytype
# mistakenly treating it as a public builtin.
_AnyStr = TypeVar('_AnyStr', bytes, str)

# isinstance() and issubclass() can take a type or an arbitrarily nested
# tuple of types. This adds support for a few levels.
TypeTuple = Union[type, tuple[Union[type, tuple[type, ...]], ...]]

def __import__(name: Union[str, bytes, bytearray], *args, **kwargs) -> module: ...
def abs(x) -> Any: ...

if sys.version_info >= (3, 10):
    def aiter(i: AsyncIterable[_T]) -> AsyncIterator[_T]: ...

def all(iterable) -> bool: ...

if sys.version_info >= (3, 10):
    @overload
    def anext(i: AsyncIterator[_T]) -> Awaitable[_T]: ...
    @overload
    def anext(i: AsyncIterator[_T], default: _T2) -> Awaitable[_T | _T2]: ...

def any(iterable) -> bool: ...
def ascii(__obj: object) -> str: ...
def apply(object: Callable, *args, **kwargs) -> NoneType: ...
def assert_type(val, typ, /): ...
def bin(number: Union[int, float]) -> str: ...
def breakpoint(*args, **kwargs) -> NoneType: ...
def callable(obj) -> bool: ...
def chr(i: int) -> str: ...
def cmp(x, y) -> int: ...
def coerce(x: int, y: int) -> tuple[int, int]: ...
def coerce(x: Union[int, float], y: float) -> tuple[float, float]: ...
def coerce(x: Union[int, float, complex], y: complex) -> tuple[complex, complex]: ...
def coerce(x: float, y: int) -> tuple[float, float]: ...
def coerce(x, y) -> tuple[object, object]: ...
def coerce(x: list[_T], y: list[_T]) -> tuple[list[_T], list[_T]]: ...
def coerce(x: tuple[_T, ...], y: tuple[_T, ...]) -> tuple[tuple[_T, ...], tuple[_T, ...]]: ...
def coerce(x: complex, y: Union[int, float]) -> tuple[complex, complex]: ...
def coerce(x: Callable, y: Callable) -> tuple[Callable, Callable]: ...
def coerce(x: type, y: type) -> tuple[type, type]: ...
def coerce(x: _T, y: _T) -> tuple[_T, _T]: ...  # E.g. coerce([], [1]) -> ([], [1])
def compile(source, filename: str, mode: str, flags: int = ..., dont_inherit: int = ..., optimize: int = ...) -> code: ...
def delattr(object, name: Union[str, bytes, bytearray]) -> None: ...
def dir(*args, **kwargs) -> list[str]: ...

class _SupportsDivMod(Protocol[_T, _T2, _T3]):
  def __divmod__(self, other: _T) -> tuple[_T2, _T3]: ...

@overload
def divmod(x: int, y: int) -> tuple[int, int]: ...
@overload
def divmod(x: Union[int, float], y: Union[int, float]) -> tuple[float, float]: ...
@overload
def divmod(x: Union[int, float, complex], y: Union[int, float, complex]) -> tuple[complex, complex]: ...
@overload
def divmod(x: _SupportsDivMod[_T, _T2, _T3], y: _T) -> tuple[_T2, _T3]: ...

def eval(src, *args, **kwargs) -> Any: ...  # Can't say *anything* about the result -- different from "-> object"
def exec(src, *args, **kwargs) -> NoneType: ...
def execfile(filename: str, *args, **kwargs) -> NoneType: ...
def exit(code: Any = ...) -> NoReturn: ...
def filter(function: None, iterable: Iterable[Optional[_T]]) -> Iterator[_T]: ...
def filter(function: Callable[[_T], Any], iterable: Iterable[_T]) -> Iterator[_T]: ...
def format(value, *args, **kwargs) -> str: ...
def getattr(value, attr: str, *args, **kwargs) -> Any: ...
def globals() -> dict[str, Any]: ...
def hasattr(object, name: str) -> bool: ...
def hash(obj) -> int: ...
def hex(number: int) -> str: ...
def id(obj) -> int: ...
def input(prompt: str = ...) -> str: ...
def intern(string: Union[str, bytearray]) -> str: ...
def isinstance(object, class_or_type_or_tuple: TypeTuple) -> bool: ...
def issubclass(cls: type, class_or_type_or_tuple: TypeTuple) -> bool: ...
def iter(collection: bytearray) -> bytearray_iterator: ...
def iter(collection: str) -> Iterator[str]: ...
def iter(collection: list[_T]) -> listiterator[_T]: ...
def iter(collection: tuple[_T, ...]) -> tupleiterator[_T]: ...
def iter(collection: set[_T]) -> setiterator[_T]: ...
def iter(collection: dict[_T, _T2]) -> Iterator[_T]: ...
def iter(collection: Generator[_T]) -> Generator[_T]: ...
def iter(collection: Iterable[_T]) -> Iterator[_T]: ...
def iter(func: typing.Callable[[], Union[_T, None]], sentinel: None, /) -> Iterator[_T]: ...
def iter(func: typing.Callable[[], _T], sentinel: object, /) -> Iterator[_T]: ...
def len(obj: Sized) -> int: ...
def locals() -> dict[str, object]: ...
@overload
def map(function, *sequences: Iterable[nothing]) -> Iterator[nothing]: ...
@overload
def map(__func: Callable[[_T], _S], __iter1: Iterable[_T]) -> Iterator[_S]: ...
@overload
def map(__func: Callable[[_T, _T2], _S], __iter1: Iterable[_T], __iter2: Iterable[_T2]) -> Iterator[_S]: ...
@overload
def map(
    __func: Callable[[_T, _T2, _T3], _S], __iter1: Iterable[_T], __iter2: Iterable[_T2], __iter3: Iterable[_T3]
) -> Iterator[_S]: ...
@overload
def map(
    __func: Callable[[_T, _T2, _T3, _T4], _S],
    __iter1: Iterable[_T],
    __iter2: Iterable[_T2],
    __iter3: Iterable[_T3],
    __iter4: Iterable[_T4],
) -> Iterator[_S]: ...
@overload
def map(
    __func: Callable[[_T, _T2, _T3, _T4, _T5], _S],
    __iter1: Iterable[_T],
    __iter2: Iterable[_T2],
    __iter3: Iterable[_T3],
    __iter4: Iterable[_T4],
    __iter5: Iterable[_T5],
) -> Iterator[_S]: ...
@overload
def map(
    __func: Callable[..., _S],
    __iter1: Iterable[Any],
    __iter2: Iterable[Any],
    __iter3: Iterable[Any],
    __iter4: Iterable[Any],
    __iter5: Iterable[Any],
    __iter6: Iterable[Any],
    *iterables: Iterable[Any],
) -> Iterator[_S]: ...
def max(iterable: Iterable[_T], key: Callable = ..., default: Any = ...) -> _T: ...
def max(arg1: _T, arg2: _T2, *, key: Callable = ...) -> Union[_T, _T2]: ...
def max(arg1: _T, arg2: _T2, arg3: _T3, *, key: Callable = ...) -> Union[_T, _T2, _T3]: ...
def max(arg1: _T, arg2: _T2, arg3: _T3, arg4: _T4, *, key: Callable = ...) -> Union[_T, _T2, _T3, _T4]: ...
def max(arg1: _T, arg2: _T, arg3: _T, arg4: _T, arg5: _T, *args: _T, key: Callable = ...) -> _T: ...
def min(iterable: Iterable[_T], key: Callable = ..., default: Any = ...) -> _T: ...
def min(arg1: _T, arg2: _T2, *, key: Callable = ...) -> Union[_T, _T2]: ...
def min(arg1: _T, arg2: _T2, arg3: _T3, *, key: Callable = ...) -> Union[_T, _T2, _T3]: ...
def min(arg1: _T, arg2: _T2, arg3: _T3, arg4: _T4, *, key: Callable = ...) -> Union[_T, _T2, _T3, _T4]: ...
def min(arg1: _T, arg2: _T, arg3: _T, arg4: _T, arg5: _T, *args: _T, key: Callable = ...) -> _T: ...
def next(iterator: Iterator[_T], default: _T2 = ...) -> Union[_T, _T2]: ...
def oct(number: int) -> str: ...
def ord(c: Union[str, bytes]) -> int: ...
def pow(x: int, y: int, *args, **kwargs) -> Union[float, int]: ...
def pow(x: Union[int, float, complex], y: complex, *args, **kwargs) -> complex: ...
def pow(x: Union[int, float], y: float, *args, **kwargs) -> float: ...
def pow(x: float, y: int, *args, **kwargs) -> float: ...
def pow(x: complex, y: Union[int, float], *args, **kwargs) -> complex: ...
def print(*args, **kwargs) -> NoneType: ...
def quit() -> NoReturn: ...
def reduce(function: Callable[..., _T], iterable: Iterable[_T2]) -> Union[_T, _T2]: ...
def reduce(function: Callable, iterable: Iterable[nothing], initial: _T) -> _T: ...
def reduce(function: Callable[..., _T], iterable: Iterable, initial) -> _T: ...
# No reload() in Python3
def reload(mod: module) -> module: ...
def repr(x) -> str: ...
def reveal_type(obj: _T, /) -> _T: ...
def round(number: Union[int, float, typing.SupportsRound]) -> int: ...
def round(number: Union[int, float, typing.SupportsRound], *args, **kwargs) -> float: ...
def setattr(object, name: str, value) -> NoneType: ...
def sorted(iterable: Iterable[_T], *args, **kwargs) -> list[_T]: ...
def sum(iterable: Iterable[_SummableT]) -> _SummableT: ...
def sum(iterable: Iterable[_T], start: _T) -> _T: ...
def vars(*args, **kwargs) -> dict[str, Any]: ...

if sys.version_info >= (3, 10):
    class zip(Iterator[_S]):
        @overload
        def __new__(cls, *, strict: bool = ...) -> zip[nothing]: ...
        @overload
        def __new__(cls, seq: Iterable[nothing], *, strict: bool = ...) -> zip[nothing]: ...
        @overload
        def __new__(cls, seq: Iterable[_T], *, strict: bool = ...) -> zip[Tuple[_T]]: ...
        @overload
        def __new__(cls, seq1: Iterable[nothing], seq2: Iterable, *, strict: bool = ...) -> zip[nothing]: ...
        @overload
        def __new__(cls, seq1: Iterable, seq2: Iterable[nothing], *, strict: bool = ...) -> zip[nothing]: ...
        @overload
        def __new__(cls, seq1: Iterable[_T], seq2: Iterable[_T2], *, strict: bool = ...) -> zip[Tuple[_T, _T2]]: ...
        @overload
        def __new__(cls, seq1, seq2, seq3, *seqs: Iterable, strict: bool = ...) -> zip[tuple]: ...
        def __iter__(self) -> Self: ...
else:
    class zip(Iterator[_S]):
        @overload
        def __new__(cls) -> zip[nothing]: ...
        @overload
        def __new__(cls, seq: Iterable[nothing]) -> zip[nothing]: ...
        @overload
        def __new__(cls, seq: Iterable[_T]) -> zip[Tuple[_T]]: ...
        @overload
        def __new__(cls, seq1: Iterable[nothing], seq2: Iterable) -> zip[nothing]: ...
        @overload
        def __new__(cls, seq1: Iterable, seq2: Iterable[nothing]) -> zip[nothing]: ...
        @overload
        def __new__(cls, seq1: Iterable[_T], seq2: Iterable[_T2]) -> zip[Tuple[_T, _T2]]: ...
        @overload
        def __new__(cls, seq1, seq2, seq3, *seqs: Iterable) -> zip[tuple]: ...
        def __iter__(self) -> Self: ...

# Keyword constants cannot be assigned here; they are defined in the parser.
# False: bool = ...
# True: bool = ...
# None: NoneType = ...
# __debug__: bool = ...

NotImplemented: _NotImplementedType
Ellipsis: ellipsis

class object():
    __slots__ = []  # if used as base class
    __bases__: Tuple[Any, ...]
    __dict__: Dict[str, Any]
    __doc__: str
    __mro__: list[Any]
    __name__: str
    __subclasses__: Any
    __subclasshook__: Any
    # InterpreterClass will contain this, too:
    __module__: str
    def __init__(self) -> NoneType: ...
    # Used by special_builtins.Object to handle super.__init__.
    def __init__extra_args(self, *args, **kwargs) -> NoneType: ...
    def __sizeof__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __format__(self, format_spec: str, /) -> str: ...
    def __delattr__(self, name: str, /) -> None: ...
    def __dir__(self) -> list[str]: ...
    def __eq__(self, other, /) -> bool: ...
    def __ne__(self, other, /) -> bool: ...
    def __ge__(self, other, /) -> bool: ...
    def __gt__(self, other, /) -> bool: ...
    def __le__(self, other, /) -> bool: ...
    def __lt__(self, other, /) -> bool: ...
    def __hash__(self) -> int: ...
    def __setattr__(self, name, value, /) -> None: ...
    def __getattribute__(self, name, /) -> Any: ...
    def __reduce__(self) -> str | tuple[Any, ...]: ...
    def __new__(cls: Type[_T]) -> _T: ...
    # Used by special_builtins.Object to handler super.__new__.
    @staticmethod
    def __new__extra_args(cls: Type[_T], *args, **kwargs) -> _T: ...
    @classmethod
    def __init_subclass__(cls) -> None: ...
    if sys.version_info >= (3, 11):
        def __getstate__(self) -> object: ...

# old style class. classobj is in fact a subclass of object in Python.
class classobj(object):
    __slots__ = []
    __bases__: Tuple[Any, ...]
    __dict__: Dict[str, Any]
    __doc__: str
    __name__: str
    def __init__(self) -> NoneType: ...
    def __repr__(self) -> str: ...
    def __cmp__(self, y) -> bool: ...

# Not actually a builtin
class _NotImplementedType(bool):
    pass

class NoneType(object):
    # Note that we don't do __slots__ = [] here. (I.e., we ignore STORE_ATTR
    # errors on NoneType). This is symmetric with LOAD_ATTR.
    pass

class ellipsis(object):
    __slots__ = []

class property(object):
    fget: Callable[[Any], Any] | None
    fset: Callable[[Any, Any], None] | None
    fdel: Callable[[Any], None] | None
    def __init__(self, fget=..., fset=..., fdel=..., doc=...) -> NoneType: ...
    def __get__(self, *args, **kwargs) -> Any: ...
    def __set__(self, *args, **kwargs) -> Any: ...
    def __delete__(self, *args, **kwargs) -> Any: ...

# staticmethod and classmethod are handled in special_builtins.py.
class staticmethod(typing.Callable, Generic[_P, _T]):
    __slots__ = []
    def __init__(self: staticmethod[_T], __f: Callable[_P, _T]) -> None: ...
    def __get__(self, __obj: _T2 | None, __type: Type[_T2] | None = ...) -> Callable[_P, _T]: ...

class classmethod(typing.Callable, Generic[_T, _P, _T2]):
    __slots__ = []
    def __init__(self: classmethod[_T2],
                 __f: Callable[Concatenate[_T, _P], _T2]) -> None: ...
    def __get__(self, __obj: _T3 | None, __type: Type[_T3] | None = ...) -> Callable[_P, _T2]: ...

_T_str = TypeVar('_T_str', bound=str)
class str(Sequence[str], Hashable):
    __slots__ = []
    def __new__(cls: Type[_T_str], object = ..., encoding: str = ..., errors: str = ...) -> _T_str: ...
    def __init__(self, object) -> NoneType: ...
    def __init__(self, bytes: bytes, encoding: str = ..., errors: str = ...) -> NoneType: ...
    def __init__(self) -> NoneType: ...
    def __iter__(self) -> Iterator[str]: ...
    def __add__(self, y: str) -> str: ...
    def __contains__(self, y) -> bool: ...
    def __getitem__(self, index: Union[int, slice]) -> str: ...
    def __getslice__(self, i: Optional[int], j: Optional[int]) -> str: ...
    def __len__(self) -> int: ...
    def __mod__(self, y) -> str: ...
    def __mul__(self, n: int) -> str: ...
    def __rmul__(self, n: int) -> str: ...
    def __hash__(self) -> int: ...
    if PYTYPE_OPTIONS.strict_primitive_comparisons:
        def __ge__(self, y: str, /) -> bool: ...
        def __gt__(self, y: str, /) -> bool: ...
        def __le__(self, y: str, /) -> bool: ...
        def __lt__(self, y: str, /) -> bool: ...
    def capitalize(self) -> str: ...
    def casefold(self) -> str: ...  # see section 3.13 of the Unicode standard
    def center(self, width: int, fillchar: str = ...) -> str: ...
    def count(self, sub: str, *args, **kwargs) -> int: ...
    def encode(self, encoding: str = ..., errors: str = ...) -> bytes: ...
    def endswith(self, suffix: Union[str, Tuple[str, ...]], start: Optional[int] = ..., end: Optional[int] = ...) -> bool: ...
    def expandtabs(self, tabsize: int = ...) -> str: ...
    def find(self, sub: str, *args, **kwargs) -> int: ...
    # The 'self' argument here is intentionally named something else so that
    # "blah".format(self=self) works.
    def format(self_, *args, **kwargs) -> str: ...
    def format_map(self, *args, **kwargs) -> str: ...
    def index(self, sub: str, *args, **kwargs) -> int: ...
    def isalnum(self) -> bool: ...
    def isalpha(self) -> bool: ...
    def isascii(self) -> bool: ...
    def isdecimal(self) -> bool: ...
    def isdigit(self) -> bool: ...
    def isidentifier(self) -> bool: ...
    def islower(self) -> bool: ...
    def isnumeric(self) -> bool: ...
    def isprintable(self) -> bool: ...
    def isspace(self) -> bool: ...
    def istitle(self) -> bool: ...
    def isupper(self) -> bool: ...
    def join(self, iterable: Union[str, Iterable[str]]) -> str: ...
    def join(self, iterable: Iterable[nothing]) -> str: ...
    def ljust(self, width: int, fillchar: str = ...) -> str: ...
    def lower(self) -> str: ...
    def lstrip(self, chars: Optional[str] = ...) -> str: ...
    def partition(self, sep: str) -> Tuple[str, str, str]: ...
    if sys.version_info >= (3, 9):
      def removeprefix(self, prefix: str) -> str: ...
      def removesuffix(self, suffix: str) -> str: ...
    def replace(self, old: str, new: str, *args, **kwargs) -> str: ...
    def rfind(self, sub: str, *args, **kwargs) -> int: ...
    def rindex(self, sub: str, *args, **kwargs) -> int: ...
    def rjust(self, width: int, *args, **kwargs) -> str: ...
    def rpartition(self, sep: str) -> tuple[str, str, str]: ...
    def rsplit(self, sep: Optional[str] = ..., maxsplit: int = ...) -> List[str]: ...
    def rstrip(self, chars: Optional[str] = ...) -> str: ...
    def split(self, sep: Optional[str] = ..., maxsplit: int = ...) -> List[str]: ...
    def splitlines(self, keepends: bool = ...) -> List[str]: ...
    def startswith(self, prefix: Union[str, Tuple[str, ...]], start: Optional[int] = ..., end: Optional[int] = ...) -> bool: ...
    def strip(self, chars: Optional[str] = ...) -> str: ...
    def swapcase(self) -> str: ...
    def title(self) -> str: ...
    def translate(self, table: Union[Mapping, Sequence]) -> str: ...
    def upper(self) -> str: ...
    def zfill(self, width: int) -> str: ...
    @staticmethod
    def maketrans(*args, **kwargs) -> dict: ...

class bytes(Sequence[int]):
    def __init__(self, ints: Iterable[int]) -> NoneType: ...
    def __init__(self, bytes: SupportsBytes) -> NoneType: ...
    def __init__(self, string: str, encoding: str, errors: str = ...) -> NoneType: ...
    def __init__(self, length: int) -> NoneType: ...
    def __init__(self) -> NoneType: ...

    def __add__(self, s: bytes) -> bytes: ...
    def __buffer__(self, __flags: int) -> memoryview: ...
    if sys.version_info >= (3, 11):
      def __bytes__(self) -> bytes: ...
    def __contains__(self, o) -> bool: ...
    def __float__(self) -> float: ...
    def __getitem__(self, i: int) -> int: ...
    def __getitem__(self, s: slice) -> bytes: ...
    def __int__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def __len__(self) -> int: ...
    def __mod__(self, value) -> bytes: ...
    def __mul__(self, n: int) -> bytes: ...
    def __rmul__(self, n: int) -> bytes: ...
    if PYTYPE_OPTIONS.strict_primitive_comparisons:
        def __lt__(self, y: bytes, /) -> bool: ...
        def __le__(self, y: bytes, /) -> bool: ...
        def __gt__(self, y: bytes, /) -> bool: ...
        def __ge__(self, y: bytes, /) -> bool: ...

    def capitalize(self) -> bytes: ...
    def center(self, width: int, fillchar: bytes = ...) -> bytes: ...
    def count(self, sub: Union[bytes, int], start: Optional[int] = ..., end: Optional[int] = ...) -> int: ...
    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...
    def endswith(self, suffix: Union[bytes, Tuple[bytes, ...]]) -> bool: ...
    def expandtabs(self, tabsize: int = ...) -> bytes: ...
    def find(self, sub: Union[bytes, int], start: Optional[int] = ..., end: Optional[int] = ...) -> int: ...
    def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
    def index(self, sub: Union[bytes, int], start: Optional[int] = ..., end: Optional[int] = ...) -> int: ...
    def isalnum(self) -> bool: ...
    def isalpha(self) -> bool: ...
    def isascii(self) -> bool: ...
    def isdigit(self) -> bool: ...
    def islower(self) -> bool: ...
    def isspace(self) -> bool: ...
    def istitle(self) -> bool: ...
    def isupper(self) -> bool: ...
    def join(self, iterable: Iterable[bytes]) -> bytes: ...
    def ljust(self, width: int, fillchar: bytes = ...) -> bytes: ...
    def lower(self) -> bytes: ...
    def lstrip(self, chars: Optional[bytes] = ...) -> bytes: ...
    def partition(self, sep: bytes) -> Tuple[bytes, bytes, bytes]: ...
    if sys.version_info >= (3, 9):
      def removeprefix(self, prefix: bytes) -> bytes: ...
      def removesuffix(self, suffix: bytes) -> bytes: ...
    def replace(self, old: bytes, new: bytes, count: int = ...) -> bytes: ...
    def rfind(self, sub: Union[bytes, int], start: Optional[int] = ..., end: Optional[int] = ...) -> int: ...
    def rindex(self, sub: Union[bytes, int], start: Optional[int] = ..., end: Optional[int] = ...) -> int: ...
    def rjust(self, width: int, fillchar: bytes = ...) -> bytes: ...
    def rpartition(self, sep: bytes) -> Tuple[bytes, bytes, bytes]: ...
    def rsplit(self, sep: Optional[bytes] = ..., maxsplit: int = ...) -> List[bytes]: ...
    def rstrip(self, chars: Optional[bytes] = ...) -> bytes: ...
    def split(self, sep: Optional[bytes] = ..., maxsplit: int = ...) -> List[bytes]: ...
    def splitlines(self, keepends: bool = ...) -> List[bytes]: ...
    def startswith(self, prefix: Union[bytes, Tuple[bytes, ...]]) -> bool: ...
    def strip(self, chars: Optional[bytes] = ...) -> bytes: ...
    def swapcase(self) -> bytes: ...
    def title(self) -> bytes: ...
    def translate(self, table: Optional[bytes], delete: bytes = ...) -> bytes: ...
    def upper(self) -> bytes: ...
    def zfill(self, width: int) -> bytes: ...

    @classmethod
    def fromhex(cls, s: str) -> bytes: ...
    @classmethod
    def maketrans(cls, frm: bytes, to: bytes) -> bytes: ...

class bytearray(MutableSequence[int]):
    __slots__ = []
    def __init__(self, iterable_of_ints) -> NoneType: ...
    def __init__(self) -> NoneType: ...
    def __init__(self, source: str, encoding: str, errors: str = ...) -> NoneType: ...
    def __add__(self, y: Union[str, bytes, bytearray]) -> bytearray: ...
    def __alloc__(self) -> int: ...
    def __buffer__(self, __flags: int) -> memoryview: ...
    def __contains__(self, y: Union[str, int, bytearray, bytes]) -> bool: ...
    def __delitem__(self, y: Union[int, slice]) -> NoneType: ...
    def __getitem__(self, index: int) -> int: ...
    def __getitem__(self, index: slice) -> bytearray: ...
    def __iter__(self) -> bytearray_iterator: ...
    def __len__(self) -> int: ...
    def __mul__(self, n: int) -> bytearray: ...
    def __setitem__(self, index: int, y: int) -> None: ...
    def __setitem__(self, index: slice, y: Iterable[Union[int, bytes]]) -> None: ...
    def append(self, int: int) -> NoneType: ...
    def capitalize(self) -> bytearray: ...
    def center(self, width: int, *args, **kwargs) -> bytearray: ...
    def clear(self) -> None: ...
    def copy(self) -> bytearray: ...
    def count(self, sub: bytearray, *args, **kwargs) -> int: ...
    def decode(self, *args, **kwargs) -> str: ...
    def endswith(self, suffix: Union[bytes, bytearray, tuple[Union[bytes, bytearray], ...]], *args, **kwargs) -> bool: ...
    def expandtabs(self, *args, **kwargs) -> bytearray: ...
    def extend(self, iterable_int) -> NoneType: ...
    def find(self, sub: Union[bytes, bytearray], *args, **kwargs) -> int: ...
    def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...
    def index(self, sub: Union[bytes, bytearray], *args, **kwargs) -> int: ...
    def insert(self, index: int, int: Union[bytes, int]) -> NoneType: ...
    def isalnum(self) -> bool: ...
    def isalpha(self) -> bool: ...
    def isascii(self) -> bool: ...
    def isdigit(self) -> bool: ...
    def islower(self) -> bool: ...
    def isspace(self) -> bool: ...
    def istitle(self) -> bool: ...
    def isupper(self) -> bool: ...
    def join(self, iterable: Iterable[Union[nothing, bytes, bytearray]]) -> bytearray: ...
    def ljust(self, width: int, *args, **kwargs) -> bytearray: ...
    def lower(self) -> bytearray: ...
    def lstrip(self, *args, **kwargs) -> bytearray: ...
    def partition(self, sep: Union[bytes, int, bytearray, Iterator]) -> tuple[bytearray, bytearray, bytearray]: ...
    def pop(self, *args, **kwargs) -> int: ...
    def remove(self, int: Union[bytes, int]) -> NoneType: ...
    if sys.version_info >= (3, 9):
      def removeprefix(self, prefix: bytes) -> bytearray: ...
      def removesuffix(self, suffix: bytes) -> bytearray: ...
    def replace(self, old: Union[bytes, bytearray], new: Union[bytes, bytearray], *args, **kwargs) -> bytearray: ...
    def reverse(self) -> NoneType: ...
    def rfind(self, sub: Union[bytes, bytearray], *args, **kwargs) -> int: ...
    def rindex(self, sub: Union[bytes, bytearray], *args, **kwargs) -> int: ...
    def rjust(self, width: int, *args, **kwargs) -> bytearray: ...
    def rpartition(self, sep: Union[bytes, int, bytearray, Iterator]) -> tuple[bytearray, bytearray, bytearray]: ...
    def rsplit(self, sep: Union[bytes, bytearray], *args, **kwargs) -> list[bytearray]: ...
    def rsplit(self) -> list[bytearray]: ...
    def rstrip(self, *args, **kwargs) -> bytearray: ...
    def split(self, *args, **kwargs) -> list[bytearray]: ...
    def splitlines(self, *args, **kwargs) -> list[bytearray]: ...
    def startswith(self, prefix: Union[bytes, bytearray, tuple[Union[bytes, bytearray], ...]], *args, **kwargs) -> bool: ...
    def strip(self, *args, **kwargs) -> bytearray: ...
    def swapcase(self) -> bytearray: ...
    def title(self) -> bytearray: ...
    def upper(self) -> bytearray: ...
    def zfill(self, width: int) -> bytearray: ...

    @classmethod
    def fromhex(cls, string: str) -> bytearray: ...

class bytearray_iterator(Iterator[int]):
    __slots__ = []
    def __iter__(self) -> bytearray_iterator: ...
    def __next__(self) -> int: ...

class dict_keys(KeysView[_T]):
    __slots__ = []
    def __contains__(self, y) -> bool: ...
    def __iter__(self) -> Iterator[_T]: ...
    def __len__(self) -> int: ...
    def __and__(self, y: Iterable) -> set[_T]: ...
    def __sub__(self, y: Iterable) -> set[_T]: ...
    def __or__(self, y: Iterable[_T2]) -> set[Union[_T, _T2]]: ...
    def __xor__(self, y: Iterable[_T2]) -> set[Union[_T, _T2]]: ...

class dict_values(ValuesView[_T]):
    __slots__ = []
    def __iter__(self) -> Iterator[_T]: ...
    def __len__(self) -> int: ...

class dict_items(ItemsView[_K, _V], object):
    __slots__ = []
    def __and__(self, y: Union[set, dict_items]) -> set[tuple[_K, _V]]: ...
    def __or__(self, y: Union[set, dict_items[_K2, _V2]]) -> set[tuple[Union[_K, _K2], Union[_V, _V2]]]: ...
    def __xor__(self, y: Union[set, dict_items[_K2, _V2]]) -> set[tuple[Union[_K, _K2], Union[_V, _V2]]]: ...
    def __sub__(self, y: Union[set, dict_items[_K2, _V2]]) -> set[tuple[_K, _V]]: ...
    def __contains__(self, y) -> bool: ...
    def __iter__(self) -> Iterator[Tuple[_K,_V]]: ...
    def __len__(self) -> int: ...

class dict(Dict[_K, _V]):
    __slots__ = []
    def __init__(self) -> NoneType:
        self = dict[nothing, nothing]
    def __init__(self, list: list[nothing]) -> NoneType:
        self = dict[nothing, nothing]
    def __init__(self, mapping: Mapping[_K2, _V2]) -> NoneType:
        self = dict[_K2, _V2]
    def __init__(self, iterable: Iterable[tuple[_K2, _V2]]) -> NoneType:
        self = dict[_K2, _V2]
    def __init__(self, *args, **kwargs) -> NoneType:
        self = dict[Any, Any]
    def __delitem__(self, y: _K) -> NoneType: ...
    def __iter__(self) -> Iterator[_K]: ...
    def __setitem__(self, i: _K2, y: _V2) -> NoneType:
      self = dict[Union[_K, _K2], Union[_V, _V2]]
    def clear(self) -> NoneType:
        self = dict[nothing, nothing]
    def copy(self: _T) -> _T: ...
    @staticmethod
    def fromkeys(keys: Iterable[_K]) -> Dict[_K, NoneType]: ...
    @staticmethod
    def fromkeys(keys: Iterable[_K], value: _V) -> Dict[_K, _V]: ...
    def items(self) -> dict_items[_K, _V]: ...
    def keys(self) -> dict_keys[_K]: ...
    def pop(self, k) -> _V: ...
    def pop(self, k, d: _V2) -> Union[_V, _V2]: ...
    def setdefault(self, k: _K2) -> Union[_V, NoneType]:
        self = dict[Union[_K, _K2], Union[_V, NoneType]]
    def setdefault(self, k: _K2, v: _V2) -> Union[_V, _V2]:
        self = dict[Union[_K, _K2], Union[_V, _V2]]
    @overload
    def update(self) -> None: ...
    @overload
    def update(self, __m: dict[_K2, _V2]) -> None:
        self = dict[_K | _K2, _V | _V2]
    @overload
    def update(self, **kwargs: _V2) -> None:
        self = dict[_K | _K2, _V | _V2]
    @overload
    def update(self, __m: _SupportsKeysAndGetItem | Iterable[tuple[Any, Any]] = ..., **kwargs) -> None:
        self = dict[Any, Any]
    def values(self) -> dict_values[_V]: ...
    if sys.version_info >= (3, 9):
      def __or__(self, other: Mapping[_K2, _V2]) -> Dict[Union[_K, _K2], Union[_V, _V2]]: ...
      def __ror__(self, other: Mapping[_K2, _V2]) -> Dict[Union[_K, _K2], Union[_V, _V2]]: ...
      # __ior__ is equivalent to update.
      # It should be able to accept "an iterable...of iterables of length 2".
      # That's not something the type system can express, except for tuples.
      @overload
      def __ior__(self, other: dict[_K2, _V2]) -> Dict[Union[_K, _K2], Union[_V, _V2]]:
          self = dict[Union[_K, _K2], Union[_V, _V2]]
      @overload
      def __ior__(self, other: Iterable[Tuple[_K2, _V2]]) -> Dict[Union[_K, _K2], Union[_V, _V2]]:
          self = dict[Union[_K, _K2], Union[_V, _V2]]
      @overload
      def __ior__(self, other: _SupportsKeysAndGetItem | Iterable[tuple[Any, Any]]) -> Dict[Any, Any]:
          self = dict[Any, Any]

class listiterator(Iterator[_T]):
    __slots__ = []
    def __iter__(self) -> listiterator[_T]: ...
    def __next__(self) -> _T: ...

class enumerate(Iterator[tuple[int, _T]]):
    __slots__ = []
    def __init__(self, iterable: Iterable[_T2], start: int = ...) -> NoneType:
      self = enumerate[_T2]
    def __iter__(self) -> enumerate[_T]: ...  # enumerate.__iter__() returns itself
    def __next__(self) -> tuple[int, _T]: ...

class listreverseiterator(Iterator[_T]):
    __slots__ = []
    def __iter__(self) -> listreverseiterator[_T]: ...
    def __next__(self) -> _T: ...

class list(List[_T]):
    __slots__ = []
    def __init__(self) -> NoneType:
        self = list[nothing]
    def __init__(self, iterable: Iterable[_T2]) -> NoneType:
        self = list[_T2]
    def __add__(self, y: list[_T2]) -> list[Union[_T, _T2]]: ...
    def __contains__(self, y) -> bool: ...
    def __delitem__(self, y: Union[SupportsIndex, slice]) -> NoneType: ...
    def __delslice__(self, i: int, j: int) -> NoneType: ...
    def __getitem__(self, index: SupportsIndex) -> _T: ...
    def __getitem__(self, index: slice) -> list[_T]: ...
    def __getslice__(self, i: Optional[int], j: Optional[int]) -> list[_T]: ...
    def __iadd__(self, y: Iterable[_T2]) -> list[Union[_T, _T2]]:
      self = list[Union[_T, _T2]]
    def __iter__(self) -> listiterator[_T]: ...
    def __mul__(self, n: int) -> list[_T]: ...
    def __reversed__(self) -> listreverseiterator[_T]: ...
    def __setitem__(self, i: SupportsIndex, y: _T2) -> NoneType:
      self = list[Union[_T, _T2]]
    def __setitem__(self, i: slice, y) -> NoneType:
      self = list[Any]
    def __setslice__(self, i: int, j: int, y) -> NoneType: ...
    def append(self, object: _T2) -> NoneType:
      self = list[Union[_T, _T2]]
    def extend(self, i: Iterable[_T2]) -> NoneType:
      self = list[Union[_T, _T2]]
    def clear(self) -> NoneType:
      self = list[nothing]
    def copy(self) -> list[_T]: ...
    def count(self, value: _T) -> int: ...
    def index(self, value, *args, **kwargs) -> int: ...
    def insert(self, index: int, object: _T2) -> NoneType:
      self = list[Union[_T, _T2]]
    def pop(self) -> _T: ...
    def pop(self, i: int) -> _T: ...
    def remove(self, value: _T) -> NoneType: ...
    def reverse(self) -> NoneType: ...
    def sort(self, *args, **kwargs) -> NoneType: ...

# "reversed" is a type, see PyReversed_Type in Objects/enumobject.c
class reversed(Iterator[_T]):
    __slots__ = []
    def __init__(self, sequence: Reversible[_T2]) -> NoneType:
      self = reversed[_T2]
    def __iter__(self) -> reversed[_T]: ...
    def __next__(self) -> _T: ...

class tuple(Tuple[_T]):
    __slots__ = []
    def __init__(self) -> NoneType:
      self = Tuple[()]
    def __init__(self, p0: Iterable[_T2]) -> NoneType:
      self = tuple[_T2, ...]
    def __add__(self, y: tuple[_T2, ...]) -> tuple[Union[_T, _T2], ...]: ...
    def __contains__(self, y) -> bool: ...
    def __getitem__(self, index: int) -> _T: ...
    def __getitem__(self, index: slice) -> tuple[_T, ...]: ...
    def __getslice__(self, i: Optional[int], j: Optional[int]) -> tuple[_T, ...]: ...
    def __iter__(self) -> tupleiterator[_T]: ...
    def __mul__(self, n: int) -> tuple[_T, ...]: ...
    def count(self, value: _T) -> int: ...
    def index(self, value, *args, **kwargs) -> int: ...

class tupleiterator(Iterator[_T]):
    __slots__ = []
    def __iter__(self) -> tupleiterator[_T]: ...
    def __next__(self) -> _T: ...

class set(Set[_T]):
    __slots__ = []
    def __init__(self) -> NoneType:
        self = set[nothing]
    def __init__(self, iterable: Iterable[_T2]) -> NoneType:
        self = set[_T2]
    def __and__(self, y: Iterable) -> set[_T]: ...
    def __contains__(self, y) -> bool: ...
    def __iter__(self) -> setiterator[_T]: ...
    def __or__(self, y: Iterable[_T2]) -> set[Union[_T, _T2]]: ...
    def __sub__(self, y: Iterable) -> set[_T]: ...
    def __xor__(self, y: Iterable[_T2]) -> set[Union[_T, _T2]]: ...
    def clear(self) -> NoneType:
        self = set[nothing]
    def copy(self) -> set[_T]: ...
    def discard(self, y) -> NoneType: ...
    def difference_update(self, *args, **kwargs) -> NoneType: ...
    def symmetric_difference_update(self, *args, **kwargs) -> NoneType: ...
    def intersection_update(self, *args, **kwargs) -> NoneType: ...
    def isdisjoint(self, y: Iterable) -> bool: ...
    def issubset(self, y: Iterable) -> bool: ...
    def issuperset(self, y: Iterable) -> bool: ...
    def pop(self) -> _T: ...
    def remove(self, x) -> None: ...
    @overload
    def update(self, other: Iterable[_T2]) -> None:
      self = set[Union[_T, _T2]]
    @overload
    def update(self, *args, **kwargs) -> None:
        self = set[Any]
    def add(self, y: _T2) -> NoneType:
        self = set[Union[_T, _T2]]
    @overload
    def union(self, other: Iterable[_T2]) -> set[_T | _T2]: ...
    @overload
    def union(self, other1: Iterable[_T2], other2: Iterable[_T3]) -> set[_T | _T2 | _T3]: ...
    @overload
    def union(self, *args: Iterable[Any]) -> set[Any]: ...
    def intersection(self, *args: Iterable[Any]) -> set[_T]: ...
    def difference(self, *args: Iterable[Any]) -> set[_T]: ...
    def symmetric_difference(self, other: Iterable[_T2]) -> set[_T | _T2]: ...

class frozenset(FrozenSet[_T]):
    __slots__ = []
    def __init__(self) -> NoneType:
        self = frozenset[nothing]
    def __init__(self, x: Iterable[_T2]) -> NoneType:
        self = frozenset[_T2]
    def __and__(self, y: AbstractSet) -> frozenset[_T]: ...
    def __contains__(self, y) -> bool: ...
    def __iter__(self) -> setiterator[_T]: ...
    def __or__(self, y: AbstractSet[_T2]) -> frozenset[Union[_T, _T2]]: ...
    def __sub__(self, y: AbstractSet[_T2]) -> frozenset[_T]: ...
    def __xor__(self, y: AbstractSet[_T2]) -> frozenset[Union[_T, _T2]]: ...
    def copy(self, *args, **kwargs) -> frozenset[_T]: ...
    def isdisjoint(self, y: Iterable) -> bool: ...
    def issubset(self, y: Iterable) -> bool: ...
    def issuperset(self, y: Iterable) -> bool: ...
    @overload
    def union(self, other: Iterable[_T2]) -> frozenset[_T | _T2]: ...
    @overload
    def union(self, other1: Iterable[_T2], other2: Iterable[_T3]) -> frozenset[_T | _T2 | _T3]: ...
    @overload
    def union(self, *args: Iterable[Any]) -> frozenset[Any]: ...
    def intersection(self, *args: Iterable[Any]) -> frozenset[_T]: ...
    def difference(self, *args: Iterable[Any]) -> frozenset[_T]: ...
    def symmetric_difference(self, other: Iterable[_T2]) -> frozenset[_T | _T2]: ...

class setiterator(Iterator[_T]):
    __slots__ = []
    def __iter__(self) -> setiterator[_T]: ...
    def __next__(self) -> _T: ...

class bool(int, SupportsInt, SupportsFloat):
    __slots__ = []
    def __init__(self, x) -> NoneType: ...
    def __init__(self) -> NoneType: ...
    def __and__(self, y: bool) -> bool: ...
    def __and__(self, y: int) -> int: ...
    def __or__(self, y: bool) -> bool: ...
    def __or__(self, y: int) -> int: ...
    def __xor__(self, y: bool) -> bool: ...
    def __xor__(self, y: int) -> int: ...
    def __coerce__(self, y: int) -> Tuple[bool, int]: ...
    def __coerce__(self, y: bool) -> Tuple[bool, bool]: ...

# This class does not exist at runtime; it is here to help describe the types
# int accepts.
class _SupportsTrunc(Protocol):
  def __trunc__(self) -> int: ...

class int(SupportsInt, SupportsFloat, SupportsAbs[int]):
    __slots__ = []
    denominator: int
    numerator = ... # type: int
    real = ... # type: int
    imag = ... # type: int
    @overload
    def __init__(self) -> NoneType: ...
    @overload
    def __init__(self, x: Union[int, float, str, bytes, SupportsInt, SupportsIndex, _SupportsTrunc]) -> NoneType: ...
    @overload
    def __init__(self, x: Union[str, bytes], base: int) -> NoneType: ...
    def __add__(self, y: int) -> int: ...
    def __add__(self, y: float) -> float: ...
    def __add__(self, y: complex) -> complex: ...
    def __and__(self, y: int) -> int: ...
    def __and__(self, y: float) -> float: ...
    def __and__(self, y: complex) -> complex: ...
    def __div__(self, y: int) -> int: ...
    def __div__(self, y: float) -> float: ...
    def __div__(self, y: complex) -> complex: ...
    def __divmod__(self, y: int) -> Tuple[int, int]: ...
    def __divmod__(self, y: float) -> Tuple[float, float]: ...
    def __divmod__(self, y: complex) -> Tuple[complex, complex]: ...
    def __floordiv__(self, y: int) -> int: ...
    def __floordiv__(self, y: float) -> float: ...
    def __floordiv__(self, y: complex) -> complex: ...
    def __mod__(self, y: int) -> int: ...
    def __mod__(self, y: float) -> float: ...
    def __mod__(self, y: complex) -> complex: ...
    def __mul__(self, y: int) -> int: ...
    def __mul__(self, y: float) -> float: ...
    def __mul__(self, y: complex) -> complex: ...
    def __mul__(self, n: str) -> str: ...
    def __mul__(self, n: list[_T]) -> list[_T]: ...
    def __mul__(self, n: tuple[_T, ...]) -> tuple[_T, ...]: ...
    def __mul__(self, n: bytearray) -> bytearray: ...
    def __pow__(self, y: bool) -> int: ...
    def __pow__(self, y: int, modulo: int) -> int: ...
    def __pow__(self, y: int) -> Union[int, float]: ...  # 2 ** -1 == 0.5
    def __pow__(self, y: float) -> float: ...
    def __pow__(self, y: complex) -> complex: ...
    def __rshift__(self, y: int) -> int: ...
    def __sub__(self, y: int) -> int: ...
    def __sub__(self, y: float) -> float: ...
    def __sub__(self, y: complex) -> complex: ...
    def __truediv__(self, y: Union[int, float]) -> float: ...
    def __truediv__(self, y: complex) -> complex: ...
    def __coerce__(self, y: int) -> Tuple[int, int]: ...
    def __float__(self) -> float: ...
    def __hex__(self) -> str: ...
    if PYTYPE_OPTIONS.strict_primitive_comparisons:
        def __lt__(self, y: float, /) -> bool: ...
        def __le__(self, y: float, /) -> bool: ...
        def __gt__(self, y: float, /) -> bool: ...
        def __ge__(self, y: float, /) -> bool: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> int: ...
    def __long__(self) -> int: ...
    def __lshift__(self, y: int) -> int: ...
    def __neg__(self) -> int: ...
    def __nonzero__(self) -> bool: ...
    def __oct__(self) -> str: ...
    def __or__(self, y: int) -> int: ...
    def __pos__(self) -> int: ...
    def __trunc__(self, *args, **kwargs) -> int: ...
    def __xor__(self, y: int) -> int: ...
    if sys.version_info >= (3, 10):
        def bit_count(self) -> int: ...
    def bit_length(self) -> int: ...
    def conjugate(self) -> int: ...
    def to_bytes(self, length: int, byteorder: str, *, signed: bool = ...) -> bytes: ...
    @classmethod
    def from_bytes(cls, bytes: Sequence[int], byteorder: str, *, signed: bool = ...) -> int: ...
    if sys.version_info >= (3, 12):
        def is_integer(self) -> Literal[True]: ...

class float(SupportsInt, SupportsFloat, SupportsAbs):
    __slots__ = []
    real = ... # type: float
    imag = ... # type: float
    def __init__(self, x: Union[int, float, str, bytes, SupportsFloat]) -> NoneType: ...
    def __init__(self) -> NoneType: ...
    def __abs__(self) -> float: ...
    def __add__(self, y: Union[int, float]) -> float: ...
    def __add__(self, y: complex) -> complex: ...
    def __coerce__(self, y: Union[int, float]) -> Tuple[float, Union[float, int]]: ...
    def __div__(self, y: Union[int, float]) -> float: ...
    def __div__(self, y: complex) -> complex: ...
    def __divmod__(self, y: Union[int, float]) -> Tuple[float, float]: ...
    def __divmod__(self, y: complex) -> Tuple[complex, complex]: ...
    def __float__(self) -> float: ...
    def __floordiv__(self, y: Union[int, float]) -> float: ...
    def __floordiv__(self, y: complex) -> complex: ...
    def __hex__(self) -> str: ...
    if PYTYPE_OPTIONS.strict_primitive_comparisons:
        def __lt__(self, y: float, /) -> bool: ...
        def __le__(self, y: float, /) -> bool: ...
        def __gt__(self, y: float, /) -> bool: ...
        def __ge__(self, y: float, /) -> bool: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> int: ...
    def __long__(self) -> int: ...
    def __mod__(self, y: Union[int, float]) -> float: ...
    def __mod__(self, y: complex) -> complex: ...
    def __mul__(self, y: Union[int, float]) -> float: ...
    def __mul__(self, y: complex) -> complex: ...
    def __neg__(self) -> float: ...
    def __nonzero__(self) -> bool: ...
    def __oct__(self) -> str: ...
    def __pos__(self) -> float: ...
    def __pow__(self, y: Union[int, float]) -> float: ...
    def __pow__(self, y: complex) -> complex: ...
    def __sub__(self, y: Union[int, float]) -> float: ...
    def __sub__(self, y: complex) -> complex: ...
    def __truediv__(self, y: Union[int, float]) -> float: ...
    def __truediv__(self, y: complex) -> complex: ...
    def __trunc__(self, *args, **kwargs) -> int: ...
    def conjugate(self) -> float: ...
    def as_integer_ratio(self) -> tuple[int, int]: ...
    def hex(self) -> str: ...
    def is_integer(self) -> bool: ...

    @classmethod
    def fromhex(cls, string: str) -> float: ...

class complex(SupportsAbs, SupportsInt, SupportsFloat, SupportsComplex):
    __slots__ = []
    real = ... # type: float
    imag = ... # type: float
    def __init__(self, real: Union[int, float, complex, str, bytes, typing.SupportsComplex], *args, **kwargs) -> NoneType: ...
    def __init__(self) -> NoneType: ...
    def __abs__(self) -> float: ...
    def __add__(self, y: Union[int, float, complex]) -> complex: ...
    def __coerce__(self, y: Union[int, float, complex]) -> Tuple[complex, complex]: ...
    def __div__(self, y: Union[int, float, complex]) -> complex: ...
    def __divmod__(self, y: Union[int, float, complex]) -> Tuple[complex, complex]: ...
    def __floordiv__(self, y: Union[int, float, complex]) -> complex: ...
    def __mod__(self, y: Union[int, float, complex]) -> complex: ...
    def __mul__(self, y: Union[int, float, complex]) -> complex: ...
    def __neg__(self) -> complex: ...
    def __nonzero__(self) -> bool: ...
    def __pos__(self) -> complex: ...
    def __pow__(self, y: Union[int, float, complex]) -> complex: ...
    def __sub__(self, y: Union[int, float, complex]) -> complex: ...
    def __truediv__(self, y: Union[int, float, complex]) -> complex: ...
    def conjugate(self) -> complex: ...

class generator(Generator[_T, _T2, _V]):
    __slots__ = []
    def __iter__(self) -> generator[_T, _T2, _V]: ...
    def __next__(self) -> _T: ...
    def send(self, value: _T2) -> _T: ...
    def close(self) -> NoneType: ...

class coroutine(Coroutine[_T, _T2, _V]):
    __slots__ = []
    def close(self) -> NoneType: ...
    def send(self, value: _T2) -> _T: ...

class asyncgenerator(AsyncGenerator[_T, _T2]):
    __slots__ = []
    def __aiter__(self) -> asyncgenerator[_T, _T2]: ...
    def __anext__(self) -> coroutine[Any, Any, _T]: ...
    def asend(self, value: _T2) -> coroutine[Any, Any, _T]: ...
    def aclose(self) -> coroutine[Any, Any, None]: ...

class instancemethod(object):
    __slots__ = []
    def __init__(self, function: Union[Callable, instancemethod], instance, cls) -> NoneType: ...
    def __get__(self, obj, *args, **kwargs) -> instancemethod: ...

__path__: List[str]  # only sometimes present

class module(object):
    __doc__: str
    __file__: str
    __name__: str
    __package__: Optional[str]
    __path__: Iterable[str]  # only sometimes present
    def __init__(self, name: Union[str, bytearray], doc = ...) -> NoneType: ...
    def __getattr__(self, name) -> Any: ...  # modules can contain anything

class slice(object):
    __slots__ = []  # slices are readonly
    start: Optional[int]
    stop: Optional[int]
    step: Optional[int]
    def __init__(self, stop, *args, **kwargs) -> NoneType: ...
    def indices(self, len: int) -> tuple[int, int, int]: ...

# Definitions copied from https://github.com/python/typeshed/blob/main/stdlib/builtins.pyi;
class memoryview(Sequence[int]):
    __slots__ = []
    @property
    def format(self) -> str: ...
    @property
    def itemsize(self) -> int: ...
    @property
    def shape(self) -> tuple[int, ...] | None: ...
    @property
    def strides(self) -> tuple[int, ...] | None: ...
    @property
    def suboffsets(self) -> tuple[int, ...] | None: ...
    @property
    def readonly(self) -> bool: ...
    @property
    def ndim(self) -> int: ...
    @property
    def obj(self) -> Any: ...
    @property
    def c_contiguous(self) -> bool: ...
    @property
    def f_contiguous(self) -> bool: ...
    @property
    def contiguous(self) -> bool: ...
    @property
    def nbytes(self) -> int: ...
    def __init__(self, object: Any) -> None: ...
    def __enter__(self: memoryview) -> memoryview: ...
    def __exit__(
        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: Any | None
    ) -> None: ...
    def cast(self, format: str, shape: list[int] | tuple[int, ...] = ...) -> memoryview: ...
    @overload
    def __getitem__(self, index: int) -> int: ...
    @overload
    def __getitem__(self, index: tuple[int, ...]) -> int: ...
    @overload
    def __getitem__(self, index: slice) -> memoryview: ...
    def __contains__(self, object: object) -> bool: ...
    def __iter__(self) -> Iterator[int]: ...
    def __len__(self) -> int: ...
    @overload
    def __setitem__(self, index: slice, o: Any) -> None: ...
    @overload
    def __setitem__(self, index: int, o: int) -> None: ...
    @overload
    def __setitem__(self, index: tuple[int, ...], o: int) -> None: ...
    def __buffer__(self, __flags: int) -> memoryview: ...
    def __release_buffer__(self, __buffer: memoryview) -> None: ...
    if sys.version_info >= (3, 10):
        def tobytes(self, order: Literal["C", "F", "A"] | None = "C") -> bytes: ...
    else:
        def tobytes(self, order: Literal["C", "F", "A"] | None = None) -> bytes: ...

    def tolist(self) -> list[int]: ...
    def toreadonly(self) -> memoryview: ...
    def release(self) -> None: ...
    def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = ...) -> str: ...

class type(Callable, Type[_T]):
    __name__: str
    __module__: str
    __bases__: Tuple[type, ...]
    __base__: Optional[type]
    __dictoffset__: int
    __itemsize__: int
    def __new__(cls: Type[type], object: _T) -> Type[_T]: ...
    # The return type in the below two definitions is used only when abstract.py
    # isn't able to build a class from the arguments.
    def __new__(cls: Type[type], name: str, bases: tuple[type, ...], dict: Dict[str, Any], **kwargs) -> type: ...
    def __init__(self, object) -> None: ...
    def __init__(self, name, bases, dict,  **kwargs) -> None: ...
    def __subclasses__(self) -> List[type]: ...
    def __instancecheck__(self, object) -> bool: ...
    def __subclasscheck__(self, cls) -> bool: ...
    def mro(self) -> List[type]: ...

# Usually the class argument to super() already inherits from object. So to
# avoid confusion, super() inherits from nothing.
class super(nothing):
    __slots__ = []
    def __init__(self, *args, **kwargs) -> NoneType: ...
    def __get__(self, obj, *args, **kwargs) -> super: ...
    def __set__(self, obj, value) -> super: ...
    def __new__(cls: Type[super], *args, **kwargs) -> super: ...

class range(Sequence[int]):
    __slots__ = []
    start: int
    stop: int
    step: int
    def __init__(self, stop: SupportsIndex, *args, **kwargs) -> None: ...
    @overload
    def __getitem__(self, index: int) -> int: ...
    @overload
    def __getitem__(self, index: slice) -> range: ...
    def __iter__(self) -> Iterator[int]: ...
    def __len__(self) -> int: ...
    def __reversed__(self, *args, **kwargs) -> Iterator[int]: ...

# From Python/objects/capsule.c. Used e.g. by datetime.datetime_CAPI
class PyCapsule(object):
    pass

# types.CodeType, a.k.a., [type 'code']
# Definition copied from
# https://github.com/python/typeshed/blob/master/stdlib/types.pyi
class code(object):
    @property
    def co_argcount(self) -> int: ...
    @property
    def co_posonlyargcount(self) -> int: ...
    @property
    def co_kwonlyargcount(self) -> int: ...
    @property
    def co_nlocals(self) -> int: ...
    @property
    def co_stacksize(self) -> int: ...
    @property
    def co_flags(self) -> int: ...
    @property
    def co_code(self) -> bytes: ...
    @property
    def co_consts(self) -> tuple[Any, ...]: ...
    @property
    def co_names(self) -> tuple[str, ...]: ...
    @property
    def co_varnames(self) -> tuple[str, ...]: ...
    @property
    def co_filename(self) -> str: ...
    @property
    def co_name(self) -> str: ...
    @property
    def co_firstlineno(self) -> int: ...
    @property
    def co_lnotab(self) -> bytes: ...
    @property
    def co_freevars(self) -> tuple[str, ...]: ...
    @property
    def co_cellvars(self) -> tuple[str, ...]: ...
    if sys.version_info >= (3, 10):
        @property
        def co_linetable(self) -> bytes: ...
        def co_lines(self) -> Iterator[tuple[int, int, int | None]]: ...
    if sys.version_info >= (3, 11):
        @property
        def co_exceptiontable(self) -> bytes: ...
        @property
        def co_qualname(self) -> str: ...
        def co_positions(self) -> Iterable[tuple[int | None, int | None, int | None, int | None]]: ...

    if sys.version_info >= (3, 11):
        def __init__(
            self,
            __argcount: int,
            __posonlyargcount: int,
            __kwonlyargcount: int,
            __nlocals: int,
            __stacksize: int,
            __flags: int,
            __codestring: bytes,
            __constants: tuple[object, ...],
            __names: tuple[str, ...],
            __varnames: tuple[str, ...],
            __filename: str,
            __name: str,
            __qualname: str,
            __firstlineno: int,
            __linetable: bytes,
            __exceptiontable: bytes,
            __freevars: tuple[str, ...] = ...,
            __cellvars: tuple[str, ...] = ...,
        ) -> None: ...
    elif sys.version_info >= (3, 10):
        def __init__(
            self,
            __argcount: int,
            __posonlyargcount: int,
            __kwonlyargcount: int,
            __nlocals: int,
            __stacksize: int,
            __flags: int,
            __codestring: bytes,
            __constants: tuple[object, ...],
            __names: tuple[str, ...],
            __varnames: tuple[str, ...],
            __filename: str,
            __name: str,
            __firstlineno: int,
            __linetable: bytes,
            __freevars: tuple[str, ...] = ...,
            __cellvars: tuple[str, ...] = ...,
        ) -> None: ...
    else:
        def __init__(
            self,
            __argcount: int,
            __posonlyargcount: int,
            __kwonlyargcount: int,
            __nlocals: int,
            __stacksize: int,
            __flags: int,
            __codestring: bytes,
            __constants: tuple[object, ...],
            __names: tuple[str, ...],
            __varnames: tuple[str, ...],
            __filename: str,
            __name: str,
            __firstlineno: int,
            __lnotab: bytes,
            __freevars: tuple[str, ...] = ...,
            __cellvars: tuple[str, ...] = ...,
        ) -> None: ...
    if sys.version_info >= (3, 11):
        def replace(
            self,
            *,
            co_argcount: int = ...,
            co_posonlyargcount: int = ...,
            co_kwonlyargcount: int = ...,
            co_nlocals: int = ...,
            co_stacksize: int = ...,
            co_flags: int = ...,
            co_firstlineno: int = ...,
            co_code: bytes = ...,
            co_consts: tuple[object, ...] = ...,
            co_names: tuple[str, ...] = ...,
            co_varnames: tuple[str, ...] = ...,
            co_freevars: tuple[str, ...] = ...,
            co_cellvars: tuple[str, ...] = ...,
            co_filename: str = ...,
            co_name: str = ...,
            co_qualname: str = ...,
            co_linetable: bytes = ...,
            co_exceptiontable: bytes = ...,
        ) -> code: ...
    elif sys.version_info >= (3, 10):
        def replace(
            self,
            *,
            co_argcount: int = ...,
            co_posonlyargcount: int = ...,
            co_kwonlyargcount: int = ...,
            co_nlocals: int = ...,
            co_stacksize: int = ...,
            co_flags: int = ...,
            co_firstlineno: int = ...,
            co_code: bytes = ...,
            co_consts: tuple[object, ...] = ...,
            co_names: tuple[str, ...] = ...,
            co_varnames: tuple[str, ...] = ...,
            co_freevars: tuple[str, ...] = ...,
            co_cellvars: tuple[str, ...] = ...,
            co_filename: str = ...,
            co_name: str = ...,
            co_linetable: bytes = ...,
        ) -> code: ...
    else:
        def replace(
            self,
            *,
            co_argcount: int = ...,
            co_posonlyargcount: int = ...,
            co_kwonlyargcount: int = ...,
            co_nlocals: int = ...,
            co_stacksize: int = ...,
            co_flags: int = ...,
            co_firstlineno: int = ...,
            co_code: bytes = ...,
            co_consts: tuple[object, ...] = ...,
            co_names: tuple[str, ...] = ...,
            co_varnames: tuple[str, ...] = ...,
            co_freevars: tuple[str, ...] = ...,
            co_cellvars: tuple[str, ...] = ...,
            co_filename: str = ...,
            co_name: str = ...,
            co_lnotab: bytes = ...,
        ) -> code: ...

class ArithmeticError(StandardError):
    pass

class AssertionError(StandardError):
    pass

class AttributeError(StandardError):
    if sys.version_info >= (3, 10):
        name: str
        obj: Any

# Note: __traceback__ and with_traceback should use types.TracebackType, but
# builtins can't depend on other modules.
_TBE = TypeVar("_TBE", bound="BaseException")

class BaseException(object):
    args: Tuple[Any, ...]
    __cause__: Optional[BaseException]
    __context__: Optional[BaseException]
    __suppress_context__: bool
    __traceback__: Optional[Any]
    def __init__(self, *args, **kwargs) -> NoneType: ...
    def with_traceback(self: _TBE, tb: Optional[Any]) -> _TBE: ...
    if sys.version_info >= (3, 11):
        # only present after add_note() is called
        __notes__: list[str]
        def add_note(self, __note: str) -> None: ...

class BufferError(StandardError):
    pass

class BytesWarning(Warning):
    pass

class DeprecationWarning(Warning):
    pass

class EOFError(StandardError):
    pass

EnvironmentError = OSError

class Exception(BaseException):
    pass

class FloatingPointError(ArithmeticError):
    pass

class FutureWarning(Warning):
    pass

class GeneratorExit(BaseException):
    pass

IOError = OSError

class ImportError(StandardError):
    name: str
    path: str
    msg: str  # undocumented
    if sys.version_info >= (3, 12):
        name_from: str | None  # undocumented

class ImportWarning(Warning):
    pass

class IndentationError(SyntaxError):
    pass

class IndexError(LookupError):
    pass

class KeyError(LookupError):
    pass

class KeyboardInterrupt(BaseException):
    pass

class LookupError(StandardError):
    pass

class MemoryError(StandardError):
    pass

class NameError(StandardError):
    if sys.version_info >= (3, 10):
        name: str

class NotImplementedError(RuntimeError):
    pass

class OSError(Exception):
    errno: int
    filename: str
    filename2: str
    strerror: str

class OverflowError(ArithmeticError):
    pass

class PendingDeprecationWarning(Warning):
    pass

class ReferenceError(StandardError):
    pass

class RuntimeError(StandardError):
    pass

class RuntimeWarning(Warning):
    pass

class StandardError(Exception):
    pass

class StopIteration(Exception):
    value: Any

class SyntaxError(StandardError):
    filename: str
    lineno: int
    msg: str
    offset: int
    print_file_and_line: Optional[str]
    text: str
    if sys.version_info >= (3, 10):
        end_lineno: int
        end_offset: int

class SyntaxWarning(Warning):
    pass

class SystemError(StandardError):
    pass

class SystemExit(BaseException):
    code: int

class TabError(IndentationError):
    pass

class TypeError(StandardError):
    pass

class UnboundLocalError(NameError):
    pass

class UnicodeError(ValueError):
    pass

class UnicodeDecodeError(UnicodeError):
    encoding: str
    object: str
    start: int
    end: int
    reason: str
    def __init__(self, encoding: str, object: bytes, start: int, end: int, reason: str) -> None: ...

class UnicodeEncodeError(UnicodeError):
    encoding: str
    object: str
    start: int
    end: int
    reason: str
    def __init__(self, encoding: str, object: str, start: int, end: int, reason: str) -> None: ...

class UnicodeTranslateError(UnicodeError):
    encoding: str
    object: str
    start: int
    end: int
    reason: str
    def __init__(self, object: str, start: int, end: int, reason: str) -> None: ...

class UnicodeWarning(Warning):
    pass

class UserWarning(Warning):
    pass

class ValueError(StandardError):
    pass

class Warning(Exception):
    pass

class ZeroDivisionError(ArithmeticError):
    pass

# -------------------------------------------------------------------
# Everything below this is new in python3

class BlockingIOError(OSError):
    characters_written: int
class ChildProcessError(OSError): ...
class FileExistsError(OSError): ...
class FileNotFoundError(OSError): ...
class InterruptedError(OSError): ...
class IsADirectoryError(OSError): ...
class NotADirectoryError(OSError): ...
class PermissionError(OSError): ...
class ProcessLookupError(OSError): ...
class TimeoutError(OSError): ...

class ResourceWarning(Warning): ...

# Connection errors
class ConnectionError(OSError): ...
class BrokenPipeError(ConnectionError): ...
class ConnectionAbortedError(ConnectionError): ...
class ConnectionRefusedError(ConnectionError): ...
class ConnectionResetError(ConnectionError): ...

class StopAsyncIteration(Exception):
    value: Any
class RecursionError(RuntimeError): ...

class ModuleNotFoundError(ImportError): ...

# This class is to be exported as PathLike from os,
# but we define it here as _PathLike to avoid import cycle issues.
# See https://github.com/python/typeshed/pull/991#issuecomment-288160993
class _PathLike(Generic[_AnyStr], Protocol):
    def __fspath__(self) -> _AnyStr: ...
_FileType = Union[str, bytes, int, _PathLike]

@overload
def open(
    file: _FileType,
    mode: Literal["rb", "wb", "ab", "xb", "r+b", "w+b", "a+b", "x+b", "rb+", "wb+", "ab+", "xb+"],
    buffering: int = ...,
    encoding: Optional[str] = ...,
    errors: Optional[str] = ...,
    newline: Optional[str] = ...,
    closefd: bool = ...,
) -> BinaryIO: ...
@overload
def open(
    file: _FileType,
    mode: Literal["r", "w", "a", "x", "r+", "w+", "a+", "x+", "rt", "wt", "at", "xt", "r+t", "w+t", "a+t", "x+t", "rt+", "wt+", "at+", "xt+"] = ...,
    buffering: int = ...,
    encoding: Optional[str] = ...,
    errors: Optional[str] = ...,
    newline: Optional[str] = ...,
    closefd: bool = ...,
) -> TextIO: ...
@overload
def open(
    file: _FileType,
    mode: str,
    buffering: int = ...,
    encoding: Optional[str] = ...,
    errors: Optional[str] = ...,
    newline: Optional[str] = ...,
    closefd: bool = ...,
) -> IO: ...

if sys.version_info >= (3, 11):
    class BaseExceptionGroup(BaseException, Generic[_T]):
        def __new__(cls, __message: str, __exceptions: Sequence[_T]) -> Self: ...
        def __init__(self, __message: str, __exceptions: Sequence[_T]) -> None: ...
        @property
        def message(self) -> str: ...
        @property
        def exceptions(self) -> tuple[_T | BaseExceptionGroup[_T], ...]: ...
        @overload
        def subgroup(
            self, __condition: type[_T2] | tuple[type[_T2], ...]
        ) -> ExceptionGroup[_T2] | None: ...
        @overload
        def subgroup(
            self, __condition: type[_T3] | tuple[type[_T3], ...]
        ) -> BaseExceptionGroup[_T3] | None: ...
        @overload
        def subgroup(
            self, __condition: Callable[[_T | Self], bool]
        ) -> BaseExceptionGroup[_T] | None: ...
        @overload
        def split(
            self, __condition: type[_T2] | tuple[type[_T2], ...]
        ) -> tuple[ExceptionGroup[_T2] | None, BaseExceptionGroup[_T] | None]: ...
        @overload
        def split(
            self, __condition: type[_T3] | tuple[type[_T3], ...]
        ) -> tuple[BaseExceptionGroup[_T3] | None, BaseExceptionGroup[_T] | None]: ...
        @overload
        def split(
            self, __condition: Callable[[_T | Self], bool]
        ) -> tuple[BaseExceptionGroup[_T] | None, BaseExceptionGroup[_T] | None]: ...
        # In reality it is `NonEmptySequence`:
        @overload
        def derive(self, __excs: Sequence[_T2]) -> ExceptionGroup[_T2]: ...
        @overload
        def derive(self, __excs: Sequence[_T3]) -> BaseExceptionGroup[_T3]: ...
        def __class_getitem__(cls, __item: Any) -> Any: ...

    class ExceptionGroup(BaseExceptionGroup[_T], Exception):
        def __new__(cls, __message: str, __exceptions: Sequence[_T]) -> Self: ...
        def __init__(self, __message: str, __exceptions: Sequence[_T]) -> None: ...
        @property
        def exceptions(self) -> tuple[_T | ExceptionGroup[_T], ...]: ...
        # We accept a narrower type, but that's OK.
        @overload  # type: ignore[override]
        def subgroup(
            self, __condition: type[_T2] | tuple[type[_T2], ...]
        ) -> ExceptionGroup[_T2] | None: ...
        @overload
        def subgroup(self, __condition: Callable[[_T | Self], bool]) -> ExceptionGroup[_T] | None: ...
        @overload  # type: ignore[override]
        def split(
            self, __condition: type[_T2] | tuple[type[_T2], ...]
        ) -> tuple[ExceptionGroup[_T2] | None, ExceptionGroup[_T] | None]: ...
        @overload
        def split(
            self, __condition: Callable[[_T | Self], bool]
        ) -> tuple[ExceptionGroup[_T] | None, ExceptionGroup[_T] | None]: ...
