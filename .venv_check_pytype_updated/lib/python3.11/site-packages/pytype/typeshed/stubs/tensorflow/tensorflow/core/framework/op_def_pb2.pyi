"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import collections.abc
import typing as typing_extensions

import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.message
import tensorflow.core.framework.attr_value_pb2
import tensorflow.core.framework.full_type_pb2
import tensorflow.core.framework.resource_handle_pb2
import tensorflow.core.framework.types_pb2

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class OpDef(google.protobuf.message.Message):
    """Defines an operation. A NodeDef in a GraphDef specifies an Op by
    using the "op" field which should match the name of a OpDef.
    LINT.IfChange
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class ArgDef(google.protobuf.message.Message):
        """For describing inputs and outputs."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        DESCRIPTION_FIELD_NUMBER: builtins.int
        TYPE_FIELD_NUMBER: builtins.int
        TYPE_ATTR_FIELD_NUMBER: builtins.int
        NUMBER_ATTR_FIELD_NUMBER: builtins.int
        TYPE_LIST_ATTR_FIELD_NUMBER: builtins.int
        HANDLE_DATA_FIELD_NUMBER: builtins.int
        IS_REF_FIELD_NUMBER: builtins.int
        EXPERIMENTAL_FULL_TYPE_FIELD_NUMBER: builtins.int
        name: builtins.str
        """Name for the input/output.  Should match the regexp "[a-z][a-z0-9_]*"."""
        description: builtins.str
        """Human readable description."""
        type: tensorflow.core.framework.types_pb2.DataType.ValueType
        """Describes the type of one or more tensors that are accepted/produced
        by this input/output arg.  The only legal combinations are:
        * For a single tensor: either the "type" field is set or the
          "type_attr" field is set to the name of an attr with type "type".
        * For a sequence of tensors with the same type: the "number_attr"
          field will be set to the name of an attr with type "int", and
          either the "type" or "type_attr" field will be set as for
          single tensors.
        * For a sequence of tensors, the "type_list_attr" field will be set
          to the name of an attr with type "list(type)".
        """
        type_attr: builtins.str
        """if specified, attr must have type "type" """
        number_attr: builtins.str
        """if specified, attr must have type "int" """
        type_list_attr: builtins.str
        """If specified, attr must have type "list(type)", and none of
        type, type_attr, and number_attr may be specified.
        """
        @property
        def handle_data(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[tensorflow.core.framework.resource_handle_pb2.ResourceHandleProto.DtypeAndShape]:
            """The handle data for resource inputs."""
        is_ref: builtins.bool
        """For inputs: if true, the inputs are required to be refs.
          By default, inputs can be either refs or non-refs.
        For outputs: if true, outputs are refs, otherwise they are not.
        """
        @property
        def experimental_full_type(self) -> tensorflow.core.framework.full_type_pb2.FullTypeDef:
            """Experimental. Full type declaration for this argument.
            The full type specification combines type, type_attr, type_list_attr,
            etc. into a unified representation.
            This declaration may contain non-concrete types (for example,
            Tensor<TypeVar<'T'>> is a valid type declaration.

            Note: this is a transient field. The long-term aim is to represent the
            entire OpDef as a single type: a callable. In that context, this field is
            just the type of a single argument.
            """
        def __init__(
            self,
            *,
            name: builtins.str | None = ...,
            description: builtins.str | None = ...,
            type: tensorflow.core.framework.types_pb2.DataType.ValueType | None = ...,
            type_attr: builtins.str | None = ...,
            number_attr: builtins.str | None = ...,
            type_list_attr: builtins.str | None = ...,
            handle_data: collections.abc.Iterable[tensorflow.core.framework.resource_handle_pb2.ResourceHandleProto.DtypeAndShape] | None = ...,
            is_ref: builtins.bool | None = ...,
            experimental_full_type: tensorflow.core.framework.full_type_pb2.FullTypeDef | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["experimental_full_type", b"experimental_full_type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["description", b"description", "experimental_full_type", b"experimental_full_type", "handle_data", b"handle_data", "is_ref", b"is_ref", "name", b"name", "number_attr", b"number_attr", "type", b"type", "type_attr", b"type_attr", "type_list_attr", b"type_list_attr"]) -> None: ...

    @typing_extensions.final
    class AttrDef(google.protobuf.message.Message):
        """Description of the graph-construction-time configuration of this
        Op.  That is to say, this describes the attr fields that will
        be specified in the NodeDef.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        NAME_FIELD_NUMBER: builtins.int
        TYPE_FIELD_NUMBER: builtins.int
        DEFAULT_VALUE_FIELD_NUMBER: builtins.int
        DESCRIPTION_FIELD_NUMBER: builtins.int
        HAS_MINIMUM_FIELD_NUMBER: builtins.int
        MINIMUM_FIELD_NUMBER: builtins.int
        ALLOWED_VALUES_FIELD_NUMBER: builtins.int
        name: builtins.str
        """A descriptive name for the argument.  May be used, e.g. by the
        Python client, as a keyword argument name, and so should match
        the regexp "[a-z][a-z0-9_]+".
        """
        type: builtins.str
        """One of the type names from attr_value.proto ("string", "list(string)",
        "int", etc.).
        """
        @property
        def default_value(self) -> tensorflow.core.framework.attr_value_pb2.AttrValue:
            """A reasonable default for this attribute if the user does not supply
            a value.  If not specified, the user must supply a value.
            """
        description: builtins.str
        """Human-readable description."""
        has_minimum: builtins.bool
        """--- Constraints ---
        These constraints are only in effect if specified.  Default is no
        constraints.

        For type == "int", this is a minimum value.  For "list(___)"
        types, this is the minimum length.
        """
        minimum: builtins.int
        @property
        def allowed_values(self) -> tensorflow.core.framework.attr_value_pb2.AttrValue:
            """The set of allowed values.  Has type that is the "list" version
            of the "type" field above (uses the "list" field of AttrValue).
            If type == "type" or "list(type)" above, then the "type" field
            of "allowed_values.list" has the set of allowed DataTypes.
            If type == "string" or "list(string)", then the "s" field of
            "allowed_values.list" has the set of allowed strings.
            """
        def __init__(
            self,
            *,
            name: builtins.str | None = ...,
            type: builtins.str | None = ...,
            default_value: tensorflow.core.framework.attr_value_pb2.AttrValue | None = ...,
            description: builtins.str | None = ...,
            has_minimum: builtins.bool | None = ...,
            minimum: builtins.int | None = ...,
            allowed_values: tensorflow.core.framework.attr_value_pb2.AttrValue | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["allowed_values", b"allowed_values", "default_value", b"default_value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["allowed_values", b"allowed_values", "default_value", b"default_value", "description", b"description", "has_minimum", b"has_minimum", "minimum", b"minimum", "name", b"name", "type", b"type"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    INPUT_ARG_FIELD_NUMBER: builtins.int
    OUTPUT_ARG_FIELD_NUMBER: builtins.int
    CONTROL_OUTPUT_FIELD_NUMBER: builtins.int
    ATTR_FIELD_NUMBER: builtins.int
    DEPRECATION_FIELD_NUMBER: builtins.int
    SUMMARY_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    IS_COMMUTATIVE_FIELD_NUMBER: builtins.int
    IS_AGGREGATE_FIELD_NUMBER: builtins.int
    IS_STATEFUL_FIELD_NUMBER: builtins.int
    ALLOWS_UNINITIALIZED_INPUT_FIELD_NUMBER: builtins.int
    IS_DISTRIBUTED_COMMUNICATION_FIELD_NUMBER: builtins.int
    name: builtins.str
    """Op names starting with an underscore are reserved for internal use.
    Names should be CamelCase and match the regexp "[A-Z][a-zA-Z0-9>_]*".
    """
    @property
    def input_arg(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OpDef.ArgDef]:
        """Description of the input(s)."""
    @property
    def output_arg(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OpDef.ArgDef]:
        """Description of the output(s)."""
    @property
    def control_output(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Named control outputs for this operation. Useful only for composite
        operations (i.e. functions) which want to name different control outputs.
        """
    @property
    def attr(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OpDef.AttrDef]: ...
    @property
    def deprecation(self) -> global___OpDeprecation:
        """Optional deprecation based on GraphDef versions."""
    summary: builtins.str
    """One-line human-readable description of what the Op does."""
    description: builtins.str
    """Additional, longer human-readable description of what the Op does."""
    is_commutative: builtins.bool
    """-------------------------------------------------------------------------
    Which optimizations this operation can participate in.

    True if the operation is commutative ("op(a,b) == op(b,a)" for all inputs)
    """
    is_aggregate: builtins.bool
    """If is_aggregate is true, then this operation accepts N >= 2
    inputs and produces 1 output all of the same type.  Should be
    associative and commutative, and produce output with the same
    shape as the input.  The optimizer may replace an aggregate op
    taking input from multiple devices with a tree of aggregate ops
    that aggregate locally within each device (and possibly within
    groups of nearby devices) before communicating.
    TODO(josh11b): Implement that optimization.
    for things like add
    """
    is_stateful: builtins.bool
    """-------------------------------------------------------------------------
    Optimization constraints.

    Ops are marked as stateful if their behavior depends on some state beyond
    their input tensors (e.g. variable reading op) or if they have
    a side-effect (e.g. printing or asserting ops). Equivalently, stateless ops
    must always produce the same output for the same input and have
    no side-effects.

    By default Ops may be moved between devices.  Stateful ops should
    either not be moved, or should only be moved if that state can also
    be moved (e.g. via some sort of save / restore).
    Stateful ops are guaranteed to never be optimized away by Common
    Subexpression Elimination (CSE).
    for things like variables, queue
    """
    allows_uninitialized_input: builtins.bool
    """-------------------------------------------------------------------------
    Non-standard options.

    By default, all inputs to an Op must be initialized Tensors.  Ops
    that may initialize tensors for the first time should set this
    field to true, to allow the Op to take an uninitialized Tensor as
    input.
    for Assign, etc.
    """
    is_distributed_communication: builtins.bool
    """Indicates whether the op implementation uses distributed communication.
    If True, the op is allowed to return errors for network disconnection and
    trigger TF network failure handling logics.
    """
    def __init__(
        self,
        *,
        name: builtins.str | None = ...,
        input_arg: collections.abc.Iterable[global___OpDef.ArgDef] | None = ...,
        output_arg: collections.abc.Iterable[global___OpDef.ArgDef] | None = ...,
        control_output: collections.abc.Iterable[builtins.str] | None = ...,
        attr: collections.abc.Iterable[global___OpDef.AttrDef] | None = ...,
        deprecation: global___OpDeprecation | None = ...,
        summary: builtins.str | None = ...,
        description: builtins.str | None = ...,
        is_commutative: builtins.bool | None = ...,
        is_aggregate: builtins.bool | None = ...,
        is_stateful: builtins.bool | None = ...,
        allows_uninitialized_input: builtins.bool | None = ...,
        is_distributed_communication: builtins.bool | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["deprecation", b"deprecation"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["allows_uninitialized_input", b"allows_uninitialized_input", "attr", b"attr", "control_output", b"control_output", "deprecation", b"deprecation", "description", b"description", "input_arg", b"input_arg", "is_aggregate", b"is_aggregate", "is_commutative", b"is_commutative", "is_distributed_communication", b"is_distributed_communication", "is_stateful", b"is_stateful", "name", b"name", "output_arg", b"output_arg", "summary", b"summary"]) -> None: ...

global___OpDef = OpDef

@typing_extensions.final
class OpDeprecation(google.protobuf.message.Message):
    """Information about version-dependent deprecation of an op"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    VERSION_FIELD_NUMBER: builtins.int
    EXPLANATION_FIELD_NUMBER: builtins.int
    version: builtins.int
    """First GraphDef version at which the op is disallowed."""
    explanation: builtins.str
    """Explanation of why it was deprecated and what to use instead."""
    def __init__(
        self,
        *,
        version: builtins.int | None = ...,
        explanation: builtins.str | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["explanation", b"explanation", "version", b"version"]) -> None: ...

global___OpDeprecation = OpDeprecation

@typing_extensions.final
class OpList(google.protobuf.message.Message):
    """A collection of OpDefs"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OP_FIELD_NUMBER: builtins.int
    @property
    def op(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___OpDef]: ...
    def __init__(
        self,
        *,
        op: collections.abc.Iterable[global___OpDef] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["op", b"op"]) -> None: ...

global___OpList = OpList
